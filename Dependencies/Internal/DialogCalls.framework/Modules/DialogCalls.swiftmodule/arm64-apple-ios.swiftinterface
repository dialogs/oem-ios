// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.3 (swiftlang-1200.0.29.2 clang-1200.0.30.1)
// swift-module-flags: -target arm64-apple-ios11.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name DialogCalls
import DialogBasics
@_exported import DialogCalls
import DialogCalls_GRPC
import DialogMessaging
import DialogMetrics
import DialogNetService
import DialogProtocols
import DialogRx
import DialogSDK_GRPC
import DialogStorage
import DialogSwiftGRPCExtra
import Foundation
import GRDB
import Reachability
import RxCocoa
import RxRelay
import RxSwift
import RxSwiftExt
import Swift
import SwiftGRPC
import SwiftProtobuf
import WebRTC
import XCGLogger
import os
public struct AnyCallSession : DialogCalls.CallSessionProtocol {
  public var uuid: Foundation.UUID {
    get
  }
  public var id: DialogCalls.CallID {
    get
  }
  public var callDataModel: DialogCalls.CallDataModel {
    get
  }
  public var isOngoing: Swift.Bool {
    get
    set
  }
  public var isOnHold: Swift.Bool {
    get
    set
  }
  public var isOngoingObservable: RxSwift.Observable<Swift.Bool> {
    get
  }
  public var startAudioDateObservable: RxSwift.Observable<Foundation.Date?> {
    get
  }
  public var peerConnectionObserver: DialogCalls.CallPeerConnectionObserving {
    get
  }
  public func setMuted(_ value: Swift.Bool)
  public func toggleVideo(_ value: Swift.Bool)
  public func ringing() -> RxSwift.Observable<Swift.Void>
  public func create(_ event: DialogCalls.CreateEvent)
  public func answer(_ event: DialogCalls.AnswerEvent)
  public func renegotiate(_ event: DialogCalls.RenegotiateEvent)
  public func join(_ event: DialogCalls.JoinEvent)
  public func ices(_ event: DialogCalls.IcesEvent)
  public func dispose()
  public func merged(newCallModel: DialogCalls.CallDataModel) -> (DialogCalls.CallSessionProtocol, DialogCalls.AnswerEvent)
  public func hangup(withReason reason: DialogCalls.CallHangupReason) -> RxSwift.Observable<Swift.Void>
  public func hangup(hangupReason: DialogCalls.CallHangupReason, disposeReason: DialogCalls.CallDisposeReason) -> RxSwift.Observable<Swift.Void>
  public var localAudio: WebRTC.RTCAudioTrack? {
    get
  }
  public var localAudioObservable: RxSwift.Observable<WebRTC.RTCAudioTrack?> {
    get
  }
  public var isLocalAudioEnabled: Swift.Bool {
    get
  }
  public var isLocalAudioEnabledObservable: RxSwift.Observable<Swift.Bool> {
    get
  }
  public var isLocalVideoEnabled: Swift.Bool {
    get
  }
  public var localVideo: DialogCalls.LocalVideo? {
    get
  }
  public var localVideoObservable: RxSwift.Observable<DialogCalls.LocalVideo?> {
    get
  }
  public var isLocalVideoEnabledObservable: RxSwift.Observable<Swift.Bool> {
    get
  }
  public var remoteAudioAdapterObservable: RxSwift.Observable<DialogCalls.AudioTrackAdapter?> {
    get
  }
  public var remoteVideoAdapterObservable: RxSwift.Observable<DialogCalls.VideoTrackAdapter?> {
    get
  }
  public var audioTrackAudioMediaReports: RxSwift.Observable<[DialogCalls.StatsReport]> {
    get
  }
  public var videoTrackVideoMediaReports: RxSwift.Observable<[DialogCalls.StatsReport]> {
    get
  }
  public var isVideoPacketsReceiving: RxSwift.Observable<DialogCalls.MediaPacketsReceivingState> {
    get
  }
  public var isAudioPacketsReceiving: RxSwift.Observable<DialogCalls.MediaPacketsReceivingState> {
    get
  }
}
extension AnyCallSession : Swift.Equatable {
  public static func == (lhs: DialogCalls.AnyCallSession, rhs: DialogCalls.AnyCallSession) -> Swift.Bool
}
extension CallSessionProtocol {
  public var asAny: DialogCalls.AnyCallSession {
    get
  }
}
public protocol CallDataModelProtocol : AnyObject {
  var callIdentifiers: DialogCalls.CallIdentifiersModel { get }
  var instanceId: Swift.Int32? { get set }
  var direction: DialogProtocols.CallDirection { get }
  var state: DialogCalls.CallState { get }
  var stateObservable: RxSwift.Observable<DialogCalls.CallState> { get }
  var answerDateUTC: Foundation.Date? { get }
  var answerDateUTCObservable: RxSwift.Observable<Foundation.Date?> { get }
  var isCurrentDevice: Swift.Bool { get }
  var isCurrentDeviceObservable: RxSwift.Observable<Swift.Bool> { get }
  var isRemoteVideoOn: Swift.Bool { get }
  var isRemoteVideoOnObservable: RxSwift.Observable<Swift.Bool> { get }
  var parameters: DialogCalls.MappedCallParameters { get }
  var parametersObservable: RxSwift.Observable<DialogCalls.MappedCallParameters> { get }
  var mergeModel: DialogCalls.MergeCallModel? { get }
  var mergeModelObservable: RxSwift.Observable<DialogCalls.MergeCallModel?> { get }
  var isOptimistic: Swift.Bool { get }
  var isOptimisticObservable: RxSwift.Observable<Swift.Bool> { get }
  var peer: DialogProtocols.DialogPeer? { get }
  var peerObservable: RxSwift.Observable<DialogProtocols.DialogPeer?> { get }
}
public class CallDataModel : DialogCalls.CallDataModelProtocol {
  final public let callIdentifiers: DialogCalls.CallIdentifiersModel
  public var instanceId: Swift.Int32?
  final public let direction: DialogProtocols.CallDirection
  public var stateObservable: RxSwift.Observable<DialogCalls.CallState> {
    get
    set
  }
  public var answerDateUTCObservable: RxSwift.Observable<Foundation.Date?> {
    get
    set
  }
  public var isCurrentDeviceObservable: RxSwift.Observable<Swift.Bool> {
    get
    set
  }
  public var isRemoteVideoOnObservable: RxSwift.Observable<Swift.Bool> {
    get
    set
  }
  public var parametersObservable: RxSwift.Observable<DialogCalls.MappedCallParameters> {
    get
    set
  }
  public var mergeModelObservable: RxSwift.Observable<DialogCalls.MergeCallModel?> {
    get
    set
  }
  public var isOptimisticObservable: RxSwift.Observable<Swift.Bool> {
    get
    set
  }
  public var peerObservable: RxSwift.Observable<DialogProtocols.DialogPeer?> {
    get
    set
  }
  public init(callIdentifiers: DialogCalls.CallIdentifiersModel, instanceId: Swift.Int32?, direction: DialogProtocols.CallDirection, initialState: DialogCalls.CallState, answerDateUTC: Foundation.Date? = nil, isCurrentDevice: Swift.Bool, isRemoteVideoOn: Swift.Bool, parameters: [Swift.String : Swift.String], mergeModel: DialogCalls.MergeCallModel?, peer: DialogProtocols.DialogPeer? = nil, isOptimistic: Swift.Bool = false)
  public static func buildOptimisticCallModel(forDirection direction: DialogProtocols.CallDirection, with identifiers: DialogCalls.CallIdentifiersModel, peer: DialogProtocols.DialogPeer? = nil, hasVideo: Swift.Bool, params: [Swift.String : Swift.String]) -> DialogCalls.CallDataModel
  @objc deinit
}
extension CallDataModel {
  public var state: DialogCalls.CallState {
    get
  }
  public var answerDateUTC: Foundation.Date? {
    get
  }
  public var parameters: DialogCalls.MappedCallParameters {
    get
  }
  public var mergeModel: DialogCalls.MergeCallModel? {
    get
  }
  public var isRemoteVideoOn: Swift.Bool {
    get
    set
  }
  public var isCurrentDevice: Swift.Bool {
    get
  }
  public var isOptimistic: Swift.Bool {
    get
  }
  public var peer: DialogProtocols.DialogPeer? {
    get
  }
}
extension CallDirection : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension CallDirection {
  public var toGrpcCallDirection: DialogCalls_GRPC.DialogCalls_CALL_DIRECTION {
    get
  }
}
extension DialogCalls_CALL_DIRECTION {
  public var toNormalizedCallDirection: DialogProtocols.CallDirection {
    get
  }
}
public enum CallDisposeReason : Swift.String, Swift.Codable {
  case internalError
  case callDoesNotExists
  case pickedUp
  case normal
  case calleeNotFound
  case noAnswer
  case busy
  case rejected
  case callerDisabled
  case calleeDisabled
  case transfer
  case merged
  case missed
  case noMicrophoneAccess
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
extension CallDisposeReason : Swift.CaseIterable {
  public static var allCases: [DialogCalls.CallDisposeReason] {
    get
  }
  public typealias AllCases = [DialogCalls.CallDisposeReason]
}
extension CallDisposeReason {
  public var toGrpcDisposeReason: DialogCalls_GRPC.DialogCalls_DISPOSE_REASON {
    get
  }
  public var toSipCode: Swift.Int {
    get
  }
}
extension DialogCalls_DISPOSE_REASON {
  public var toNormalizedDisposeReason: DialogCalls.CallDisposeReason {
    get
  }
}
public enum CallDtmf : Swift.Int {
  case d0
  case d1
  case d2
  case d3
  case d4
  case d5
  case d6
  case d7
  case d8
  case d9
  case dA
  case dB
  case dC
  case dD
  case dStar
  case dDies
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
extension CallDtmf {
  public var toString: Swift.String {
    get
  }
}
public enum CallHangupReason : Swift.Int {
  case error
  case normal
  case busy
  case reject
  case merged
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public enum CallEndedReason : Swift.Int {
  case failed
  case remoteEnded
  case unanswered
  case answeredElsewhere
  case declinedElsewhere
  public init(disposeReason: DialogCalls.CallDisposeReason, direction: DialogProtocols.CallDirection)
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
extension CallHangupReason {
  public var toGrpcHangupReason: DialogCalls_GRPC.DialogCalls_HANGUP_REASON {
    get
  }
}
extension DialogCalls_HANGUP_REASON {
  public var toNormalizedHangupReason: DialogCalls.CallHangupReason {
    get
  }
}
public struct DialogHistoryCallGetPageRequest {
  public let size: Swift.Int32
  public let seq: Swift.Int64
  public let date: Swift.Int64
  public init(size: Swift.Int32, seq: Swift.Int64, date: Swift.Int64)
}
public struct DialogHistoryCallGetDiffRequest {
  public let size: Swift.Int32
  public let seq: Swift.Int64
  public init(size: Swift.Int32, seq: Swift.Int64)
}
public struct DialogHistoryCallGetDiffResponse : Swift.Equatable {
  public let created: [DialogProtocols.DialogHistoryCall]
  public let deleted: [Swift.String]
  public static func == (a: DialogCalls.DialogHistoryCallGetDiffResponse, b: DialogCalls.DialogHistoryCallGetDiffResponse) -> Swift.Bool
}
public protocol CallKitAdapterProtocol : AnyObject {
  func assignCallsServiceDelegate(_ delegate: DialogCalls.CallsServiceProtocol?)
  func reportNewIncomingCallCame(uuid: Foundation.UUID, handleValue: Swift.String, displayName: Swift.String, hasVideo: Swift.Bool, voipCompletion: @escaping (Swift.Error?) -> Swift.Void)
  func startOutboundCall(uuid: Foundation.UUID, handleValue: Swift.String, displayName: Swift.String, hasVideo: Swift.Bool)
  func reportOutboundCallConnected(uuid: Foundation.UUID, atDate date: Foundation.Date?)
  func reportOutboundCallStartedConnecting(uuid: Foundation.UUID, atDate date: Foundation.Date?)
  func requestEndCall(uuid: Foundation.UUID, completion: ((Swift.Error?) -> Swift.Void)?)
  func reportCallEnded(uuid: Foundation.UUID, reason: DialogCalls.CallEndedReason)
  func requestMuted(uuid: Foundation.UUID, isMuted: Swift.Bool)
  func bakeHandleAndDisplayName(forUser user: DialogProtocols.DialogUser) -> (Swift.String, Swift.String)
  func bakeHandleAndDisplayName(forParameters params: DialogCalls.MappedCallParameters) -> (Swift.String, Swift.String)
}
extension RTCMediaConstraints {
  public static let `default`: WebRTC.RTCMediaConstraints
}
@objc @_hasMissingDesignatedInitializers final public class CallPeerConnection : ObjectiveC.NSObject, DialogCalls.CallPeerConnectionProtocol {
  final public let peerConnectionId: Swift.Int32
  final public var sdpId: Swift.Int32? {
    get
  }
  final public var signalingState: WebRTC.RTCSignalingState {
    get
  }
  final public var iceConnectionState: WebRTC.RTCIceConnectionState {
    get
  }
  final public var iceGatheringState: WebRTC.RTCIceGatheringState {
    get
  }
  final public let closeObservable: RxSwift.Observable<Foundation.Unit>
  final public let iceConnectionStateObservable: RxSwift.Observable<WebRTC.RTCIceConnectionState?>
  final public let iceGatheringStateObservable: RxSwift.Observable<WebRTC.RTCIceGatheringState?>
  final public let signalingStateObservable: RxSwift.Observable<WebRTC.RTCSignalingState?>
  final public let localIceCandidateObservable: RxSwift.Observable<WebRTC.RTCIceCandidate?>
  final public let remoteIceCandidateObservable: RxSwift.Observable<WebRTC.RTCIceCandidate?>
  final public let iceConnectionReceivingChangeObservable: RxSwift.Observable<Swift.Bool>
  final public let remoteAudioObservable: RxSwift.Observable<DialogCalls.AudioTrackAdapter?>
  final public let remoteVideoObservable: RxSwift.Observable<DialogCalls.VideoTrackAdapter?>
  @objc deinit
  @objc override dynamic public init()
}
extension CallPeerConnection {
  final public func getStats() -> RxSwift.Single<[DialogCalls.StatsReport]>
}
extension CallPeerConnection {
  final public func dtmf(_ dtmf: DialogCalls.CallDtmf)
}
extension CallPeerConnection {
  final public func setLocalDescription(_ sessionDescription: WebRTC.RTCSessionDescription, sdpId: Swift.Int32) -> RxSwift.Observable<Swift.Void>
  final public func setRemoteDescription(_ sessionDescription: WebRTC.RTCSessionDescription, sdpId: Swift.Int32) -> RxSwift.Observable<Swift.Void>
}
extension CallPeerConnection {
  final public func createOffer() -> RxSwift.Observable<WebRTC.RTCSessionDescription>
  final public func createAnswer() -> RxSwift.Observable<WebRTC.RTCSessionDescription>
}
extension CallPeerConnection : WebRTC.RTCPeerConnectionDelegate {
  @objc final public func peerConnection(_ peerConnection: WebRTC.RTCPeerConnection, didAdd stream: WebRTC.RTCMediaStream)
  @objc final public func peerConnection(_ peerConnection: WebRTC.RTCPeerConnection, didRemove stream: WebRTC.RTCMediaStream)
  @objc final public func peerConnection(_ peerConnection: WebRTC.RTCPeerConnection, didChange newState: WebRTC.RTCIceConnectionState)
  @objc final public func peerConnection(_ peerConnection: WebRTC.RTCPeerConnection, didChange newState: WebRTC.RTCIceGatheringState)
  @objc final public func peerConnection(_ peerConnection: WebRTC.RTCPeerConnection, didChange stateChanged: WebRTC.RTCSignalingState)
  @objc final public func peerConnection(_ peerConnection: WebRTC.RTCPeerConnection, didGenerate candidate: WebRTC.RTCIceCandidate)
  @objc final public func peerConnection(_ peerConnection: WebRTC.RTCPeerConnection, didRemove candidates: [WebRTC.RTCIceCandidate])
  @objc final public func peerConnection(_ peerConnection: WebRTC.RTCPeerConnection, didOpen dataChannel: WebRTC.RTCDataChannel)
  @objc final public func peerConnectionShouldNegotiate(_ peerConnection: WebRTC.RTCPeerConnection)
  @objc final public func peerConnection(_ peerConnection: WebRTC.RTCPeerConnection, didRemove rtpReceiver: WebRTC.RTCRtpReceiver)
  @objc final public func peerConnection(_ peerConnection: WebRTC.RTCPeerConnection, didAdd rtpReceiver: WebRTC.RTCRtpReceiver, streams mediaStreams: [WebRTC.RTCMediaStream])
  @objc final public func peerConnection(_ peerConnection: WebRTC.RTCPeerConnection, didStartReceivingOn transceiver: WebRTC.RTCRtpTransceiver)
}
public protocol CallPeerConnectionProtocol : AnyObject {
  var peerConnectionId: Swift.Int32 { get }
  var sdpId: Swift.Int32? { get }
  var iceConnectionStateObservable: RxSwift.Observable<WebRTC.RTCIceConnectionState?> { get }
  var iceGatheringStateObservable: RxSwift.Observable<WebRTC.RTCIceGatheringState?> { get }
  var signalingStateObservable: RxSwift.Observable<WebRTC.RTCSignalingState?> { get }
  var remoteAudioObservable: RxSwift.Observable<DialogCalls.AudioTrackAdapter?> { get }
  var remoteVideoObservable: RxSwift.Observable<DialogCalls.VideoTrackAdapter?> { get }
  var localIceCandidateObservable: RxSwift.Observable<WebRTC.RTCIceCandidate?> { get }
  var remoteIceCandidateObservable: RxSwift.Observable<WebRTC.RTCIceCandidate?> { get }
  var closeObservable: RxSwift.Observable<Foundation.Unit> { get }
  var iceConnectionReceivingChangeObservable: RxSwift.Observable<Swift.Bool> { get }
  var signalingState: WebRTC.RTCSignalingState { get }
  var iceConnectionState: WebRTC.RTCIceConnectionState { get }
  var iceGatheringState: WebRTC.RTCIceGatheringState { get }
  func getStats() -> RxSwift.Single<[DialogCalls.StatsReport]>
}
extension CallPeerConnectionProtocol {
  public func getStatsPeriodically(_ period: Dispatch.DispatchTimeInterval = .seconds(1), scheduler: RxSwift.SchedulerType = MainScheduler.asyncInstance) -> RxSwift.Observable<[DialogCalls.StatsReport]>
}
public typealias SdpId = Swift.Int32
public typealias InstanceId = Swift.Int32
public typealias PeerConnectionId = Swift.Int32
public enum RenegotiateEvent {
  case fromClient
  case fromServer(sdp: DialogCalls.SdpId?, instance: DialogCalls.InstanceId, peerConnection: DialogCalls.PeerConnectionId)
}
public struct AnswerEvent {
  public let isAudioEnabled: Swift.Bool
  public let isVideoEnabled: Swift.Bool
  public let setOnHold: Swift.Bool
  public init(isAudioEnabled: Swift.Bool, isVideoEnabled: Swift.Bool, setOnHold: Swift.Bool)
}
public struct CreateEvent {
  public init()
}
public typealias IcesEvent = DialogCalls_GRPC.DialogCalls_IceCallRequest
public typealias JoinEvent = DialogCalls_GRPC.DialogCalls_JoinCallRequest
public protocol CallSessionProtocol {
  var uuid: Foundation.UUID { get }
  var id: DialogCalls.CallID { get }
  var callDataModel: DialogCalls.CallDataModel { get }
  var isOngoing: Swift.Bool { get set }
  var isOnHold: Swift.Bool { get set }
  var isOngoingObservable: RxSwift.Observable<Swift.Bool> { get }
  var startAudioDateObservable: RxSwift.Observable<Foundation.Date?> { get }
  var peerConnectionObserver: DialogCalls.CallPeerConnectionObserving { get }
  func setMuted(_ value: Swift.Bool)
  func toggleVideo(_ value: Swift.Bool)
  func ringing() -> RxSwift.Observable<Swift.Void>
  func create(_ event: DialogCalls.CreateEvent)
  func renegotiate(_ event: DialogCalls.RenegotiateEvent)
  func answer(_ event: DialogCalls.AnswerEvent)
  func join(_ event: DialogCalls.JoinEvent)
  func ices(_ event: DialogCalls.IcesEvent)
  func dispose()
  func merged(newCallModel: DialogCalls.CallDataModel) -> (DialogCalls.CallSessionProtocol, DialogCalls.AnswerEvent)
  func normalHangup() -> RxSwift.Observable<Swift.Void>
  func hangup(withReason reason: DialogCalls.CallHangupReason) -> RxSwift.Observable<Swift.Void>
  func hangup(hangupReason: DialogCalls.CallHangupReason, disposeReason: DialogCalls.CallDisposeReason) -> RxSwift.Observable<Swift.Void>
  var isLocalAudioEnabled: Swift.Bool { get }
  var localAudio: WebRTC.RTCAudioTrack? { get }
  var localAudioObservable: RxSwift.Observable<WebRTC.RTCAudioTrack?> { get }
  var isLocalAudioEnabledObservable: RxSwift.Observable<Swift.Bool> { get }
  var localVideo: DialogCalls.LocalVideo? { get }
  var localVideoObservable: RxSwift.Observable<DialogCalls.LocalVideo?> { get }
  var isLocalVideoEnabledObservable: RxSwift.Observable<Swift.Bool> { get }
  var isLocalVideoEnabled: Swift.Bool { get }
  var remoteAudioAdapterObservable: RxSwift.Observable<DialogCalls.AudioTrackAdapter?> { get }
  var remoteVideoAdapterObservable: RxSwift.Observable<DialogCalls.VideoTrackAdapter?> { get }
  var audioTrackAudioMediaReports: RxSwift.Observable<[DialogCalls.StatsReport]> { get }
  var videoTrackVideoMediaReports: RxSwift.Observable<[DialogCalls.StatsReport]> { get }
  var isVideoPacketsReceiving: RxSwift.Observable<DialogCalls.MediaPacketsReceivingState> { get }
  var isAudioPacketsReceiving: RxSwift.Observable<DialogCalls.MediaPacketsReceivingState> { get }
}
public protocol CallPeerConnectionObserving {
  var peerConnectionObservable: RxSwift.Observable<DialogCalls.CallPeerConnection?> { get }
  var mediaConnectionStateObservable: RxSwift.Observable<Swift.Bool> { get }
  var signalingStateObservable: RxSwift.Observable<Swift.Bool> { get }
  var audioTrackStats: RxSwift.Observable<[DialogCalls.StatsReport]> { get }
  var videoTrackStats: RxSwift.Observable<[DialogCalls.StatsReport]> { get }
}
extension CallSessionProtocol {
  public func normalHangup() -> RxSwift.Observable<Swift.Void>
}
public enum MediaPacketsReceivingState {
  case notStarted
  case reseted
  case started(isReceiving: Swift.Bool)
}
extension MediaPacketsReceivingState : Swift.Equatable {
  public static func == (lhs: DialogCalls.MediaPacketsReceivingState, rhs: DialogCalls.MediaPacketsReceivingState) -> Swift.Bool
}
extension CallSession {
  final public var audioTrackAudioMediaReports: RxSwift.Observable<[DialogCalls.StatsReport]> {
    get
  }
  final public var videoTrackVideoMediaReports: RxSwift.Observable<[DialogCalls.StatsReport]> {
    get
  }
  final public var isVideoPacketsReceiving: RxSwift.Observable<DialogCalls.MediaPacketsReceivingState> {
    get
  }
  final public var isAudioPacketsReceiving: RxSwift.Observable<DialogCalls.MediaPacketsReceivingState> {
    get
  }
}
extension CallSession {
  final public func hangup(hangupReason: DialogCalls.CallHangupReason, disposeReason: DialogCalls.CallDisposeReason) -> RxSwift.Observable<Swift.Void>
  final public func hangup(withReason reason: DialogCalls.CallHangupReason) -> RxSwift.Observable<Swift.Void>
  final public func normalHangup() -> RxSwift.Observable<Swift.Void>
}
@_hasMissingDesignatedInitializers final public class CallSession : DialogCalls.CallSessionProtocol {
  final public let callDataModel: DialogCalls.CallDataModel
  final public let isOngoingObservable: RxSwift.Observable<Swift.Bool>
  final public let localAudioObservable: RxSwift.Observable<WebRTC.RTCAudioTrack?>
  final public var isLocalAudioEnabledObservable: RxSwift.Observable<Swift.Bool> {
    get
    set
  }
  final public let isLocalVideoEnabledObservable: RxSwift.Observable<Swift.Bool>
  final public let localVideoObservable: RxSwift.Observable<DialogCalls.LocalVideo?>
  final public let remoteAudioAdapterObservable: RxSwift.Observable<DialogCalls.AudioTrackAdapter?>
  final public let remoteVideoAdapterObservable: RxSwift.Observable<DialogCalls.VideoTrackAdapter?>
  final public let startAudioDateObservable: RxSwift.Observable<Foundation.Date?>
  final public var peerConnectionObserver: DialogCalls.CallPeerConnectionObserving {
    get
  }
  final public func dispose()
  final public func setMuted(_ value: Swift.Bool)
  final public func toggleVideo(_ value: Swift.Bool)
  final public func merged(newCallModel: DialogCalls.CallDataModel) -> (DialogCalls.CallSessionProtocol, DialogCalls.AnswerEvent)
  @objc deinit
}
extension CallSession {
  final public func ringing() -> RxSwift.Observable<Swift.Void>
}
extension CallSession {
  final public func create(_ event: DialogCalls.CreateEvent)
  final public func answer(_ event: DialogCalls.AnswerEvent)
  final public func renegotiate(_ event: DialogCalls.RenegotiateEvent)
  final public func join(_ event: DialogCalls.JoinEvent)
  final public func ices(_ event: DialogCalls.IcesEvent)
}
extension CallSession : DialogMetrics.DialogEventsConvertible {
  final public func convert() -> [DialogMetrics.DialogMetricStoragableEvent]
}
extension CallSession {
  final public var isOngoing: Swift.Bool {
    get
    set
  }
  final public var isOnHold: Swift.Bool {
    get
    set
  }
  final public var localAudio: WebRTC.RTCAudioTrack? {
    get
  }
  final public var localVideo: DialogCalls.LocalVideo? {
    get
  }
  final public var isLocalVideoEnabled: Swift.Bool {
    get
  }
  final public var isLocalAudioEnabled: Swift.Bool {
    get
  }
  final public var uuid: Foundation.UUID {
    get
  }
  final public var id: DialogCalls.CallID {
    get
  }
}
extension CallSession : Swift.Equatable {
  public static func == (lhs: DialogCalls.CallSession, rhs: DialogCalls.CallSession) -> Swift.Bool
}
extension Dialog_CALL_DIRECTION : DialogSwiftGRPCExtra.GoogleProtobufValueInitable {
  public typealias SwiftType = DialogProtocols.CallDirection
  public init(_ value: DialogCalls_GRPC.Dialog_CALL_DIRECTION.SwiftType)
  public var nativeValue: DialogCalls_GRPC.Dialog_CALL_DIRECTION.SwiftType {
    get
  }
}
extension CallDirection : DialogSwiftGRPCExtra.GoogleProtobufRepresentable {
  public typealias GoogleProtobufValueType = DialogCalls_GRPC.Dialog_CALL_DIRECTION
  public init(_ value: DialogCalls_GRPC.Dialog_CALL_DIRECTION)
}
extension CallType {
  public init(_ value: Swift.Bool)
  public var boolValue: Swift.Bool {
    get
  }
}
extension Dialog_CreatedCallModel.CallResultModel.CallResultOneOf.OneOf_Result : DialogSwiftGRPCExtra.GoogleProtobufValueInitable {
  public typealias SwiftType = DialogProtocols.DialogHistoryCall.DisposeReason
  public init(_ value: DialogCalls_GRPC.Dialog_CreatedCallModel.CallResultModel.CallResultOneOf.OneOf_Result.SwiftType)
  public var nativeValue: DialogCalls_GRPC.Dialog_CreatedCallModel.CallResultModel.CallResultOneOf.OneOf_Result.SwiftType {
    get
  }
}
extension Dialog_DeletedCallModel : DialogSwiftGRPCExtra.GoogleProtobufValueInitable {
  public typealias SwiftType = DialogProtocols.DialogDeletedHistoryCall
  public init(_ value: DialogProtocols.DialogDeletedHistoryCall)
  public var nativeValue: DialogCalls_GRPC.Dialog_DeletedCallModel.SwiftType {
    get
  }
}
extension DialogDeletedHistoryCall : DialogSwiftGRPCExtra.GoogleProtobufRepresentable {
  public typealias GoogleProtobufValueType = DialogCalls_GRPC.Dialog_DeletedCallModel
  public init(_ value: DialogCalls_GRPC.Dialog_DeletedCallModel)
}
public class CallsLogger {
  final public let log: os.OSLog
  public init(tag: Swift.String)
  public func error(_ message: Swift.StaticString, _ error: Swift.Error? = nil)
  @objc deinit
}
public typealias CallID = Swift.String
public struct IceCandidateInfo : Swift.Equatable {
  public let sdpType: WebRTC.RTCSdpType
  public let sdpId: Swift.Int32
  public let iceCandidate: WebRTC.RTCIceCandidate
  public let iceId: Swift.Int32
  public init(tuple: (sdpType: WebRTC.RTCSdpType, sdpId: Swift.Int32, iceCandidate: WebRTC.RTCIceCandidate, iceId: Swift.Int32))
  public init(sdpType: WebRTC.RTCSdpType, sdpId: Swift.Int32, iceCandidate: WebRTC.RTCIceCandidate, iceId: Swift.Int32)
  public static func == (a: DialogCalls.IceCandidateInfo, b: DialogCalls.IceCandidateInfo) -> Swift.Bool
}
public enum CallsNetworkingServiceError : Swift.Error {
  case serviceAlreadyConnected
  case serviceAlreadyDisconnected
  case multipleClientCallsAreDisallowed
  case multipleServerCallsAreDisallowed
  case inboundServerCallsAreDisallowedWhileHavingClientCall
  case outboundServerCallsAreDisallowedWhileHavingClientCall
  public static func == (a: DialogCalls.CallsNetworkingServiceError, b: DialogCalls.CallsNetworkingServiceError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
final public class CallsNetworkingService : DialogCalls.CallsNetworkingServiceProtocol {
  final public func assignNetworkingEventsProcessingDelegate(_ delegate: DialogCalls.CallsNetworkingEventsProcessingDelegate?)
  final public var isConnected: Swift.Bool {
    get
  }
  final public var connectionStateObservable: RxSwift.Observable<SwiftGRPC.Channel.ConnectivityState> {
    get
    set
  }
  public static let updatesStreamRestoreInterval: Swift.Double
  public init()
  @objc deinit
}
extension CallsNetworkingService {
  final public func disconnect(completion: @escaping () -> Swift.Void = {}) throws
  final public func verifyConnection()
  final public func connect(withInfo info: DialogProtocols.ChannelBasedServiceRestorableInfo) throws
}
extension CallsNetworkingService {
  final public func generateId(id: DialogCalls.CallID) -> RxSwift.Observable<DialogCalls_GRPC.DialogCalls_GenerateIdResponse>
  final public func lockCall(id: DialogCalls.CallID, instanceId: Swift.Int32?, sdpId: Swift.Int32) -> RxSwift.Observable<DialogCalls_GRPC.DialogCalls_LockCallResponse>
  final public func answerCall(id: DialogCalls.CallID, instanceId: Swift.Int32) -> RxSwift.Observable<DialogCalls_GRPC.DialogCalls_AnswerCallResponse>
  final public func createCall(id: DialogCalls.CallID, params: [Swift.String : Swift.String]) -> RxSwift.Observable<DialogCalls_GRPC.DialogCalls_CreateCallResponse>
  final public func ringing(id: DialogCalls.CallID) -> RxSwift.Observable<DialogCalls_GRPC.DialogCalls_RingingCallResponse>
  final public func disposeCall(id: DialogCalls.CallID, instanceId: Swift.Int32?, hangupReason reason: DialogCalls.CallHangupReason) -> RxSwift.Observable<DialogCalls_GRPC.DialogCalls_DisposeCallResponse>
  final public func ice(id: DialogCalls.CallID, instanceId: Swift.Int32?, peerConnectionId: Swift.Int32, iceCandidatesInfos: [DialogCalls.IceCandidateInfo]) -> RxSwift.Observable<DialogCalls_GRPC.DialogCalls_IceCallResponse>
  final public func joinCall(id: DialogCalls.CallID, instanceId: Swift.Int32?, peerConnectionId: Swift.Int32, sdpId: Swift.Int32, sdp: Swift.String, sdpType: Swift.String) -> RxSwift.Observable<DialogCalls_GRPC.DialogCalls_JoinCallResponse>
}
public protocol CallsNetworkingServiceProtocol : AnyObject {
  var isConnected: Swift.Bool { get }
  var connectionStateObservable: RxSwift.Observable<SwiftGRPC.Channel.ConnectivityState> { get }
  func assignNetworkingEventsProcessingDelegate(_ delegate: DialogCalls.CallsNetworkingEventsProcessingDelegate?)
  func connect(withInfo info: DialogProtocols.ChannelBasedServiceRestorableInfo) throws
  func disconnect(completion: @escaping () -> Swift.Void) throws
  func verifyConnection()
  func generateId(id: DialogCalls.CallID) -> RxSwift.Observable<DialogCalls_GRPC.DialogCalls_GenerateIdResponse>
  func lockCall(id: DialogCalls.CallID, instanceId: Swift.Int32?, sdpId: Swift.Int32) -> RxSwift.Observable<DialogCalls_GRPC.DialogCalls_LockCallResponse>
  func answerCall(id: DialogCalls.CallID, instanceId: Swift.Int32) -> RxSwift.Observable<DialogCalls_GRPC.DialogCalls_AnswerCallResponse>
  func createCall(id: DialogCalls.CallID, params: [Swift.String : Swift.String]) -> RxSwift.Observable<DialogCalls_GRPC.DialogCalls_CreateCallResponse>
  func ringing(id: DialogCalls.CallID) -> RxSwift.Observable<DialogCalls_GRPC.DialogCalls_RingingCallResponse>
  func disposeCall(id: DialogCalls.CallID, instanceId: Swift.Int32?, hangupReason: DialogCalls.CallHangupReason) -> RxSwift.Observable<DialogCalls_GRPC.DialogCalls_DisposeCallResponse>
  func ice(id: DialogCalls.CallID, instanceId: Swift.Int32?, peerConnectionId: Swift.Int32, iceCandidatesInfos: [DialogCalls.IceCandidateInfo]) -> RxSwift.Observable<DialogCalls_GRPC.DialogCalls_IceCallResponse>
  func joinCall(id: DialogCalls.CallID, instanceId: Swift.Int32?, peerConnectionId: Swift.Int32, sdpId: Swift.Int32, sdp: Swift.String, sdpType: Swift.String) -> RxSwift.Observable<DialogCalls_GRPC.DialogCalls_JoinCallResponse>
}
@_hasMissingDesignatedInitializers final public class CallsReachability {
  public static let shared: DialogCalls.CallsReachability
  final public var connectionObservable: RxSwift.Observable<Reachability.Reachability.Connection> {
    get
  }
  @objc deinit
}
public protocol CallAudioRouterProtocol {
  func updateState(_ state: DialogCalls.CallState)
  func stop()
}
public class CallsService : DialogCalls.CallsServiceProtocol {
  final public let callsStateService: DialogCalls.CallsStateServiceProtocol
  final public let activeCallObservable: RxSwift.Observable<DialogCalls.AnyCallSession?>
  public var activeCall: DialogCalls.AnyCallSession? {
    get
  }
  final public let hasActiveCall: RxSwift.Observable<Swift.Bool>
  final public let lastActiveCallDisposeReason: RxSwift.Observable<DialogCalls.DisposedCallInfoModel?>
  final public let callsNetworkingStateObservable: RxSwift.Observable<SwiftGRPC.Channel.ConnectivityState>
  final public let isServiceConnected: RxSwift.Observable<Swift.Bool>
  final public let callsAvailabilityObservable: RxSwift.Observable<Swift.Bool>
  public init(callsStateService: DialogCalls.CallsStateServiceProtocol, callsNetworkingService: DialogCalls.CallsNetworkingServiceProtocol, callKitAdapter: DialogCalls.CallKitAdapterProtocol, mediaPermissionsService: DialogProtocols.MediaDevicePermissionsServiceProtocol, mediaConfigService: DialogProtocols.MediaConfigServiceProtocol, featureFlagsService: DialogProtocols.DialogFeatureFlagsServiceProtocol, eventBus: DialogProtocols.EventBusServiceProtocol, userEventBus: DialogProtocols.UserEventBusServiceProtocol, callAudioRouter: DialogCalls.CallAudioRouterProtocol, callsEventListener: DialogCalls.CallsEventListener)
  @objc deinit
}
extension CallsService {
  public func connect(info: DialogProtocols.ChannelBasedServiceRestorableInfo) throws
  public func disconnect(_ completion: @escaping () -> Swift.Void) throws
  public func disconnect() throws
}
extension CallsService {
  public func removeCall(uuid: Foundation.UUID)
}
extension AnyCallSession {
  public var recipientId: DialogProtocols.DialogUserId? {
    get
  }
}
extension CallsService {
  public func createOutboundCall(_ arg: DialogCalls.CallOutboundArgument)
}
extension CallsService {
  public func answerCall(uuid: Foundation.UUID, action: DialogCalls.CallAction)
  public func hangup(uuid: Foundation.UUID, action: DialogCalls.CallAction?, reason: DialogCalls.HangupCallReason)
  public func holdCall(uuid: Foundation.UUID, action: DialogCalls.CallAction)
  public func hangupCurrentActiveCall(reason: DialogCalls.HangupCallReason, action: DialogCalls.CallAction?)
  public func setMuted(_ isMuted: Swift.Bool)
}
extension AnyObserver {
  public static func create(elementOnlyHandler: @escaping (Element) -> Swift.Void) -> RxSwift.AnyObserver<Element>
}
public enum HangupCallReason {
  case undefined
  case noMicAccess
  public static func == (a: DialogCalls.HangupCallReason, b: DialogCalls.HangupCallReason) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol CallAction {
  func fulfill()
  func fail()
}
public struct CallOutboundArgument {
  public let pureParams: [Swift.String : Swift.String]
  public let handleValue: Swift.String
  public let displayName: Swift.String
  public let enableVideo: Swift.Bool
  public init(pureParams: [Swift.String : Swift.String], handleValue: Swift.String, displayName: Swift.String, enableVideo: Swift.Bool)
}
public enum CallsServiceIntent : Swift.Equatable {
  case setActiveCallVideo(isOn: Swift.Bool)
  public static func == (a: DialogCalls.CallsServiceIntent, b: DialogCalls.CallsServiceIntent) -> Swift.Bool
}
public protocol CallsServiceProtocol : AnyObject {
  var callsStateService: DialogCalls.CallsStateServiceProtocol { get }
  var activeCall: DialogCalls.AnyCallSession? { get }
  var activeCallObservable: RxSwift.Observable<DialogCalls.AnyCallSession?> { get }
  var hasActiveCall: RxSwift.Observable<Swift.Bool> { get }
  var lastActiveCallDisposeReason: RxSwift.Observable<DialogCalls.DisposedCallInfoModel?> { get }
  var isServiceConnected: RxSwift.Observable<Swift.Bool> { get }
  func connect(info: DialogProtocols.ChannelBasedServiceRestorableInfo) throws
  func disconnect(_ completion: @escaping (() -> Swift.Void)) throws
  func disconnect() throws
  func removeCall(uuid: Foundation.UUID)
  func createOutboundCall(_ arg: DialogCalls.CallOutboundArgument)
  func answerCall(uuid: Foundation.UUID, action: DialogCalls.CallAction)
  func holdCall(uuid: Foundation.UUID, action: DialogCalls.CallAction)
  func hangup(uuid: Foundation.UUID, action: DialogCalls.CallAction?, reason: DialogCalls.HangupCallReason)
  func hangupCurrentActiveCall(reason: DialogCalls.HangupCallReason, action: DialogCalls.CallAction?)
  func setMuted(_ isMuted: Swift.Bool)
}
extension CallsServiceProtocol {
  public func hangupCurrentActiveCall(reason: DialogCalls.HangupCallReason = .undefined)
  public func hangup(uuid: Foundation.UUID, action: DialogCalls.CallAction?)
}
public struct CallsEvent : Swift.Equatable, Swift.RawRepresentable {
  public var rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let requestCamera: DialogCalls.CallsEvent
  public static let requestMic: DialogCalls.CallsEvent
  public static let noCameraAccess: DialogCalls.CallsEvent
  public static let noMicAccess: DialogCalls.CallsEvent
  public static let noMicAndCameraAccess: DialogCalls.CallsEvent
  public static let missedCall: DialogCalls.CallsEvent
  public typealias RawValue = Swift.String
}
public protocol CallsEventListener {
  func perform(event: DialogCalls.CallsEvent, object: Any?)
}
extension CallsStateService {
  final public func getCall(uuid: Foundation.UUID) -> DialogCalls.AnyCallSession?
  final public func getCall(id: DialogCalls.CallID) -> DialogCalls.AnyCallSession?
  final public func getActiveCall() -> DialogCalls.AnyCallSession?
  final public func getCallDisposeInfo(uuid: Foundation.UUID) -> DialogCalls.DisposedCallInfoModel?
  final public func getCallDisposeInfo(id: DialogCalls.CallID) -> DialogCalls.DisposedCallInfoModel?
  final public func hasOneOrMoreNonOngoingCalls() -> Swift.Bool
  final public func hasOneOrMoreOngoingCalls() -> Swift.Bool
}
extension CallsStateService {
  final public func handleIceResponse(_ response: DialogCalls_GRPC.DialogCalls_IceCallRequest)
  final public func handleJoinResponse(_ response: DialogCalls_GRPC.DialogCalls_JoinCallRequest)
  final public func handleRenegotiateResponse(_ response: DialogCalls.RenegotiateModel)
  final public func handleDisposeResponse(_ response: DialogCalls.DisposeCallModel)
  final public func handleDisposeResponses(_ responses: [DialogCalls.DisposeCallModel])
  final public func handleCallsListResponse(_ response: DialogCalls.ServerCallListModel, networkingService: DialogCalls.CallsNetworkingServiceProtocol)
}
extension CallsStateService {
  final public func removeCall(uuid: Foundation.UUID)
  final public func removeCall(id: DialogCalls.CallID)
  @discardableResult
  final public func addDisposeCallInfosAndRemoveCalls(_ infos: [DialogCalls.DisposedCallInfoModel], updateState: Swift.Bool) -> DialogCalls.CallsStateModel
  final public func addCallsIdentifiersModelIfNeeded(_ model: DialogCalls.CallIdentifiersModel)
  final public func bakeCallIdentifiersAndSaveBindingIfNeeded(forCallId callId: DialogCalls.CallID) -> DialogCalls.CallIdentifiersModel
  final public func bakeCallIdentifiersAndSaveBindingIfNeeded(forCallId callId: DialogCalls.CallID, modifyingState state: inout DialogCalls.CallsStateModel) -> (DialogCalls.CallIdentifiersModel, Swift.Bool)
  final public func addNewCall(_ callDataModel: DialogCalls.CallDataModel, localAudioEnabled: Swift.Bool, localVideoEnabled: Swift.Bool)
  final public func setCallOnHold(uuid callUUID: Foundation.UUID, isOnHold: Swift.Bool)
  final public func setCallActive(uuid: Foundation.UUID)
  final public func flush()
}
public struct CallIdentifiersModel : Swift.Equatable, Swift.Hashable {
  public let uuid: Foundation.UUID
  public let id: DialogCalls.CallID
  public init(uuid: Foundation.UUID, id: DialogCalls.CallID)
  public static func == (lhs: DialogCalls.CallIdentifiersModel, rhs: DialogCalls.CallIdentifiersModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public struct DisposedCallInfoModel : DialogProtocols.BaseStruct, Swift.Equatable {
  public let callIdentifiers: DialogCalls.CallIdentifiersModel
  public let direction: DialogProtocols.CallDirection
  public let disposeReason: DialogCalls.CallDisposeReason
  public let wasOngoing: Swift.Bool
  public let wasOnHold: Swift.Bool
  public let params: DialogCalls.MappedCallParameters
  public let peer: DialogProtocols.DialogPeer?
  public init(callIdentifiers: DialogCalls.CallIdentifiersModel, direction: DialogProtocols.CallDirection, disposeReason: DialogCalls.CallDisposeReason, wasOngoing: Swift.Bool, wasOnHold: Swift.Bool, mappedParams: DialogCalls.MappedCallParameters, peer: DialogProtocols.DialogPeer? = nil)
  public init(data model: DialogCalls.CallDataModel, reason: DialogCalls.CallDisposeReason, wasOngoing: Swift.Bool, wasOnHold: Swift.Bool)
  public static func == (a: DialogCalls.DisposedCallInfoModel, b: DialogCalls.DisposedCallInfoModel) -> Swift.Bool
}
public struct CallsStateModel : DialogProtocols.BaseStruct, Swift.Equatable {
  public var callsDictionary: Swift.Dictionary<Foundation.UUID, DialogCalls.AnyCallSession>
  public var mergedCalls: Swift.Dictionary<DialogCalls.CallID, DialogCalls.CallID>
  public var disposedCallsInfo: Swift.Dictionary<Foundation.UUID, DialogCalls.DisposedCallInfoModel>
  public var activeCallIds: DialogCalls.CallIdentifiersModel?
  public var onHoldCallsStack: [DialogCalls.CallIdentifiersModel]
  public var everExistedCallsIdentifiersSet: Swift.Set<DialogCalls.CallIdentifiersModel>
  public static var zero: DialogCalls.CallsStateModel {
    get
  }
  public static func == (a: DialogCalls.CallsStateModel, b: DialogCalls.CallsStateModel) -> Swift.Bool
}
extension CallsStateModel {
  public func getCall(id: DialogCalls.CallID) -> DialogCalls.AnyCallSession?
  public func getCall(uuid: Foundation.UUID) -> DialogCalls.AnyCallSession?
  public func getActiveCall() -> DialogCalls.AnyCallSession?
  public func getCallDisposeInfo(id: DialogCalls.CallID) -> DialogCalls.DisposedCallInfoModel?
  public func getCallDisposeInfo(uuid: Foundation.UUID) -> DialogCalls.DisposedCallInfoModel?
  public func getCallIdentifiers(id: DialogCalls.CallID) -> DialogCalls.CallIdentifiersModel?
}
public protocol CallsStateServiceProtocol : AnyObject {
  var stateObservable: RxSwift.Observable<DialogCalls.CallsStateModel> { get }
  var state: DialogCalls.CallsStateModel { get }
  var activeCallObservable: RxSwift.Observable<DialogCalls.AnyCallSession?> { get }
  var onHoldCallsStackObservable: RxSwift.Observable<[DialogCalls.CallIdentifiersModel]> { get }
  func getCall(id: DialogCalls.CallID) -> DialogCalls.AnyCallSession?
  func getCall(uuid: Foundation.UUID) -> DialogCalls.AnyCallSession?
  func getActiveCall() -> DialogCalls.AnyCallSession?
  func getCallDisposeInfo(id: DialogCalls.CallID) -> DialogCalls.DisposedCallInfoModel?
  func getCallDisposeInfo(uuid: Foundation.UUID) -> DialogCalls.DisposedCallInfoModel?
  func removeCall(id: DialogCalls.CallID)
  func removeCall(uuid: Foundation.UUID)
  func addNewCall(_ callDataModel: DialogCalls.CallDataModel, localAudioEnabled: Swift.Bool, localVideoEnabled: Swift.Bool)
  func setCallActive(uuid: Foundation.UUID)
  func setCallOnHold(uuid: Foundation.UUID, isOnHold: Swift.Bool)
  @discardableResult
  func addDisposeCallInfosAndRemoveCalls(_ infos: [DialogCalls.DisposedCallInfoModel], updateState: Swift.Bool) -> DialogCalls.CallsStateModel
  func addCallsIdentifiersModelIfNeeded(_ model: DialogCalls.CallIdentifiersModel)
  func bakeCallIdentifiersAndSaveBindingIfNeeded(forCallId callId: DialogCalls.CallID) -> DialogCalls.CallIdentifiersModel
  func bakeCallIdentifiersAndSaveBindingIfNeeded(forCallId callId: DialogCalls.CallID, modifyingState state: inout DialogCalls.CallsStateModel) -> (DialogCalls.CallIdentifiersModel, Swift.Bool)
  func flush()
}
public protocol CallsNetworkingEventsProcessingDelegate : AnyObject {
  func handleDisposeResponse(_ response: DialogCalls.DisposeCallModel)
  func handleDisposeResponses(_ responses: [DialogCalls.DisposeCallModel])
  func handleIceResponse(_ response: DialogCalls_GRPC.DialogCalls_IceCallRequest)
  func handleJoinResponse(_ response: DialogCalls_GRPC.DialogCalls_JoinCallRequest)
  func handleRenegotiateResponse(_ response: DialogCalls.RenegotiateModel)
  func handleCallsListResponse(_ response: DialogCalls.ServerCallListModel, networkingService: DialogCalls.CallsNetworkingServiceProtocol)
}
final public class CallsStateService : DialogCalls.CallsStateServiceProtocol, DialogCalls.CallsNetworkingEventsProcessingDelegate {
  final public var stateObservable: RxSwift.Observable<DialogCalls.CallsStateModel> {
    get
    set
  }
  final public var state: DialogCalls.CallsStateModel {
    get
  }
  final public var activeCallObservable: RxSwift.Observable<DialogCalls.AnyCallSession?> {
    get
    set
  }
  final public var onHoldCallsStackObservable: RxSwift.Observable<[DialogCalls.CallIdentifiersModel]> {
    get
    set
  }
  public init(networkingService: DialogCalls.CallsNetworkingServiceProtocol, metricsService: DialogMetrics.DialogMetricsServiceProtocol?)
  @objc deinit
}
extension CallState : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public enum CallState : Swift.Int {
  case trying
  case ringing
  case progress
  case talking
  case finished
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
extension CallState {
  public var isFinished: Swift.Bool {
    get
  }
  public var isConnecting: Swift.Bool {
    get
  }
  public var toGrpcCallState: DialogCalls_GRPC.DialogCalls_CALL_STATE {
    get
  }
}
extension DialogCalls_CALL_STATE {
  public var toNormalizedCallState: DialogCalls.CallState {
    get
  }
}
public enum CreateConferenceRequest {
  public struct ConferenceParams {
    public let title: Swift.String
    public let startsIn: Swift.Int64
    public let duration: Swift.Int64
    public let type: DialogCalls.ConferenceType
    public init(title: Swift.String, startsIn: Swift.Int64 = ConferenceParams.defaultStartsIn, duration: Swift.Int64 = ConferenceParams.defaultDuration, type: DialogCalls.ConferenceType = .vcs)
    public static let defaultStartsIn: Swift.Int64
    public static let defaultDuration: Swift.Int64
  }
  case createGroupFirst(DialogCalls.CreateConferenceRequest.ConferenceParams)
  case inCreatedGroup(DialogCalls.CreateConferenceRequest.ConferenceParams, DialogProtocols.DialogGroupId)
}
public struct DeleteConferenceRequest {
  public init(groupId: Swift.Int32)
}
public protocol DialogCallHistorySearchServiceProtocol {
  var search: RxSwift.AnyObserver<DialogCalls.DialogCallHistorySearchServiceRequest> { get }
  var state: RxSwift.Observable<DialogCalls.DialogCallHistorySearchCompositeState> { get }
}
final public class DialogCallHistorySearchService : DialogCalls.DialogCallHistorySearchServiceProtocol {
  public struct Config : Swift.Equatable, DialogProtocols.BaseStruct {
    public var queryMinLength: Swift.Int
    public var debounce: Dispatch.DispatchTimeInterval
    public static let `default`: DialogCalls.DialogCallHistorySearchService.Config
    public static func == (a: DialogCalls.DialogCallHistorySearchService.Config, b: DialogCalls.DialogCallHistorySearchService.Config) -> Swift.Bool
  }
  final public let search: RxSwift.AnyObserver<DialogCalls.DialogCallHistorySearchServiceRequest>
  final public let state: RxSwift.Observable<DialogCalls.DialogCallHistorySearchCompositeState>
  public static let defaultDebouncsScheduler: RxSwift.SerialDispatchQueueScheduler
  public init(performer: DialogCalls.DialogCallHistorySearchPerformerProtocol, debounceScheduler: RxSwift.SchedulerType = defaultDebouncsScheduler, config: DialogCalls.DialogCallHistorySearchService.Config = .default)
  @objc deinit
}
public struct DialogCallHistorySearchPage : DialogProtocols.BaseStruct, Swift.Equatable {
  public var results: [DialogProtocols.DialogHistoryCall]
  public static func == (lhs: DialogCalls.DialogCallHistorySearchPage, rhs: DialogCalls.DialogCallHistorySearchPage) -> Swift.Bool
}
public struct DialogCallHistorySearchResults : DialogProtocols.BaseStruct, Swift.Equatable {
  public var pages: [DialogCalls.DialogCallHistorySearchPage]
  public var hasMore: Swift.Bool
  public let initialRequest: DialogCalls.DialogCallHistorySearchRequest
  public init(initialRequest: DialogCalls.DialogCallHistorySearchRequest)
  public static func == (a: DialogCalls.DialogCallHistorySearchResults, b: DialogCalls.DialogCallHistorySearchResults) -> Swift.Bool
}
public struct DialogCallHistorySearchCompositeState : DialogProtocols.BaseStruct, Swift.Equatable {
  public var task: DialogCalls.DialogCallHistorySearchServiceTask
  public var results: DialogCalls.DialogCallHistorySearchResults?
  public static let idleWithoutResults: DialogCalls.DialogCallHistorySearchCompositeState
  public var hasResults: Swift.Bool {
    get
  }
  public var isEmpty: Swift.Bool {
    get
  }
  public static func == (a: DialogCalls.DialogCallHistorySearchCompositeState, b: DialogCalls.DialogCallHistorySearchCompositeState) -> Swift.Bool
}
public enum DialogCallHistorySearchServiceRequest : Swift.Equatable {
  case clear
  case search(DialogCalls.DialogCallHistorySearchRequest)
  case loadMore
  public var isNew: Swift.Bool {
    get
  }
  public var isClear: Swift.Bool {
    get
  }
  public var isLoadMore: Swift.Bool {
    get
  }
  public static func == (a: DialogCalls.DialogCallHistorySearchServiceRequest, b: DialogCalls.DialogCallHistorySearchServiceRequest) -> Swift.Bool
}
public enum DialogCallHistorySearchServiceTask : Swift.Equatable, Swift.CustomDebugStringConvertible {
  case idle
  case searching(request: DialogCalls.DialogCallHistorySearchRequest, pageIdx: Swift.Int)
  public static func initial(request: DialogCalls.DialogCallHistorySearchRequest) -> DialogCalls.DialogCallHistorySearchServiceTask
  public var isLoadingMore: Swift.Bool {
    get
  }
  public var isInitialLoading: Swift.Bool {
    get
  }
  public var request: DialogCalls.DialogCallHistorySearchRequest? {
    get
  }
  public var isIdle: Swift.Bool {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public static func == (a: DialogCalls.DialogCallHistorySearchServiceTask, b: DialogCalls.DialogCallHistorySearchServiceTask) -> Swift.Bool
}
public struct DialogCallsFinishedCallMetric : Swift.Codable {
  public let callEndReason: DialogCalls.CallDisposeReason
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct DialogCallHistorySearchRequest : DialogProtocols.BaseStruct, Swift.Equatable {
  public let string: Swift.String
  public var limit: Swift.Int
  public var offset: Swift.Int
  public init(string: Swift.String)
  public static func == (a: DialogCalls.DialogCallHistorySearchRequest, b: DialogCalls.DialogCallHistorySearchRequest) -> Swift.Bool
}
public protocol DialogCallHistorySearchPerformerProtocol {
  func search(request: DialogCalls.DialogCallHistorySearchRequest) -> RxSwift.Single<DialogCalls_GRPC.Dialog_GetPageResponse>
}
final public class DialogCallHistorySearchPerformer : DialogCalls.DialogCallHistorySearchPerformerProtocol {
  public init(searchService: DialogSwiftGRPCExtra.AnyServiceRessurector<DialogCalls_GRPC.Dialog_CallHistoryServiceService>, netService: DialogNetService.NetServiceProtocol)
  final public func search(request: DialogCalls.DialogCallHistorySearchRequest) -> RxSwift.Single<DialogCalls_GRPC.Dialog_GetPageResponse>
  @objc deinit
}
public protocol DialogCallsHistorySeqUpdatesServiceProtocol {
  var seqUpdates: RxSwift.Observable<DialogCalls_GRPC.Dialog_ConnectResponse> { get }
}
public class DialogCallsHistorySeqUpdatesService : DialogCalls.DialogCallsHistorySeqUpdatesServiceProtocol {
  public var seqUpdates: RxSwift.Observable<DialogCalls_GRPC.Dialog_ConnectResponse>
  public init(channelService: DialogProtocols.DialogChannelServiceProtocol)
  @objc deinit
}
public protocol DialogCallsHistoryMissedCountProvider {
  var missedCount: RxCocoa.Driver<Swift.Int> { get }
}
public protocol DialogCallsHistoryServiceProtocol : DialogCalls.DialogCallsHistoryMissedCountProvider {
  var missedCount: RxCocoa.Driver<Swift.Int> { get }
  func deleteCallHistory(for callIds: [DialogCalls.CallID]) -> RxSwift.Observable<Swift.Void>
  func getPage(request: DialogCalls.DialogHistoryCallGetPageRequest) -> RxSwift.Observable<[DialogProtocols.DialogHistoryCall]>
  func getDiff(request: DialogCalls.DialogHistoryCallGetDiffRequest) -> RxSwift.Observable<DialogCalls.DialogHistoryCallGetDiffResponse>
  func markViewed()
}
public class DialogCallsHistoryService : DialogCalls.DialogCallsHistoryServiceProtocol {
  public var missedCount: RxCocoa.Driver<Swift.Int> {
    get
    set
  }
  public static let connectStreamRestoreInterval: Swift.Double
  public init(channelService: DialogProtocols.DialogChannelServiceProtocol, eventBus: DialogProtocols.EventBusServiceProtocol, storageService: DialogStorage.DialogStorageServiceProtocol, seqUpdatesService: DialogCalls.DialogCallsHistorySeqUpdatesServiceProtocol, netService: DialogNetService.NetServiceProtocol, taskProvider: DialogNetService.GRPCTaskProviderProtocol)
  public func deleteCallHistory(for callIds: [DialogCalls.CallID]) -> RxSwift.Observable<Swift.Void>
  public func getPage(request: DialogCalls.DialogHistoryCallGetPageRequest) -> RxSwift.Observable<[DialogProtocols.DialogHistoryCall]>
  public func getDiff(request: DialogCalls.DialogHistoryCallGetDiffRequest) -> RxSwift.Observable<DialogCalls.DialogHistoryCallGetDiffResponse>
  public func markViewed()
  @objc deinit
}
public struct DialogCallsInboundAudioMetric : Swift.Codable, Swift.Equatable {
  public let packetsReceived: Swift.Int
  public let packetsLost: Swift.Int
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public static func == (a: DialogCalls.DialogCallsInboundAudioMetric, b: DialogCalls.DialogCallsInboundAudioMetric) -> Swift.Bool
}
public struct DialogCallsInboundVideoMetric : Swift.Codable, Swift.Equatable {
  public let packetsReceived: Swift.Int
  public let packetsLost: Swift.Int
  public let firCount: Swift.Int
  public let pliCount: Swift.Int
  public let nackCount: Swift.Int
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public static func == (a: DialogCalls.DialogCallsInboundVideoMetric, b: DialogCalls.DialogCallsInboundVideoMetric) -> Swift.Bool
}
public enum DialogCallsMetric {
  case outboundAudio(model: DialogCalls.DialogCallsOutboundAudioMetric)
  case inboundAudio(model: DialogCalls.DialogCallsInboundAudioMetric)
  case outboundVideo(model: DialogCalls.DialogCallsOutboundVideoMetric)
  case inboundVideo(model: DialogCalls.DialogCallsInboundVideoMetric)
  case callFinished(model: DialogCalls.DialogCallsFinishedCallMetric)
}
extension DialogCallsMetric : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension DialogCallsMetric : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension DialogCallsMetric {
  public func mapToDialogEventMetrics() -> [DialogCalls.DialogCallsMetricTrackEventInfo]
}
final public class DialogCallsMetricsService : DialogCalls.DialogCallsMetricsServiceProtocol {
  public init(callsService: DialogCalls.CallsServiceProtocol, storageService: DialogCalls.DialogCallsMetricsStorageServiceProtocol, metricsService: DialogMetrics.DialogMetricsServiceProtocol, featureFlagsService: DialogProtocols.DialogFeatureFlagsServiceProtocol)
  @objc deinit
}
public protocol DialogCallsMetricsServiceProtocol : AnyObject {
}
public struct DialogCallsMetricsStatisticsParser {
  public let report: DialogCalls.StatsReport
  public func parse() -> DialogCalls.DialogCallsMetric?
}
final public class DialogCallsMetricsStorageService : DialogCalls.DialogCallsMetricsStorageServiceProtocol {
  public static let storageKey: Swift.String
  public static let storageVersion: Swift.String
  public init(storageService: DialogStorage.DialogStorageServiceProtocol)
  final public func store(events: [DialogCalls.DialogCallsMetricStoragableEvent]) -> RxSwift.Observable<[DialogCalls.DialogCallsMetricStoragableEvent]>
  final public func observeAllEvents() -> RxSwift.Observable<[DialogCalls.DialogCallsMetricStoragableEvent]>
  final public func removeAllEvents()
  @objc deinit
}
public protocol DialogCallsMetricsStorageServiceProtocol {
  func store(events: [DialogCalls.DialogCallsMetricStoragableEvent]) -> RxSwift.Observable<[DialogCalls.DialogCallsMetricStoragableEvent]>
  func removeAllEvents()
  func observeAllEvents() -> RxSwift.Observable<[DialogCalls.DialogCallsMetricStoragableEvent]>
}
public struct DialogCallsMetricStoragableEvent : DialogStorage.DialogStoragableProtocol {
  public let uid: Swift.String
  public let timestamp: Foundation.TimeInterval
  public let metric: DialogCalls.DialogCallsMetric
  public let callId: DialogCalls.CallID
  public init(metric: DialogCalls.DialogCallsMetric, callId: DialogCalls.CallID, uid: Swift.String = UUID().uuidString, timestamp: Foundation.TimeInterval = Date().timeIntervalSince1970)
  public func requireToCreateTable(in database: GRDB.Database) throws
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension DialogCallsMetricStoragableEvent : Swift.Equatable {
  public static func == (lhs: DialogCalls.DialogCallsMetricStoragableEvent, rhs: DialogCalls.DialogCallsMetricStoragableEvent) -> Swift.Bool
}
public struct DialogCallsMetricTrackEventInfo {
  public let action: DialogMetrics.DialogEventMetric.Action
  public let value: Swift.Double
}
extension DialogCallsMissedCountState : Swift.Codable {
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case clock
    case count
    case singletonInstance
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
    public init?(stringValue: Swift.String)
    public var intValue: Swift.Int? {
      get
    }
    public init?(intValue: Swift.Int)
  }
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension DialogCallsMissedCountState : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension DialogCallsMissedCountState : GRDB.MutablePersistableRecord {
  public static let persistenceConflictPolicy: GRDB.PersistenceConflictPolicy
}
extension DialogCallsMissedCountState : DialogStorage.DialogStoragableProtocol {
  public func requireToCreateTable(in database: GRDB.Database) throws
}
extension DialogCallsMissedCountState {
  public init(grpc: DialogCalls_GRPC.Dialog_GetMissedCallsCountResponse)
}
public struct DialogCallsOutboundAudioMetric : Swift.Codable, Swift.Equatable {
  public let packetsSent: Swift.Int
  public let retransmittedPacketsSent: Swift.Int
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public static func == (a: DialogCalls.DialogCallsOutboundAudioMetric, b: DialogCalls.DialogCallsOutboundAudioMetric) -> Swift.Bool
}
public struct DialogCallsOutboundVideoMetric : Swift.Codable, Swift.Equatable {
  public let packetsSent: Swift.Int
  public let retransmittedPacketsSent: Swift.Int
  public let firCount: Swift.Int
  public let pliCount: Swift.Int
  public let nackCount: Swift.Int
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public static func == (a: DialogCalls.DialogCallsOutboundVideoMetric, b: DialogCalls.DialogCallsOutboundVideoMetric) -> Swift.Bool
}
public enum ConferenceType : Swift.Equatable {
  case tcs
  case vcs
  case unrecognized(Swift.Int)
  public static func == (a: DialogCalls.ConferenceType, b: DialogCalls.ConferenceType) -> Swift.Bool
}
@_hasMissingDesignatedInitializers public class DialogConference {
  final public let id: Swift.Int64
  final public let groupId: Swift.Int32
  final public let startAt: Swift.Int64
  final public let endAt: Swift.Int64
  final public let dialLink: Swift.String
  final public let type: DialogCalls.ConferenceType
  public struct Parameters {
    public let id: Swift.Int64
    public let confId: Swift.String
    public let param: Swift.String
    public let link: Foundation.URL
    public init?(_ parameters: [Swift.String : Swift.String], link: Foundation.URL)
    public var map: [Swift.String : Swift.String] {
      get
    }
    public var isLegacy: Swift.Bool {
      get
    }
  }
  @objc deinit
}
public protocol DialogConferenceServiceProtocol {
  func getConference(request: DialogCalls.GetConferenceRequest) -> RxSwift.Observable<DialogCalls.DialogConference>
  func createConference(request: DialogCalls.CreateConferenceRequest) -> RxSwift.Observable<DialogCalls.DialogConference>
  func updateConference(request: DialogCalls.UpdateConferenceRequest) -> RxSwift.Observable<DialogCalls.DialogConference>
  func deleteConference(request: DialogCalls.DeleteConferenceRequest) -> RxSwift.Observable<Swift.Void>
}
public class DialogConferenceService : DialogCalls.DialogConferenceServiceProtocol {
  public init(netService: DialogNetService.NetServiceProtocol, channelService: DialogProtocols.DialogChannelServiceProtocol, groupService: DialogProtocols.DialogGroupServiceProtocol, dialogService: DialogMessaging.DialogServiceProtocol, eventBus: DialogProtocols.EventBusServiceProtocol, localSyncService: DialogMessaging.LocalSyncPersistanceServiceProtocol)
  public func getConference(request: DialogCalls.GetConferenceRequest) -> RxSwift.Observable<DialogCalls.DialogConference>
  public func createConference(request: DialogCalls.CreateConferenceRequest) -> RxSwift.Observable<DialogCalls.DialogConference>
  public func updateConference(request: DialogCalls.UpdateConferenceRequest) -> RxSwift.Observable<DialogCalls.DialogConference>
  public func deleteConference(request: DialogCalls.DeleteConferenceRequest) -> RxSwift.Observable<Swift.Void>
  @objc deinit
}
extension Dialog_ConferenceResponse.ErrorModel : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
extension DialogHistoryCall : GRDB.MutablePersistableRecord {
  public static let persistenceConflictPolicy: GRDB.PersistenceConflictPolicy
}
extension DialogHistoryCall : DialogStorage.DialogStoragableProtocol {
  public func requireToCreateTable(in database: GRDB.Database) throws
}
extension DialogHistoryCall {
  public init(grpc: DialogCalls_GRPC.Dialog_CreatedCallModel)
}
public enum GetConferenceRequest {
  case byId(Swift.Int64)
  case byGroupId(Swift.Int32)
}
public typealias IceSettingsModel = DialogCalls_GRPC.DialogCalls_ConnectToCallSuccessModel.IceSettingsModel
public typealias IceServerModel = DialogCalls.IceSettingsModel.IceServerModel
public typealias GenerateIdResponseSuccessModel = DialogCalls_GRPC.DialogCalls_GenerateIdResponse.GenerateIdResponseSuccessModel
public typealias GenerateIdResponseErrorModel = DialogCalls_GRPC.DialogCalls_GenerateIdResponse.GenerateIdResponseErrorModel
public typealias CreateCallResponseSuccessModel = DialogCalls_GRPC.DialogCalls_CreateCallResponse.CreateCallResponseSuccessModel
public typealias CreateCallResponseErrorModel = DialogCalls_GRPC.DialogCalls_CreateCallResponse.CreateCallResponseErrorModel
public typealias RingingCallResponseSuccessModel = DialogCalls_GRPC.DialogCalls_RingingCallResponse.RingingCallResponseSuccessModel
public typealias RingingCallResponseErrorModel = DialogCalls_GRPC.DialogCalls_RingingCallResponse.RingingCallResponseErrorModel
public typealias AnswerCallResponseSuccessModel = DialogCalls_GRPC.DialogCalls_AnswerCallResponse.AnswerCallResponseSuccessModel
public typealias AnswerCallResponseErrorModel = DialogCalls_GRPC.DialogCalls_AnswerCallResponse.AnswerCallResponseErrorModel
public typealias DisposeCallResponseSuccessModel = DialogCalls_GRPC.DialogCalls_DisposeCallResponse.DisposeCallResponseSuccessModel
public typealias DisposeCallResponseErrorModel = DialogCalls_GRPC.DialogCalls_DisposeCallResponse.DisposeCallResponseErrorModel
public typealias LockCallResponseSuccessModel = DialogCalls_GRPC.DialogCalls_LockCallResponse.LockCallResponseSuccessModel
public typealias LockCallResponseErrorModel = DialogCalls_GRPC.DialogCalls_LockCallResponse.LockCallResponseErrorModel
public typealias JoinCallResponseSuccessModel = DialogCalls_GRPC.DialogCalls_JoinCallResponse.JoinCallResponseSuccessModel
public typealias JoinCallResponseErrorModel = DialogCalls_GRPC.DialogCalls_JoinCallResponse.JoinCallResponseErrorModel
public typealias IceCallRequestCandidateItemModel = DialogCalls_GRPC.DialogCalls_IceCallRequest.IceCallRequestCandidateItemModel
public typealias IceCandidateModel = DialogCalls.IceCallRequestCandidateItemModel.IceCandidateModel
public typealias IceCallResponseSuccessModel = DialogCalls_GRPC.DialogCalls_IceCallResponse.IceCallResponseSuccessModel
public typealias IceCallResponseErrorModel = DialogCalls_GRPC.DialogCalls_IceCallResponse.IceCallResponseErrorModel
public typealias ServerCallListModel = DialogCalls_GRPC.DialogCalls_ConnectResponse.ConnectResponseServerCallListModel
public typealias ServerCallListItemModel = DialogCalls.ServerCallListModel.ConnectResponseServerCallListItemModel
public typealias DisposeCallModel = DialogCalls_GRPC.DialogCalls_ConnectResponse.ConnectResponseDisposeCallModel
public typealias JoinCallModel = DialogCalls_GRPC.DialogCalls_ConnectResponse.ConnectResponseJoinCallModel
public typealias IceCallModel = DialogCalls_GRPC.DialogCalls_ConnectResponse.ConnectResponseIceCallModel
public typealias RenegotiateModel = DialogCalls_GRPC.DialogCalls_ConnectResponse.ConnectResponseRenegotiateCallModel
public typealias MergeCallModel = DialogCalls_GRPC.DialogCalls_MergeCallModel
public enum LocalVideoPositionState : Swift.UInt8, Swift.Equatable {
  case none
  case bitmap
  case front
  case back
  public var isNative: Swift.Bool {
    get
  }
  public var frontOriented: Swift.Bool {
    get
  }
  public typealias RawValue = Swift.UInt8
  public init?(rawValue: Swift.UInt8)
  public var rawValue: Swift.UInt8 {
    get
  }
}
@_hasMissingDesignatedInitializers final public class LocalVideo {
  final public let track: WebRTC.RTCVideoTrack
  final public let positionStateObservable: RxSwift.Observable<DialogCalls.LocalVideoPositionState>
  final public var isPreviewPreferred: RxSwift.Observable<Swift.Bool>
  final public var isVideoEnabled: Swift.Bool {
    get
  }
  final public var aspectRatioObservable: RxSwift.Observable<CoreGraphics.CGFloat>
  final public var aspectRatio: CoreGraphics.CGFloat {
    get
  }
  final public var avatarPlaceholderObserver: RxSwift.AnyObserver<UIKit.UIImage> {
    get
    set
  }
  final public func stopVideo() -> RxSwift.Observable<Swift.Void>
  final public func startVideo(withFrontCamera front: Swift.Bool = false) -> RxSwift.Observable<Swift.Void>
  final public func switchCamera() -> RxSwift.Observable<Swift.Void>
  @objc deinit
}
public enum LocalVideoError : Swift.Error {
  case failedToFindAppropriateCaptureDevice(front: Swift.Bool)
  case failedToFindAppropriateFormat(device: AVFoundation.AVCaptureDevice)
}
extension LocalVideo : Swift.Equatable {
  public static func == (lhs: DialogCalls.LocalVideo, rhs: DialogCalls.LocalVideo) -> Swift.Bool
}
public struct MappedCallParameters : Swift.Equatable {
  public var userId: Swift.String? {
    get
  }
  public var accessHash: Swift.String? {
    get
  }
  public var phone: Swift.String? {
    get
  }
  public var useExtPhone: Swift.Bool? {
    get
  }
  public var name: Swift.String? {
    get
  }
  public var localName: Swift.String? {
    get
  }
  public var groupCallType: Swift.String? {
    get
  }
  public var tcsLink: Swift.String? {
    get
  }
  public var link: Swift.String? {
    get
  }
  public init(dictionary: [Swift.String : Swift.String])
  public var peer: DialogProtocols.DialogPeer? {
    get
  }
  public func isEqual(to dictionary: [Swift.String : Swift.String]) -> Swift.Bool
  public static func == (a: DialogCalls.MappedCallParameters, b: DialogCalls.MappedCallParameters) -> Swift.Bool
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class VideoTrackAdapter : DialogCalls.MediaTrackAdapter<WebRTC.RTCVideoTrack> {
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class AudioTrackAdapter : DialogCalls.MediaTrackAdapter<WebRTC.RTCAudioTrack> {
  @objc deinit
}
@_hasMissingDesignatedInitializers public class MediaTrackAdapter<T> : DialogCalls.MediaTrackAdapterProtocol where T : WebRTC.RTCMediaStreamTrack {
  public typealias Track = T
  final public let track: DialogCalls.MediaTrackAdapter<T>.Track
  public var stateObservable: RxSwift.Observable<DialogCalls.MediaTrackState> {
    get
  }
  public var state: DialogCalls.MediaTrackState {
    get
  }
  public func stop()
  public func setState(_ newState: DialogCalls.MediaTrackState)
  @objc deinit
}
public protocol MediaTrackAdapterProtocol {
  associatedtype Track : WebRTC.RTCMediaStreamTrack
  var track: Self.Track { get }
  var state: DialogCalls.MediaTrackState { get }
  var stateObservable: RxSwift.Observable<DialogCalls.MediaTrackState> { get }
}
public enum MediaTrackState : Swift.String {
  case unmuted
  case muted
  case stopped
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
extension RTCIceConnectionState : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension RTCIceGatheringState : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension RTCPeerConnection {
  public enum StatsTarget {
    case track(WebRTC.RTCMediaStreamTrack)
    case allTracks
    public var track: WebRTC.RTCMediaStreamTrack? {
      get
    }
  }
}
extension Reactive where Base : WebRTC.RTCPeerConnection {
  public func getStats() -> RxSwift.Single<[WebRTC.RTCStatistics]>
  public func setRemoteDescription(sdp: WebRTC.RTCSessionDescription) -> RxSwift.Observable<Swift.Void>
  public func setLocalDescription(sdp: WebRTC.RTCSessionDescription) -> RxSwift.Observable<Swift.Void>
  public func createOffer(forMediaConstraints constraints: WebRTC.RTCMediaConstraints) -> RxSwift.Observable<WebRTC.RTCSessionDescription>
  public func createAnswer(forMediaConstraints constraints: WebRTC.RTCMediaConstraints) -> RxSwift.Observable<WebRTC.RTCSessionDescription>
}
extension RTCSdpType : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension RTCSignalingState : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct StatsReport {
  public enum StreamType : Swift.String {
    case inboundAudio
    case outboundAudio
    case inboundVideo
    case outboundVideo
    case unknown
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
  public var timestamp: CoreFoundation.CFTimeInterval
  public var type: Swift.String
  public var reportId: Swift.String
  public var values: [Swift.String : ObjectiveC.NSObject]
  public subscript(key: DialogCalls.StatsReport.Key) -> ObjectiveC.NSObject? {
    get
  }
  public subscript(key: Swift.String) -> ObjectiveC.NSObject? {
    get
  }
  public var mediaType: Swift.String? {
    get
  }
  public var packetsSent: Swift.Int? {
    get
  }
  public var packetsReceived: Swift.Int? {
    get
  }
  public var packetsLost: Swift.Int? {
    get
  }
  public var retransmittedPacketsSent: Swift.Int? {
    get
  }
  public var firCount: Swift.Int? {
    get
  }
  public var pliCount: Swift.Int? {
    get
  }
  public var nackCount: Swift.Int? {
    get
  }
  public var streamType: DialogCalls.StatsReport.StreamType {
    get
  }
  public init(report: WebRTC.RTCStatistics)
}
extension StatsReport {
  public struct Key : Swift.RawRepresentable {
    public typealias RawValue = Swift.String
    public let rawValue: DialogCalls.StatsReport.Key.RawValue
    public init(rawValue: DialogCalls.StatsReport.Key.RawValue)
    public init(_ rawValue: DialogCalls.StatsReport.Key.RawValue)
    public static let bytesReceived: DialogCalls.StatsReport.Key
    public static let audioOutputLevel: DialogCalls.StatsReport.Key
    public static let mediaType: DialogCalls.StatsReport.Key
    public static let packetsLost: DialogCalls.StatsReport.Key
    public static let packetsReceived: DialogCalls.StatsReport.Key
    public static let packetsSent: DialogCalls.StatsReport.Key
    public static let retransmittedPacketsSent: DialogCalls.StatsReport.Key
    public static let firCount: DialogCalls.StatsReport.Key
    public static let pliCount: DialogCalls.StatsReport.Key
    public static let nackCount: DialogCalls.StatsReport.Key
  }
}
public struct UpdateConferenceRequest {
}
extension DialogCalls.CallDisposeReason : Swift.Equatable {}
extension DialogCalls.CallDisposeReason : Swift.Hashable {}
extension DialogCalls.CallDisposeReason : Swift.RawRepresentable {}
extension DialogCalls.CallDtmf : Swift.Equatable {}
extension DialogCalls.CallDtmf : Swift.Hashable {}
extension DialogCalls.CallDtmf : Swift.RawRepresentable {}
extension DialogCalls.CallHangupReason : Swift.Equatable {}
extension DialogCalls.CallHangupReason : Swift.Hashable {}
extension DialogCalls.CallHangupReason : Swift.RawRepresentable {}
extension DialogCalls.CallEndedReason : Swift.Equatable {}
extension DialogCalls.CallEndedReason : Swift.Hashable {}
extension DialogCalls.CallEndedReason : Swift.RawRepresentable {}
extension DialogCalls.CallsNetworkingServiceError : Swift.Equatable {}
extension DialogCalls.CallsNetworkingServiceError : Swift.Hashable {}
extension DialogCalls.HangupCallReason : Swift.Equatable {}
extension DialogCalls.HangupCallReason : Swift.Hashable {}
extension DialogCalls.CallState : Swift.Equatable {}
extension DialogCalls.CallState : Swift.Hashable {}
extension DialogCalls.CallState : Swift.RawRepresentable {}
extension DialogProtocols.DialogCallsMissedCountState.CodingKeys : Swift.Equatable {}
extension DialogProtocols.DialogCallsMissedCountState.CodingKeys : Swift.Hashable {}
extension DialogProtocols.DialogCallsMissedCountState.CodingKeys : Swift.RawRepresentable {}
extension DialogCalls.LocalVideoPositionState : Swift.Hashable {}
extension DialogCalls.LocalVideoPositionState : Swift.RawRepresentable {}
extension DialogCalls.MediaTrackState : Swift.Equatable {}
extension DialogCalls.MediaTrackState : Swift.Hashable {}
extension DialogCalls.MediaTrackState : Swift.RawRepresentable {}
extension DialogCalls.StatsReport.StreamType : Swift.Equatable {}
extension DialogCalls.StatsReport.StreamType : Swift.Hashable {}
extension DialogCalls.StatsReport.StreamType : Swift.RawRepresentable {}
