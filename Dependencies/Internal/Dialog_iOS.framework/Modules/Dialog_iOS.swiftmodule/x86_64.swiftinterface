// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.3 (swiftlang-1200.0.29.2 clang-1200.0.30.1)
// swift-module-flags: -target x86_64-apple-ios11.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name Dialog_iOS
import AVFoundation
import AVKit
import Alamofire
import AssetsLibrary
import AsyncDisplayKit
import AudioToolbox
import CallKit
import CoreGraphics
import CoreImage
import CoreTelephony
import DLGPicker
import DLGPicker/*.TelegramSelectionType*/
import DialogAuth
import DialogCalls
import DialogCalls_GRPC
import DialogFeatureFlags
import DialogFiles
import DialogFiles/*.DialogFileServiceProtocol*/
import DialogFilter
import DialogMessaging
import DialogMessaging/*.DialogServiceMessageContent*/
import DialogMetrics
import DialogMiniAppService
import DialogMuteSettingsService
import DialogNetService
import DialogNetworking
import DialogNotifications
import DialogPasscode
import DialogPasscodeUI
import DialogPrivateProfile
import DialogProtocols
import DialogRx
import DialogSDK_GRPC
import DialogSearching
import DialogSecureStorage
import DialogSettingsConfigService
import DialogSharedComponents
import DialogSpeech
import DialogStorage
import DialogSwiftGRPCExtra
import Dialog_gRPC_Objc
@_exported import Dialog_iOS
import Differentiator
import Differentiator/*.AnimatableSectionModelType*/
import Differentiator/*.SectionModelType*/
import Emoji
import Foundation
import GRDB
import InputBarAccessoryView
import Intents
import KeychainAccess
import MediaPlayer
import MobileCoreServices
import NaturalLanguage
import ObjectiveC
import PhoneNumberKit
import Photos
import PushKit
import QuartzCore
import QuickLook
import RSKImageCropper
import Reachability
import RxASDataSources
import RxAlamofire
import RxAnimated
import RxBiBinding
import RxCocoa
import RxCocoa_Texture
import RxDataSources
import RxGesture
import RxKeyboard
import RxRelay
import RxSwift
import RxSwiftExt
import RxTheme
import Sentry
import SnapKit
import Speech
import Swift
import SwiftDate
import SwiftGRPC
import SwiftProtobuf
import Swinject
import SystemConfiguration
import TrustKit
import UIKit
import UIKit.UIView
import UIKit.UIViewController
import UserNotifications
import ViewAnimator
import WebKit
import WebRTC
import XCoordinator
@_hasMissingDesignatedInitializers open class AbstractRxConfigurator<Object> {
  open func createBindings(to: Object) -> [RxSwift.Disposable]
  public func bind(to: Object) -> RxSwift.Disposable
  @objc deinit
}
public typealias ActiveCallBarSceneArgument = Swift.Void
@_inheritsConvenienceInitializers final public class ActiveCallBarScene : Dialog_iOS.Scene<Dialog_iOS.ActiveCallBarSceneArgument, UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.ActiveCallBarScene.Builder
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<Dialog_iOS.ActiveCallBarSceneArgument, UIKit.UIViewController, Dialog_iOS.ActiveCallBarViewModelProtocol> {
    override final public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Dialog_iOS.ActiveCallBarSceneArgument>) -> Dialog_iOS.ActiveCallBarViewModelProtocol
    override final public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Dialog_iOS.ActiveCallBarSceneArgument>, viewModel: Dialog_iOS.ActiveCallBarViewModelProtocol) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<Dialog_iOS.ActiveCallBarSceneArgument, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
public protocol ActiveCallBarViewControllerDesignProtocol {
  var backgroundColor: UIKit.UIColor { get }
  var errorBackgroundColor: UIKit.UIColor { get }
  var titleLabelAttributes: [Foundation.NSAttributedString.Key : Any] { get }
  var bottomSpacing: CoreGraphics.CGFloat { get }
  var animationAlpha: Swift.Float { get }
  var animationDuration: CoreFoundation.CFTimeInterval { get }
}
public struct ActiveCallBarViewControllerDefaultStyle : Dialog_iOS.ActiveCallBarViewControllerDesignProtocol {
  public var backgroundColor: UIKit.UIColor
  public var errorBackgroundColor: UIKit.UIColor
  public var titleLabelAttributes: [Foundation.NSAttributedString.Key : Any] {
    get
  }
  public let bottomSpacing: CoreGraphics.CGFloat
  public let animationAlpha: Swift.Float
  public let animationDuration: CoreFoundation.CFTimeInterval
}
@objc @_hasMissingDesignatedInitializers public class ActiveCallBarViewController : UIKit.UIViewController {
  public init(viewModel: Dialog_iOS.ActiveCallBarViewModelProtocol, design: Dialog_iOS.ActiveCallBarViewControllerDesignProtocol)
  @objc override dynamic public var preferredStatusBarStyle: UIKit.UIStatusBarStyle {
    @objc get
  }
  @objc override dynamic public func viewDidLoad()
  @objc override dynamic public func viewDidAppear(_ animated: Swift.Bool)
  @objc override dynamic public func viewDidDisappear(_ animated: Swift.Bool)
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc deinit
}
public protocol ActiveCallBarViewModelProtocol {
  var titleTextDriver: RxCocoa.Driver<Swift.String> { get }
  var isStateDeclined: RxCocoa.Driver<Swift.Bool> { get }
  var tapSource: RxSwift.AnyObserver<Swift.Void> { get }
  func startTimer(withStateSource stateSource: RxSwift.Observable<DialogCalls.CallState>, nameSource: RxSwift.Observable<Swift.String?>, asnwerDateSource: RxSwift.Observable<Foundation.Date?>)
  func invalidateTimer()
}
extension CallDisposeReason {
  public var isStateDeclined: Swift.Bool {
    get
  }
}
public class ActiveCallVarViewModel : Dialog_iOS.ActiveCallBarViewModelProtocol {
  public var didTap: RxCocoa.Driver<Swift.Void> {
    get
    set
  }
  public var tapSource: RxSwift.AnyObserver<Swift.Void> {
    get
    set
  }
  public var isStateDeclined: RxCocoa.Driver<Swift.Bool> {
    get
    set
  }
  public var titleTextDriver: RxCocoa.Driver<Swift.String> {
    get
    set
  }
  public init(callsService: DialogCalls.CallsServiceProtocol, eventBusService: DialogProtocols.EventBusServiceProtocol)
  public func startTimer(withStateSource stateSource: RxSwift.Observable<DialogCalls.CallState>, nameSource: RxSwift.Observable<Swift.String?>, asnwerDateSource: RxSwift.Observable<Foundation.Date?>)
  public func invalidateTimer()
  @objc deinit
}
public typealias CallActionViewConfiguration = (Dialog_iOS.CallActionViewModelProtocol, Dialog_iOS.CallActionViewDesignProtocol)
public typealias CallSpeakerActionViewConfiguration = (Dialog_iOS.CallOptionallyTogglableActionViewModelProtocol, Dialog_iOS.CallActionViewDesignProtocol)
public struct ActiveCallButtonsPanelViewConfiguration {
}
@objc @_inheritsConvenienceInitializers public class ActiveCallButtonsPanelView : UIKit.UIView {
  public enum Distribution {
    case twoLines
    case oneLine
    public static func == (a: Dialog_iOS.ActiveCallButtonsPanelView.Distribution, b: Dialog_iOS.ActiveCallButtonsPanelView.Distribution) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  @objc override dynamic public func awakeFromNib()
  public func configure(_ configuration: Dialog_iOS.ActiveCallButtonsPanelViewConfiguration)
  public func configureDistribution(_ distribution: Dialog_iOS.ActiveCallButtonsPanelView.Distribution)
  public func configureDistribution(from traitCollection: UIKit.UITraitCollection)
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public protocol ActiveCallHeaderViewModelProtocol {
  var avatarVm: Dialog_iOS.ActiveCallAvatarViewModel { get }
  var callTitle: RxCocoa.Driver<Swift.String> { get }
  var callStatusTitle: RxCocoa.Driver<Swift.String> { get }
  var callDataModelObserver: RxSwift.AnyObserver<DialogCalls.CallDataModel> { get }
  var disposeReasonObserver: RxSwift.AnyObserver<DialogCalls.DisposedCallInfoModel?> { get }
}
public class ActiveCallHeaderViewModel : Dialog_iOS.ActiveCallHeaderViewModelProtocol {
  public var avatarVm: Dialog_iOS.ActiveCallAvatarViewModel
  public var callTitle: RxCocoa.Driver<Swift.String>
  public var callStatusTitle: RxCocoa.Driver<Swift.String>
  public var callDataModelObserver: RxSwift.AnyObserver<DialogCalls.CallDataModel>
  public var disposeReasonObserver: RxSwift.AnyObserver<DialogCalls.DisposedCallInfoModel?>
  public init(peer: DialogProtocols.DialogPeer, avatar: RxSwift.Observable<Dialog_iOS.ActiveCallAvatar>, fileService: DialogFiles.DialogFileServiceProtocol, callsService: DialogCalls.CallsServiceProtocol, mediaConfigService: DialogProtocols.MediaConfigServiceProtocol, userService: DialogProtocols.DialogUserServiceProtocol, colorService: Dialog_iOS.DialogPeerColorsServiceProtocol)
  @objc deinit
}
public typealias ActiveCallSceneArgument = Swift.Void
@_inheritsConvenienceInitializers final public class ActiveCallScene : Dialog_iOS.Scene<Dialog_iOS.ActiveCallSceneArgument, UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.ActiveCallScene.Builder
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<Dialog_iOS.ActiveCallSceneArgument, UIKit.UIViewController, Dialog_iOS.ActiveCallViewModelProtocol> {
    override final public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Dialog_iOS.ActiveCallSceneArgument>) -> Dialog_iOS.ActiveCallViewModelProtocol
    override final public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Dialog_iOS.ActiveCallSceneArgument>, viewModel: Dialog_iOS.ActiveCallViewModelProtocol) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<Dialog_iOS.ActiveCallSceneArgument, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
public protocol ActiveCallViewControllerDesignProtocol {
  var backgroundColor: UIKit.UIColor { get }
  var avatarBackgroundOverlayEffect: UIKit.UIVisualEffect? { get }
  var avatarBackgroundColor: UIKit.UIColor { get }
  var yCenterAvatarMultiplier: CoreGraphics.CGFloat { get }
  var localVideoMaxSide: CoreGraphics.CGFloat { get }
  var panelPaddings: UIKit.UIEdgeInsets { get }
  var gradientStyle: Dialog_iOS.DUIRadialGradientLayerStyle { get }
  var coverLabelAttributes: [Foundation.NSAttributedString.Key : Any] { get }
  var callPanelAppearAnimationDuration: Foundation.TimeInterval { get }
  var callPanelDisappearAnimationDuration: Foundation.TimeInterval { get }
}
extension ActiveCallViewControllerDesignProtocol {
  public var backgroundColor: UIKit.UIColor {
    get
  }
  public var avatarBackgroundColor: UIKit.UIColor {
    get
  }
  public var avatarBackgroundOverlayEffect: UIKit.UIVisualEffect? {
    get
  }
  public var yCenterAvatarMultiplier: CoreGraphics.CGFloat {
    get
  }
  public var localVideoMaxSide: CoreGraphics.CGFloat {
    get
  }
  public var avatarSideLength: CoreGraphics.CGFloat {
    get
  }
  public var panelPaddings: UIKit.UIEdgeInsets {
    get
  }
  public var gradientStyle: Dialog_iOS.DUIRadialGradientLayerStyle {
    get
  }
  public var kDefaultPadding: CoreGraphics.CGFloat {
    get
  }
  public var kTopPadding: CoreGraphics.CGFloat {
    get
  }
  public var kUsernameToStatusLabelPadding: CoreGraphics.CGFloat {
    get
  }
  public var kUsernameHeight: CoreGraphics.CGFloat {
    get
  }
  public var kUsernameTopPadding: CoreGraphics.CGFloat {
    get
  }
  public var coverLabelAttributes: [Foundation.NSAttributedString.Key : Any] {
    get
  }
  public static var avatarSideLength: CoreGraphics.CGFloat {
    get
  }
}
public struct ActiveCallViewControllerDefaultStyle : Dialog_iOS.ActiveCallViewControllerDesignProtocol {
  public var callPanelAppearAnimationDuration: Swift.Double
  public var callPanelDisappearAnimationDuration: Swift.Double
}
public struct ActiveCallBackgroundAvatarViewDesign : Dialog_iOS.AvatarViewStyleProtocol {
  public var centerTextColor: UIKit.UIColor
  public var centerTextFont: UIKit.UIFont
  public let showsText: Swift.Bool
  public var cornerRadius: DialogSharedComponents.CornerRadiusType
  public var avatarLoaderActivityStyle: UIKit.UIActivityIndicatorView.Style
  public var sideLength: CoreGraphics.CGFloat
  public var gradientStartPoint: CoreGraphics.CGPoint
  public var gradientEndPoint: CoreGraphics.CGPoint
  public var gradientColors: [Any]?
}
public struct ActiveCallAvatarViewDesign : Dialog_iOS.AvatarViewStyleProtocol {
  public var centerTextColor: UIKit.UIColor
  public var centerTextFont: UIKit.UIFont
  public var cornerRadius: Dialog_iOS.CornerRadiusType
  public var avatarLoaderActivityStyle: UIKit.UIActivityIndicatorView.Style
  public var sideLength: CoreGraphics.CGFloat {
    get
  }
  public var gradientStartPoint: CoreGraphics.CGPoint
  public var gradientEndPoint: CoreGraphics.CGPoint
  public var gradientColors: [Any]?
}
@objc @_hasMissingDesignatedInitializers public class ActiveCallViewController : UIKit.UIViewController {
  public typealias VM = Dialog_iOS.ActiveCallViewModelProtocol
  public init(viewModel: Dialog_iOS.ActiveCallViewController.VM, design: Dialog_iOS.ActiveCallViewControllerDesignProtocol)
  @objc override dynamic public var prefersStatusBarHidden: Swift.Bool {
    @objc get
  }
  @objc override dynamic public var preferredStatusBarStyle: UIKit.UIStatusBarStyle {
    @objc get
  }
  @objc override dynamic public var preferredStatusBarUpdateAnimation: UIKit.UIStatusBarAnimation {
    @objc get
  }
  @objc override dynamic public func viewDidLoad()
  @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @objc override dynamic public func viewWillDisappear(_ animated: Swift.Bool)
  @objc override dynamic public func viewDidLayoutSubviews()
  @objc override dynamic public func willTransition(to newCollection: UIKit.UITraitCollection, with coordinator: UIKit.UIViewControllerTransitionCoordinator)
  @objc override dynamic public var supportedInterfaceOrientations: UIKit.UIInterfaceOrientationMask {
    @objc get
  }
  @objc deinit
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
}
extension ActiveCallViewController : UIKit.UIGestureRecognizerDelegate {
  @objc dynamic public func gestureRecognizerShouldBegin(_ gestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
}
extension ActiveCallViewController : UIKit.UIScrollViewDelegate {
  @objc dynamic public func viewForZooming(in scrollView: UIKit.UIScrollView) -> UIKit.UIView?
}
extension UIWindow.Level {
  public static let calls: UIKit.UIWindow.Level
}
extension UIApplication {
  public var callsWindow: UIKit.UIWindow? {
    get
  }
}
public enum PresentConflictPolicy {
  case ignore
  case replace
  public static func == (a: Dialog_iOS.PresentConflictPolicy, b: Dialog_iOS.PresentConflictPolicy) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol ActiveCallWindowPresenterProtocol {
  func show(viewController: UIKit.UIViewController, onConflict conflictPolicy: Dialog_iOS.PresentConflictPolicy)
  func hide()
}
@objc public class ActiveCallWindowPresenter : ObjectiveC.NSObject, Dialog_iOS.ActiveCallWindowPresenterProtocol {
  public var conflictPolicy: Dialog_iOS.PresentConflictPolicy
  public func show(viewController: UIKit.UIViewController, onConflict conflictPolicy: Dialog_iOS.PresentConflictPolicy)
  @objc deinit
  public func hide()
  public init(rootWindow: UIKit.UIWindow)
  @objc override dynamic public init()
}
extension ActiveCallWindowPresenter : UIKit.UIAdaptivePresentationControllerDelegate {
  @available(iOS 13.0, *)
  @objc dynamic public func presentationControllerDidDismiss(_ presentationController: UIKit.UIPresentationController)
  @available(iOS 13.0, *)
  @objc dynamic public func presentationControllerShouldDismiss(_ presentationController: UIKit.UIPresentationController) -> Swift.Bool
}
extension ActiveCallWindowPresenter : UIKit.UIGestureRecognizerDelegate {
}
public struct ActiveCallAvatar {
}
public struct ActiveCallAvatarViewModel : Dialog_iOS.AvatarViewModelProtocol {
  public let basicColor: UIKit.UIColor
  public let isAvatarLoading: RxCocoa.Driver<Swift.Bool>
  public let avatarImage: RxCocoa.Driver<UIKit.UIImage?>
  public let avatarCenterText: RxCocoa.Driver<Swift.String?>
}
public enum ActiveCallState : Swift.Equatable {
  case audio
  case waitingVideoSession
  case video(receiving: Swift.Bool)
  public var isAudio: Swift.Bool {
    get
  }
  public var isVideo: Swift.Bool {
    get
  }
  public static func == (a: Dialog_iOS.ActiveCallState, b: Dialog_iOS.ActiveCallState) -> Swift.Bool
}
public protocol ActiveCallViewModelProtocol {
  var audioActionVM: Dialog_iOS.CallActionViewModelProtocol { get }
  var videoActionVM: Dialog_iOS.CallActionViewModelProtocol { get }
  var speakerActionVM: Dialog_iOS.CallOptionallyTogglableActionViewModelProtocol { get }
  var addActionVM: Dialog_iOS.CallActionViewModelProtocol { get }
  var declineActionVM: Dialog_iOS.CallActionViewModelProtocol { get }
  var chatActionVM: Dialog_iOS.CallActionViewModelProtocol { get }
  var headerViewModel: Dialog_iOS.ActiveCallHeaderViewModelProtocol { get }
  var avatarVm: Dialog_iOS.ActiveCallAvatarViewModel { get }
  var didTapDismiss: RxSwift.AnyObserver<Swift.Void> { get }
  var remoteVideoTrackObservable: RxSwift.Observable<WebRTC.RTCVideoTrack?> { get }
  var shouldShowCallPanel: RxCocoa.Driver<Swift.Bool> { get }
  var state: RxCocoa.Driver<Dialog_iOS.ActiveCallState> { get }
  var isRemoteVideoEnabled: RxSwift.Observable<Swift.Bool> { get }
  var isLocalVideoEnabled: RxSwift.Observable<Swift.Bool> { get }
  var isRemoteVideoPacketsReceiving: RxSwift.Observable<DialogCalls.MediaPacketsReceivingState> { get }
  var localVideoObservable: RxSwift.Observable<DialogCalls.LocalVideo?> { get }
  var changeCameraTap: RxSwift.AnyObserver<Swift.Void> { get }
  var videoViewTap: RxSwift.AnyObserver<Swift.Void> { get }
  var callFinished: RxSwift.Observable<DialogCalls.CallDisposeReason> { get }
  var localVideoAspectRatio: RxSwift.Observable<CoreGraphics.CGFloat> { get }
}
@_hasMissingDesignatedInitializers public class ActiveCallViewModel : Dialog_iOS.ActiveCallViewModelProtocol {
  public struct Dependencies {
  }
  public var headerViewModel: Dialog_iOS.ActiveCallHeaderViewModelProtocol
  public var avatarVm: Dialog_iOS.ActiveCallAvatarViewModel {
    get
  }
  public var audioActionVM: Dialog_iOS.CallActionViewModelProtocol {
    get
  }
  public var videoActionVM: Dialog_iOS.CallActionViewModelProtocol {
    get
  }
  public var speakerActionVM: Dialog_iOS.CallOptionallyTogglableActionViewModelProtocol {
    get
  }
  public var addActionVM: Dialog_iOS.CallActionViewModelProtocol {
    get
  }
  public var declineActionVM: Dialog_iOS.CallActionViewModelProtocol {
    get
  }
  public var chatActionVM: Dialog_iOS.CallActionViewModelProtocol {
    get
  }
  final public let videoViewTap: RxSwift.AnyObserver<Swift.Void>
  final public let shouldShowCallPanel: RxCocoa.Driver<Swift.Bool>
  final public let state: RxCocoa.Driver<Dialog_iOS.ActiveCallState>
  final public let localVideoAspectRatio: RxSwift.Observable<CoreGraphics.CGFloat>
  final public let didTapDismiss: RxSwift.AnyObserver<Swift.Void>
  final public let remoteVideoTrackObservable: RxSwift.Observable<WebRTC.RTCVideoTrack?>
  final public let isRemoteVideoEnabled: RxSwift.Observable<Swift.Bool>
  final public let isLocalVideoEnabled: RxSwift.Observable<Swift.Bool>
  final public let isRemoteVideoPacketsReceiving: RxSwift.Observable<DialogCalls.MediaPacketsReceivingState>
  final public let localVideoObservable: RxSwift.Observable<DialogCalls.LocalVideo?>
  final public let changeCameraTap: RxSwift.AnyObserver<Swift.Void>
  final public let callFinished: RxSwift.Observable<DialogCalls.CallDisposeReason>
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class P2PCallViewModel : Dialog_iOS.ActiveCallViewModel {
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class AVCCallViewModel : Dialog_iOS.ActiveCallViewModel {
  @objc deinit
}
public enum DeletableAccess {
  case deletable, undeletable
  public static func == (a: Dialog_iOS.DeletableAccess, b: Dialog_iOS.DeletableAccess) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol ActiveSessionCellViewModelParentProtocol : AnyObject {
  var deletableAccess: Dialog_iOS.DeletableAccess { get }
}
@_hasMissingDesignatedInitializers public class ActiveSessionCellViewModel {
  public var deletableAccess: Dialog_iOS.DeletableAccess
  final public let deactivating: RxRelay.BehaviorRelay<Swift.Bool>
  @objc deinit
}
@_inheritsConvenienceInitializers final public class ActiveSessionsScene : Dialog_iOS.Scene<Swift.Void, UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.ActiveSessionsScene.Builder
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<Swift.Void, UIKit.UIViewController, Dialog_iOS.ActiveSessionViewModelProtocol> {
    override final public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>) -> Dialog_iOS.ActiveSessionViewModelProtocol
    override final public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>, viewModel: Dialog_iOS.ActiveSessionViewModelProtocol) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<Swift.Void, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
@objc @_hasMissingDesignatedInitializers final public class ActiveSessionViewController : UIKit.UIViewController {
  public typealias VM = Dialog_iOS.ActiveSessionViewModelProtocol
  public init(viewModel vm: Dialog_iOS.ActiveSessionViewModelProtocol)
  @objc override final public func viewDidLoad()
  @objc override final public func viewDidLayoutSubviews()
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc deinit
}
public protocol ActiveSessionViewModelProtocol {
  var listOfActiveSessions: RxSwift.Observable<[DialogSDK_GRPC.Dialog_AuthSession]> { get }
  var localActiveSession: RxSwift.Observable<DialogAuth.AuthSession> { get }
  var sections: RxSwift.Observable<[Dialog_iOS.ActiveSessionsSection]> { get }
  var deactivateSpecificSession: RxSwift.AnyObserver<Dialog_iOS.ActiveSessionCellViewModelParentProtocol> { get }
  var deactivateAllSessions: RxSwift.AnyObserver<Swift.Void> { get }
  var isDeactivatingAllSessions: RxCocoa.Driver<Swift.Bool> { get }
}
public class ActiveSessionViewModel : Dialog_iOS.ActiveSessionViewModelProtocol {
  final public let sections: RxSwift.Observable<[Dialog_iOS.ActiveSessionsSection]>
  final public let listOfActiveSessions: RxSwift.Observable<[DialogSDK_GRPC.Dialog_AuthSession]>
  final public let localActiveSession: RxSwift.Observable<DialogAuth.AuthSession>
  final public let isDeactivatingAllSessions: RxCocoa.Driver<Swift.Bool>
  final public let deactivateAllSessions: RxSwift.AnyObserver<Swift.Void>
  final public let deactivateSpecificSession: RxSwift.AnyObserver<Dialog_iOS.ActiveSessionCellViewModelParentProtocol>
  public init(activeSessionsServie sessionService: DialogMessaging.DialogActiveSessionsServiceProtocol)
  @objc deinit
}
public struct ActiveSessionsSection {
  public var items: [Dialog_iOS.ActiveSessionsSection.Item]
}
extension ActiveSessionsSection : Differentiator.SectionModelType {
  public typealias Item = Dialog_iOS.ActiveSessionCellViewModelParentProtocol
  public init(original: Dialog_iOS.ActiveSessionsSection, items: [Dialog_iOS.ActiveSessionCellViewModelParentProtocol])
}
@_hasMissingDesignatedInitializers final public class ActiveUserDependentServicesAssembler : Swinject.Assembly {
  final public func assemble(container: Swinject.Container)
  @objc deinit
}
public protocol ActiveUsersServiceRegistrarProtocol {
  var registerActive: RxSwift.AnyObserver<DialogProtocols.AuthUserEntry> { get }
  var unregisterActive: RxSwift.AnyObserver<DialogProtocols.AuthUserEntry> { get }
}
public protocol ActiveUsersProviderServiceProtocol : AnyObject {
  var activeUsers: RxSwift.Observable<[DialogProtocols.AuthUserEntry]> { get }
}
extension ActiveUsersProviderServiceProtocol {
  public var firstActiveUser: RxSwift.Observable<DialogProtocols.AuthUserEntry?> {
    get
  }
}
public protocol ActiveUsersServiceProtocol : Dialog_iOS.ActiveUsersProviderServiceProtocol, Dialog_iOS.ActiveUsersServiceRegistrarProtocol, Dialog_iOS.DisposeBagable {
}
final public class ActiveUsersService : Dialog_iOS.ActiveUsersServiceProtocol {
  final public let registerActive: RxSwift.AnyObserver<DialogProtocols.AuthUserEntry>
  final public let unregisterActive: RxSwift.AnyObserver<DialogProtocols.AuthUserEntry>
  final public let activeUsers: RxSwift.Observable<[DialogProtocols.AuthUserEntry]>
  final public let disposeBag: RxSwift.DisposeBag
  public init(container: Swinject.Container)
  @objc deinit
}
public protocol ActivityIndicatorNodeStyleProtocol {
  var color: UIKit.UIColor { get }
  var style: UIKit.UIActivityIndicatorView.Style { get }
}
public struct ActivityIndicatorNodeDefaultStyle : Dialog_iOS.ActivityIndicatorNodeStyleProtocol {
  public let color: UIKit.UIColor
  public let style: UIKit.UIActivityIndicatorView.Style
}
@objc @_inheritsConvenienceInitializers public class ActivityIndicatorNode : AsyncDisplayKit.ASDisplayNode {
  public var isIndicatorHidden: Swift.Bool {
    get
    set(value)
  }
  convenience public init(style: Dialog_iOS.ActivityIndicatorNodeStyleProtocol)
  @objc deinit
  @objc override dynamic public init()
}
extension Reactive where Base : Dialog_iOS.ActivityIndicatorNode {
  public var isIndicatorHidden: RxCocoa.Binder<Swift.Bool> {
    get
  }
}
@objc @_inheritsConvenienceInitializers open class AnimatedCollectionViewLayout : UIKit.UICollectionViewFlowLayout {
  open var animator: Dialog_iOS.LayoutAttributesAnimator?
  @objc override dynamic open class var layoutAttributesClass: Swift.AnyClass {
    @objc get
  }
  @objc override dynamic open func layoutAttributesForElements(in rect: CoreGraphics.CGRect) -> [UIKit.UICollectionViewLayoutAttributes]?
  @objc override dynamic open func shouldInvalidateLayout(forBoundsChange newBounds: CoreGraphics.CGRect) -> Swift.Bool
  @objc override dynamic open func prepare(forAnimatedBoundsChange oldBounds: CoreGraphics.CGRect)
  @objc override dynamic open func targetContentOffset(forProposedContentOffset proposedContentOffset: CoreGraphics.CGPoint) -> CoreGraphics.CGPoint
  @objc override dynamic open func finalizeAnimatedBoundsChange()
  @objc deinit
  @objc override dynamic public init()
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
@objc @_inheritsConvenienceInitializers open class AnimatedCollectionViewLayoutAttributes : UIKit.UICollectionViewLayoutAttributes {
  public var contentView: UIKit.UIView?
  public var scrollDirection: UIKit.UICollectionView.ScrollDirection
  public var startOffset: CoreGraphics.CGFloat
  public var middleOffset: CoreGraphics.CGFloat
  public var endOffset: CoreGraphics.CGFloat
  @objc override dynamic open func copy(with zone: ObjectiveC.NSZone? = nil) -> Any
  @objc override dynamic open func isEqual(_ object: Any?) -> Swift.Bool
  @objc deinit
  @objc override dynamic public init()
}
extension AnyObserver {
  public static func create(elementOnlyHandler: @escaping (Element) -> Swift.Void) -> RxSwift.AnyObserver<Element>
  public init(weakBindTo relay: RxRelay.BehaviorRelay<Element>)
  public init(weakBindTo relay: RxRelay.BehaviorRelay<Element?>)
  public static func empty() -> RxSwift.AnyObserver<Element>
}
extension BehaviorRelay {
  final public func asObserver() -> RxSwift.AnyObserver<Element>
}
public enum AppAuthState : Swift.Equatable, Swift.CustomDebugStringConvertible {
  case undefined
  case auth
  case goingToAuthorize(DialogProtocols.DialogUserId)
  case userAuthorized(DialogProtocols.AuthUserEntry)
  public var user: DialogProtocols.AuthUserEntry? {
    get
  }
  public var isUserAuthorized: Swift.Bool {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public static func == (a: Dialog_iOS.AppAuthState, b: Dialog_iOS.AppAuthState) -> Swift.Bool
}
public protocol AppAuthStateServiceProtocol {
  var state: RxCocoa.Driver<Dialog_iOS.AppAuthState> { get }
}
public protocol AppAuthStateInputServiceProtocol {
  var stateInput: RxSwift.AnyObserver<Dialog_iOS.AppAuthState> { get }
}
public enum AppStartAuthedUserResolve {
  case resolved(DialogProtocols.AuthUserEntry)
  case noAuth
}
extension AppAuthStateServiceProtocol {
  public func doWithAuthedUser() -> RxSwift.Single<Dialog_iOS.AppStartAuthedUserResolve>
}
extension AppAuthStateServiceProtocol {
  public func doWithAuthedUserIgnoringOtherCases() -> RxSwift.Maybe<DialogProtocols.AuthUserEntry>
}
final public class AppAuthStateService : Dialog_iOS.AppAuthStateServiceProtocol, Dialog_iOS.AppAuthStateInputServiceProtocol {
  final public var state: RxCocoa.Driver<Dialog_iOS.AppAuthState> {
    get
    set
  }
  final public var stateInput: RxSwift.AnyObserver<Dialog_iOS.AppAuthState> {
    get
    set
  }
  public init()
  @objc deinit
}
public protocol AppCallKitProviderProtocol {
  var provider: CallKit.CXProvider { get }
}
final public class AppCallKitProvider : Dialog_iOS.AppCallKitProviderProtocol {
  final public var provider: CallKit.CXProvider
  public init(provider: CallKit.CXProvider)
  convenience public init(appName: Swift.String? = Bundle.main.appName)
  @objc deinit
}
public typealias AppStrongRouter = XCoordinator.StrongRouter<Dialog_iOS.AppRoute>
public typealias AppWeakRouter = XCoordinator.WeakRouter<Dialog_iOS.AppRoute>
public typealias AppRouter = Dialog_iOS.AppStrongRouter
public protocol UserSpecifiedRouterProtocol : AnyObject {
  var router: Dialog_iOS.AppRouter { get }
  var user: DialogProtocols.AuthUserEntry { get }
  func go(to route: Dialog_iOS.GlobalAppRoute.AuthedUser.Route)
}
public class UserSpecifiedRouter : Dialog_iOS.UserSpecifiedRouterProtocol {
  public var router: Dialog_iOS.AppRouter {
    get
  }
  final public let user: DialogProtocols.AuthUserEntry
  public init(service: Dialog_iOS.AppRouterServiceProtocol, user: DialogProtocols.AuthUserEntry)
  public func go(to route: Dialog_iOS.GlobalAppRoute.AuthedUser.Route)
  @objc deinit
}
public protocol AppRouterServiceProtocol {
  var router: Dialog_iOS.AppRouter { get }
}
final public class LazyAppRouterService : Dialog_iOS.AppRouterServiceProtocol {
  public typealias Resolving = () -> Dialog_iOS.AppRouter
  public init(resolving: @escaping Dialog_iOS.LazyAppRouterService.Resolving)
  final public var router: Dialog_iOS.AppRouter {
    get
  }
  @objc deinit
}
public typealias AnyAppCoordinator = Dialog_iOS.AppCoordinator.AnyCoordinatorType
public enum GlobalAppRoute {
  case user(Dialog_iOS.GlobalAppRoute.AuthedUser)
  public struct AuthedUser {
    public var entry: DialogProtocols.AuthUserEntry
    public var route: Dialog_iOS.GlobalAppRoute.AuthedUser.Route
    public enum Route {
      case dialogsRoute(Dialog_iOS.DialogsRoute)
      case logout
    }
    public init(entry: DialogProtocols.AuthUserEntry, route: Dialog_iOS.GlobalAppRoute.AuthedUser.Route)
  }
}
public enum AppRoute : XCoordinator.Route {
  case authType
  case homeWithEntry(DialogProtocols.AuthUserEntry)
  case home(DialogProtocols.AuthUserEntry)
  case logout(DialogProtocols.AuthUserEntry)
  case onboardingLogout(DialogProtocols.AuthUserEntry)
  case feedback
  case present(UIKit.UIViewController)
  case dismiss
  case presentInfoMessageAndDismiss
  case webView(Foundation.URL)
  case global(Dialog_iOS.GlobalAppRoute)
}
extension UIApplication {
  public var appWindow: UIKit.UIWindow? {
    get
  }
}
open class AppCoordinator : XCoordinator.ViewCoordinator<Dialog_iOS.AppRoute> {
  public init(container: Swinject.Container, rootViewController: UIKit.UIViewController)
  override open func prepareTransition(for route: Dialog_iOS.AppRoute) -> XCoordinator.ViewTransition
  @objc deinit
  override public init(rootViewController: XCoordinator.ViewCoordinator<Dialog_iOS.AppRoute>.RootViewController, initialRoute: Dialog_iOS.AppRoute? = super)
}
public protocol AppearanceCellViewModelProtocol {
}
public enum AppFlowState : Swift.String {
  case idle
  case authByCertificate
  case authByLoginWaitsLogin
  case authByLoginWaitsPassword
  case authByPhoneWaitsPhone
  case authByPhoneWaitsCode
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public protocol ApplicationProtectedDataAvailabilityServiceProtocol : Dialog_iOS.ProtectedDataIndependentServiceProtocol {
  var applicationProtectedDataAvailable: RxSwift.Observable<Swift.Bool> { get }
}
extension ApplicationProtectedDataAvailabilityServiceProtocol {
  public var applicationProtectedDataBecomeAvailableFirstTime: RxSwift.Completable {
    get
  }
}
final public class ApplicationProtectedDataAvailabilityService : Dialog_iOS.ApplicationProtectedDataAvailabilityServiceProtocol {
  final public let applicationProtectedDataAvailable: RxSwift.Observable<Swift.Bool>
  public init(application: UIKit.UIApplication = .shared, center: Foundation.NotificationCenter = .default)
  @objc deinit
}
public protocol AppNotificationSettingsServiceProtocol {
  var settings: RxSwift.Observable<UserNotifications.UNNotificationSettings> { get }
}
final public class AppNotificationSettingsService : Dialog_iOS.AppNotificationSettingsServiceProtocol {
  public static func defaultCheckTrigger(notificationCenter: Foundation.NotificationCenter = .default) -> RxSwift.Observable<Swift.Void>
  final public var settings: RxSwift.Observable<UserNotifications.UNNotificationSettings>
  public init(center: UserNotifications.UNUserNotificationCenter = .current(), checkTrigger: RxSwift.Observable<Swift.Void> = defaultCheckTrigger())
  @objc deinit
}
public struct AppRootControllerHolder {
  public let rootViewController: UIKit.UIViewController
  public init(rootViewController: UIKit.UIViewController)
}
final public class ApprovalCodeRequestTimeoutService {
  public enum State {
    case idle
    case loading
    case timeout
    public static func == (a: Dialog_iOS.ApprovalCodeRequestTimeoutService.State, b: Dialog_iOS.ApprovalCodeRequestTimeoutService.State) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  final public let state: RxCocoa.Driver<Dialog_iOS.ApprovalCodeRequestTimeoutService.State>
  final public let secondsLeft: RxCocoa.Driver<Swift.Int>
  final public var requestLoading: RxSwift.AnyObserver<Swift.Void> {
    get
  }
  final public var requestBeginTimeout: RxSwift.AnyObserver<Swift.Int> {
    get
  }
  final public var requestReset: RxSwift.AnyObserver<Swift.Void> {
    get
  }
  public init()
  final public func secondsLeftString(formatter: Foundation.DateComponentsFormatter) -> RxCocoa.Driver<Swift.String?>
  @objc deinit
}
public typealias Theme = DialogSharedComponents.Theme
public typealias Subtheme = DialogSharedComponents.Subtheme
public typealias DomainSpecificKey = DialogSharedComponents.DomainSpecificKey
public typealias ThemeAttributeValue = DialogSharedComponents.ThemeAttributeValue
public typealias AppThemeService = DialogSharedComponents.AppThemeService
public typealias BasicAppTheme = DialogSharedComponents.BasicAppTheme
public typealias AppThemeProvider = DialogSharedComponents.AppThemeProvider
extension BasicAppTheme {
  public static let appTheme: DialogSharedComponents.BasicAppTheme
}
extension ThemeService where Provider == DialogSharedComponents.AppThemeProvider {
  public func generalControlColor() -> RxSwift.Observable<UIKit.UIColor?>
  public var generalButtonCornerRadius: RxSwift.Observable<Dialog_iOS.CornerRadiusType?> {
    get
  }
}
final public class AppVersionCheckServiceAppStore : Dialog_iOS.AppVersionCheckServiceProtocol {
  public init(bundleIdentifier: Swift.String, currentVersion: Swift.String)
  final public func checkVersion() -> RxSwift.Single<Dialog_iOS.CheckVersionResult>
  @objc deinit
}
final public class AppVersionCheckServiceEnterprise : Dialog_iOS.AppVersionCheckServiceProtocol {
  public init(distributionLink: Swift.String, currentVersion: Swift.String)
  final public func checkVersion() -> RxSwift.Single<Dialog_iOS.CheckVersionResult>
  @objc deinit
}
public enum CheckVersionResult {
  case upToDate
  case update(latestVersion: Swift.String, updateLink: Swift.String)
}
public enum CheckVersionError : Swift.Error {
  case invalidDistributionLink
  case invalidBundleIdentifier
  case decodingFailed
  case emptyData
  public static func == (a: Dialog_iOS.CheckVersionError, b: Dialog_iOS.CheckVersionError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol AppVersionCheckServiceProtocol {
  func checkVersion() -> RxSwift.Single<Dialog_iOS.CheckVersionResult>
  func checkVersionRoutinely(interval: Dispatch.DispatchTimeInterval, ignoreErrorsPredicate: @escaping (Swift.Error) -> Swift.Bool) -> RxSwift.Observable<Dialog_iOS.CheckVersionResult>
  func subscribeToVersionCheck(checkInterval: Foundation.TimeInterval, disposeBy: RxSwift.DisposeBag)
}
extension AppVersionCheckServiceProtocol {
  public func checkVersionRoutinely(interval: Dispatch.DispatchTimeInterval, ignoreErrorsPredicate: @escaping (Swift.Error) -> Swift.Bool) -> RxSwift.Observable<Dialog_iOS.CheckVersionResult>
}
extension AppVersionCheckServiceProtocol {
  public func subscribeToVersionCheck(checkInterval: Foundation.TimeInterval = 0, disposeBy disposeBag: RxSwift.DisposeBag)
}
extension Collection {
  public subscript(safe index: Self.Index) -> Self.Element? {
    get
  }
}
extension Array {
  public func appending<S>(contentsOf sequence: S) -> Swift.Array<Element> where Element == S.Element, S : Swift.Sequence
}
extension Array where Element : Differentiator.SectionModelType {
  public var firstIndexPath: Foundation.IndexPath {
    get
  }
  public var lastIndexPath: Foundation.IndexPath {
    get
  }
}
extension Array where Element : Swift.Hashable {
  public func difference(from other: [Element]) -> [Element]
}
extension Reactive where Base : AsyncDisplayKit.ASCollectionNode {
  public var itemsInserted: RxCocoa.ControlEvent<[Foundation.IndexPath]> {
    get
  }
  public func onItemsInserted() -> RxSwift.Observable<[Foundation.IndexPath]>
  public var reloadData: RxCocoa.ControlEvent<Swift.Void> {
    get
  }
  public var reloadDataWithCompletion: RxCocoa.ControlEvent<Swift.Void> {
    get
  }
  public func onReloadData() -> RxSwift.Observable<Swift.Void>
  public func onReloadDataWithCompletion() -> RxSwift.Observable<Swift.Void>
  public var viewDidScroll: RxCocoa.ControlEvent<Swift.Void> {
    get
  }
  public func onViewDidScroll() -> RxSwift.Observable<Swift.Void>
  public var viewDidEndDecelerating: RxCocoa.ControlEvent<Swift.Void> {
    get
  }
  public func onViewDidEndDecelerating() -> RxSwift.Observable<Swift.Void>
  public var scrollViewDidEndScrollingAnimation: RxCocoa.ControlEvent<Swift.Void> {
    get
  }
  public func onScrollViewDidEndScrollingAnimation() -> RxSwift.Observable<Swift.Void>
}
extension Reactive where Base : AsyncDisplayKit.ASImageNode {
  public var image: RxCocoa.Binder<UIKit.UIImage?> {
    get
  }
  public var tintColor: RxCocoa.Binder<UIKit.UIColor> {
    get
  }
}
extension ASLayoutElement {
  @discardableResult
  public func noGrow() -> AsyncDisplayKit.ASLayoutElement
  @discardableResult
  public func fullGrow() -> AsyncDisplayKit.ASLayoutElement
  @discardableResult
  public func growWith(_ grow: CoreGraphics.CGFloat) -> AsyncDisplayKit.ASLayoutElement
  @discardableResult
  public func noShrink() -> AsyncDisplayKit.ASLayoutElement
  @discardableResult
  public func fullShrink() -> AsyncDisplayKit.ASLayoutElement
  @discardableResult
  public func shrinkWith(_ shrink: CoreGraphics.CGFloat) -> AsyncDisplayKit.ASLayoutElement
  @discardableResult
  public func setFlexBasis(points: CoreGraphics.CGFloat) -> AsyncDisplayKit.ASLayoutElement
  @discardableResult
  public func setFlexBasis(fraction: CoreGraphics.CGFloat) -> AsyncDisplayKit.ASLayoutElement
  @discardableResult
  public func setWidth(points: CoreGraphics.CGFloat) -> AsyncDisplayKit.ASLayoutElement
  @discardableResult
  public func setWidth(fraction: CoreGraphics.CGFloat) -> AsyncDisplayKit.ASLayoutElement
  @discardableResult
  public func setPrefSize(_ size: CoreGraphics.CGSize) -> AsyncDisplayKit.ASLayoutElement
  @discardableResult
  public func setPrefLayoutSize(_ size: AsyncDisplayKit.ASLayoutSize) -> AsyncDisplayKit.ASLayoutElement
}
public enum AssetsServiceCroppingType {
  case original
  case square
  public static func == (a: Dialog_iOS.AssetsServiceCroppingType, b: Dialog_iOS.AssetsServiceCroppingType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol AssetsServiceProtocol {
  func convertToContent(content: Dialog_iOS.TypeAssetToMessages) -> RxSwift.Observable<DialogMessaging.DialogDocumentMessageContent>
  func convertJustMadePhoto(image: UIKit.UIImage, asFile: Swift.Bool) -> RxSwift.Observable<DialogMessaging.DialogDocumentMessageContent>
  func convertJustMadeVideo(fromURL url: Foundation.URL, asFile: Swift.Bool) -> RxSwift.Observable<DialogMessaging.DialogDocumentMessageContent>
  func convertPickedAsset(_ asset: Photos.PHAsset, cropType: Dialog_iOS.AssetsServiceCroppingType, asFile: Swift.Bool) -> RxSwift.Observable<DialogMessaging.DialogDocumentMessageContent>
}
public enum TypeAssetToMessages {
  case storedMediaContent([Photos.PHAsset])
  case mediaAsDocument([Photos.PHAsset])
  case unstoredPhoto(UIKit.UIImage)
  case unstoredVideo(Foundation.URL)
  case filesFromStorage([Foundation.URL])
  case audio(Foundation.URL, Foundation.TimeInterval)
}
@_hasMissingDesignatedInitializers public class AssetsService : Dialog_iOS.AssetsServiceProtocol {
  public func convertToContent(content: Dialog_iOS.TypeAssetToMessages) -> RxSwift.Observable<DialogMessaging.DialogDocumentMessageContent>
  public func convertJustMadePhoto(image: UIKit.UIImage, asFile: Swift.Bool = true) -> RxSwift.Observable<DialogMessaging.DialogDocumentMessageContent>
  public func convertJustMadeVideo(fromURL url: Foundation.URL, asFile: Swift.Bool) -> RxSwift.Observable<DialogMessaging.DialogDocumentMessageContent>
  public func convertPickedAsset(_ asset: Photos.PHAsset, cropType: Dialog_iOS.AssetsServiceCroppingType, asFile: Swift.Bool) -> RxSwift.Observable<DialogMessaging.DialogDocumentMessageContent>
  @objc deinit
}
extension ASSizeRange : Swift.Equatable {
}
public func == (lhs: AsyncDisplayKit.ASSizeRange, rhs: AsyncDisplayKit.ASSizeRange) -> Swift.Bool
extension ASSizeRange : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Reactive where Base : AsyncDisplayKit.ASTableNode {
  public var itemsInserted: RxCocoa.ControlEvent<[Foundation.IndexPath]> {
    get
  }
  public func onItemsInserted() -> RxSwift.Observable<[Foundation.IndexPath]>
  public var viewDidScroll: RxCocoa.ControlEvent<Swift.Void> {
    get
  }
  public func onViewDidScroll() -> RxSwift.Observable<Swift.Void>
  public var scrollViewWillBeginDragging: RxCocoa.ControlEvent<Swift.Void> {
    get
  }
  public var viewDidEndDecelerating: RxCocoa.ControlEvent<Swift.Void> {
    get
  }
  public func onViewDidEndDecelerating() -> RxSwift.Observable<Swift.Void>
  public var scrollViewDidEndScrollingAnimation: RxCocoa.ControlEvent<Swift.Void> {
    get
  }
  public func onScrollViewDidEndScrollingAnimation() -> RxSwift.Observable<Swift.Void>
}
extension Reactive where Base : AsyncDisplayKit.ASVideoNode {
  public var assetUrl: RxCocoa.Binder<Foundation.URL?> {
    get
  }
  public var asset: RxCocoa.Binder<AVFoundation.AVAsset?> {
    get
  }
  public var shouldAutoplay: RxCocoa.Binder<Swift.Bool> {
    get
  }
  public var shouldAutorepeat: RxCocoa.Binder<Swift.Bool> {
    get
  }
  public var muted: RxCocoa.Binder<Swift.Bool> {
    get
  }
}
public struct AttachmentSceneStyle {
}
extension Theme.Domain {
  public static let sharedFilesScene: Dialog_iOS.Theme.Domain
  public static let sharedMediaCellStyle: Dialog_iOS.Theme.Domain
  public static let sharedDocumentCellStyle: Dialog_iOS.Theme.Domain
  public static let sharedFilesEmptyViewStyle: Dialog_iOS.Theme.Domain
}
extension Theme.Keys.SharedFilesScene {
  public static let navigationViewHeight: Dialog_iOS.Theme.Keys.SharedFilesScene
  public static let searchBarHeight: Dialog_iOS.Theme.Keys.SharedFilesScene
  public static let separatorHeight: Dialog_iOS.Theme.Keys.SharedFilesScene
  public static let sectionHeaderHeight: Dialog_iOS.Theme.Keys.SharedFilesScene
  public static let mainBackgroundColor: Dialog_iOS.Theme.Keys.SharedFilesScene
  public static let separatorColor: Dialog_iOS.Theme.Keys.SharedFilesScene
  public static let numberOfItemsInLine: Dialog_iOS.Theme.Keys.SharedFilesScene
}
extension Theme.Defaults {
  public static let sharedFilesScene: DialogSharedComponents.Subtheme<Dialog_iOS.Theme.Keys.SharedFilesScene>
}
extension Theme.Keys {
  public struct SharedFilesScene : Dialog_iOS.DomainSpecificKey, Swift.RawRepresentable {
    public static var domain: Dialog_iOS.Theme.Domain
    public var domainInternalId: Swift.String {
      get
    }
    public let rawValue: Swift.String
    public init(rawValue: Swift.String)
    public typealias RawValue = Swift.String
  }
}
extension Theme.Defaults {
  public static let sharedMediaCellStyle: DialogSharedComponents.Subtheme<Dialog_iOS.Theme.Keys.SharedFilesScene.SharedMediaCellStyle>
}
extension Theme.Keys.SharedFilesScene.SharedMediaCellStyle {
  public static let imageCornerRadius: Dialog_iOS.Theme.Keys.SharedFilesScene.SharedMediaCellStyle
  public static let detailsFontColor: Dialog_iOS.Theme.Keys.SharedFilesScene.SharedMediaCellStyle
  public static let thumbImageSize: Dialog_iOS.Theme.Keys.SharedFilesScene.SharedMediaCellStyle
  public static let thumbImageInsets: Dialog_iOS.Theme.Keys.SharedFilesScene.SharedMediaCellStyle
  public static let titlelabelInsets: Dialog_iOS.Theme.Keys.SharedFilesScene.SharedMediaCellStyle
  public static let detailsLabelInsets: Dialog_iOS.Theme.Keys.SharedFilesScene.SharedMediaCellStyle
  public static let titleLabelHeight: Dialog_iOS.Theme.Keys.SharedFilesScene.SharedMediaCellStyle
  public static let detailsLabelHeight: Dialog_iOS.Theme.Keys.SharedFilesScene.SharedMediaCellStyle
  public static let titleLabelFontSize: Dialog_iOS.Theme.Keys.SharedFilesScene.SharedMediaCellStyle
  public static let detailsLabelFontSize: Dialog_iOS.Theme.Keys.SharedFilesScene.SharedMediaCellStyle
}
extension Theme.Keys.SharedFilesScene {
  public struct SharedMediaCellStyle : Dialog_iOS.DomainSpecificKey, Swift.RawRepresentable {
    public static var domain: Dialog_iOS.Theme.Domain
    public var domainInternalId: Swift.String {
      get
    }
    public let rawValue: Swift.String
    public init(rawValue: Swift.String)
    public typealias RawValue = Swift.String
  }
}
extension Theme.Defaults {
  public static let sharedMediaEmptyViewStyle: DialogSharedComponents.Subtheme<Dialog_iOS.Theme.Keys.SharedFilesScene.SharedMediaEmptyViewStyle>
}
extension Theme.Keys.SharedFilesScene.SharedMediaEmptyViewStyle {
  public static let titleFont: Dialog_iOS.Theme.Keys.SharedFilesScene.SharedMediaEmptyViewStyle
  public static let titleColor: Dialog_iOS.Theme.Keys.SharedFilesScene.SharedMediaEmptyViewStyle
  public static let descriptionFont: Dialog_iOS.Theme.Keys.SharedFilesScene.SharedMediaEmptyViewStyle
  public static let descriptionColor: Dialog_iOS.Theme.Keys.SharedFilesScene.SharedMediaEmptyViewStyle
  public static let connectionErrorImage: Dialog_iOS.Theme.Keys.SharedFilesScene.SharedMediaEmptyViewStyle
  public static let emptyStateImage: Dialog_iOS.Theme.Keys.SharedFilesScene.SharedMediaEmptyViewStyle
}
extension Theme.Keys.SharedFilesScene {
  public struct SharedMediaEmptyViewStyle : Dialog_iOS.DomainSpecificKey, Swift.RawRepresentable {
    public static var domain: Dialog_iOS.Theme.Domain
    public var domainInternalId: Swift.String {
      get
    }
    public let rawValue: Swift.String
    public init(rawValue: Swift.String)
    public typealias RawValue = Swift.String
  }
}
public struct AttachmentsCollectionViewSection {
  public var items: [Dialog_iOS.AttachmentsCollectionViewSection.Item]
  public var category: Dialog_iOS.AttachmentCategory
}
extension AttachmentsCollectionViewSection : Differentiator.SectionModelType, Differentiator.AnimatableSectionModelType {
  public typealias Identity = Swift.String
  public var identity: Swift.String {
    get
  }
  public init(original: Dialog_iOS.AttachmentsCollectionViewSection, items: [Dialog_iOS.AttachmentsCollectionViewSection.Item])
  public init(original: Dialog_iOS.AttachmentsCollectionViewSection, items: [Dialog_iOS.AttachmentsCollectionViewSection.Item], category: Dialog_iOS.AttachmentCategory)
  public typealias Item = Dialog_iOS.AnyMessageCellViewModel
}
public struct AttachmentsCollectionViewCategorySection {
  public var category: Dialog_iOS.AttachmentCategory
  public var items: [Dialog_iOS.AttachmentsCollectionViewCategorySection.Item]
}
extension AttachmentsCollectionViewCategorySection : Differentiator.SectionModelType, Differentiator.AnimatableSectionModelType, Swift.Equatable {
  public typealias Identity = Swift.String
  public var identity: Swift.String {
    get
  }
  public static func == (lhs: Dialog_iOS.AttachmentsCollectionViewCategorySection, rhs: Dialog_iOS.AttachmentsCollectionViewCategorySection) -> Swift.Bool
  public init(original: Dialog_iOS.AttachmentsCollectionViewCategorySection, items: [Dialog_iOS.AttachmentsCollectionViewCategorySection.Item])
  public init(original: Dialog_iOS.AttachmentsCollectionViewCategorySection, items: [Dialog_iOS.AttachmentsCollectionViewCategorySection.Item], category: Dialog_iOS.AttachmentCategory)
  public typealias Item = Dialog_iOS.AttachmentsCollectionViewCategoryViewModel
}
public struct AttachmentsCollectionViewCategoryViewModel : Differentiator.IdentifiableType, Swift.Equatable {
  public typealias Identity = Swift.String
  public var identity: Swift.String {
    get
  }
  public static func == (lhs: Dialog_iOS.AttachmentsCollectionViewCategoryViewModel, rhs: Dialog_iOS.AttachmentsCollectionViewCategoryViewModel) -> Swift.Bool
}
@_inheritsConvenienceInitializers final public class AttachmentsScene : Dialog_iOS.Scene<Dialog_iOS.ConversationPeer, UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.AttachmentsScene.Builder
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<Dialog_iOS.ConversationPeer, UIKit.UIViewController, Dialog_iOS.AttachmentsViewModelProtocol> {
    override final public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Dialog_iOS.AttachmentsScene.DefaultBuilder.MainArgument>) -> Dialog_iOS.AttachmentsViewModelProtocol
    override final public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Dialog_iOS.ConversationPeer>, viewModel: Dialog_iOS.AttachmentsViewModelProtocol) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<Dialog_iOS.ConversationPeer, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
@objc @_hasMissingDesignatedInitializers public class AttachmentsViewController : UIKit.UIViewController {
  @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @objc override dynamic public func viewWillDisappear(_ animated: Swift.Bool)
  @objc override dynamic public func viewDidLoad()
  @objc override dynamic public func viewWillLayoutSubviews()
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc deinit
}
extension AttachmentsViewController : UIKit.UICollectionViewDelegateFlowLayout {
  @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, layout collectionViewLayout: UIKit.UICollectionViewLayout, sizeForItemAt indexPath: Foundation.IndexPath) -> CoreGraphics.CGSize
  @objc dynamic public func scrollViewWillEndDragging(_ scrollView: UIKit.UIScrollView, withVelocity velocity: CoreGraphics.CGPoint, targetContentOffset: Swift.UnsafeMutablePointer<CoreGraphics.CGPoint>)
  @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, willDisplay cell: UIKit.UICollectionViewCell, forItemAt indexPath: Foundation.IndexPath)
}
extension AttachmentsViewController : UIKit.UINavigationBarDelegate {
  @objc dynamic public func position(for bar: UIKit.UIBarPositioning) -> UIKit.UIBarPosition
}
extension AttachmentsViewController : UIKit.UITextFieldDelegate {
  @objc dynamic public func textFieldShouldReturn(_ textField: UIKit.UITextField) -> Swift.Bool
}
extension AttachmentsViewController : UIKit.UIGestureRecognizerDelegate {
  @objc dynamic public func gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
  @objc dynamic public func gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldBeRequiredToFailBy otherGestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
  @objc dynamic public func gestureRecognizerShouldBegin(_ gestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
}
extension AttachmentsViewController : UIKit.UICollectionViewDelegate {
  @available(iOS 13.0, *)
  @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, contextMenuConfigurationForItemAt indexPath: Foundation.IndexPath, point: CoreGraphics.CGPoint) -> UIKit.UIContextMenuConfiguration?
  @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, canPerformAction action: ObjectiveC.Selector, forItemAt indexPath: Foundation.IndexPath, withSender sender: Any?) -> Swift.Bool
  @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, shouldShowMenuForItemAt indexPath: Foundation.IndexPath) -> Swift.Bool
  @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, performAction action: ObjectiveC.Selector, forItemAt indexPath: Foundation.IndexPath, withSender sender: Any?)
}
extension AttachmentsViewController : Dialog_iOS.ConversationStandardEditActionResponder {
  @objc dynamic public func forwardMessage(_ sender: Any?)
  @objc dynamic public func replyToMessage(_ sender: Any?)
  @objc dynamic public func synthesizeMessage(_ sender: Any?)
  @objc dynamic public func copyMessageContent(_ sender: Any?)
  @objc dynamic public func selectMessage(_ sender: Any?)
  @objc dynamic public func resendMessage(_ sender: Any?)
  @objc dynamic public func deselectMessage(_ sender: Any?)
  @objc dynamic public func editMessage(_ sender: Any?)
  @objc dynamic public func deleteMessage(_ sender: Any?)
  @objc dynamic public func saveMessage(_ sender: Any?)
  @objc dynamic public func showInConversation(_ sender: Any?)
  @objc dynamic public func addReaction(_ sender: Any?)
  @objc dynamic public func stopSynthesizingCurrentMessage(_ sender: Any?)
}
extension AttachmentsViewController : UIKit.UISearchBarDelegate {
  @objc dynamic public func searchBarSearchButtonClicked(_ searchBar: UIKit.UISearchBar)
}
public enum AttachmentsViewControllerState {
  case exploring
  case error
  case empty
  case loading
  case selecting
  case searchingInitial
  case searchingEmptyResult
  case searchingWithResults
  case searchingConnectionError
  public static func == (a: Dialog_iOS.AttachmentsViewControllerState, b: Dialog_iOS.AttachmentsViewControllerState) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol AttachmentsViewModelProtocol : Dialog_iOS.MenuInteractorProtocol {
  var switchedToCategory: RxSwift.AnyObserver<Dialog_iOS.AttachmentCategory> { get }
  var exploreSections: RxCocoa.Driver<[Dialog_iOS.AttachmentsCollectionViewSection]> { get }
  var searchingSections: RxCocoa.Driver<[Dialog_iOS.AttachmentsCollectionViewSection]> { get }
  var categoriesSections: RxCocoa.Driver<[Dialog_iOS.AttachmentsCollectionViewCategorySection]> { get }
  var performLoading: RxSwift.AnyObserver<DialogProtocols.DialogMessagesRequestDirection> { get }
  var categories: RxCocoa.Driver<[Dialog_iOS.CategoryItem]> { get }
  var state: RxCocoa.Driver<Dialog_iOS.AttachmentsViewControllerState> { get }
  var searchText: RxSwift.AnyObserver<Swift.String?> { get }
  var setSearchText: RxCocoa.Driver<Swift.String?> { get }
  var searchTextIsEditing: RxSwift.AnyObserver<Swift.Bool> { get }
  var cancelButtonIsTapped: RxSwift.AnyObserver<Swift.Void> { get }
  var style: RxCocoa.Driver<Dialog_iOS.AttachmentSceneStyle> { get }
  var tintColor: RxCocoa.Driver<UIKit.UIColor?> { get }
  var stateViewModel: Dialog_iOS.DUIEmptyStateViewModelProtocol { get }
  @available(iOS 13.0, *)
  func contextMenuConfiguration(forCellViewModel: Dialog_iOS.MessageCellViewModel, handler: @escaping ((UIKit.UIAction) -> Swift.Void)) -> UIKit.UIContextMenuConfiguration?
  func setupMenu(forCellViewModel cellViewModel: Dialog_iOS.MessageCellViewModel) -> [UIKit.UIMenuItem]
}
public typealias SearchedItem = DialogProtocols.DialogMessage
@_hasMissingDesignatedInitializers public class AttachmentsViewModel : Dialog_iOS.AttachmentsViewModelProtocol {
  public var state: RxCocoa.Driver<Dialog_iOS.AttachmentsViewControllerState> {
    get
    set
  }
  final public let switchedToCategory: RxSwift.AnyObserver<Dialog_iOS.AttachmentCategory>
  final public let searchText: RxSwift.AnyObserver<Swift.String?>
  public var setSearchText: RxCocoa.Driver<Swift.String?>
  public var searchTextIsEditing: RxSwift.AnyObserver<Swift.Bool> {
    get
    set
  }
  public var cancelButtonIsTapped: RxSwift.AnyObserver<Swift.Void> {
    get
    set
  }
  public var performLoading: RxSwift.AnyObserver<DialogProtocols.DialogMessagesRequestDirection> {
    get
    set
  }
  final public let exploreSections: RxCocoa.Driver<[Dialog_iOS.AttachmentsCollectionViewSection]>
  final public let searchingSections: RxCocoa.Driver<[Dialog_iOS.AttachmentsCollectionViewSection]>
  public var categoriesSections: RxCocoa.Driver<[Dialog_iOS.AttachmentsCollectionViewCategorySection]>
  final public let categories: RxCocoa.Driver<[Dialog_iOS.CategoryItem]>
  final public let style: RxCocoa.Driver<Dialog_iOS.AttachmentSceneStyle>
  final public let tintColor: RxCocoa.Driver<UIKit.UIColor?>
  final public let permissions: Dialog_iOS.AttachmentsViewModel.Permissions
  public var stateViewModel: Dialog_iOS.DUIEmptyStateViewModelProtocol {
    get
    set
  }
  @objc deinit
}
extension AttachmentsViewModel : Dialog_iOS.MenuInteractorProtocol {
  @_hasMissingDesignatedInitializers public class Permissions {
    final public let canForward: RxSwift.BehaviorSubject<Swift.Bool>
    final public let canDelete: RxSwift.BehaviorSubject<Swift.Bool>
    final public let canReply: RxSwift.BehaviorSubject<Swift.Bool>
    @objc deinit
  }
  public func canPerformAction(_ action: ObjectiveC.Selector, item: Dialog_iOS.MessageCellViewModel.Content, messageStatus: DialogProtocols.DialogMyMessageStatusType?, fileError: DialogProtocols.DialogFileError?) -> Swift.Bool
  public func handleEvent(_ event: Dialog_iOS.MenuActionEvent, item: Dialog_iOS.MessageCellViewModel.Content) throws
}
extension AttachmentsViewModel {
  public func setupMenu(forCellViewModel cellViewModel: Dialog_iOS.MessageCellViewModel) -> [UIKit.UIMenuItem]
}
@available(iOS 13.0, *)
extension AttachmentsViewModel {
  public func contextMenuConfiguration(forCellViewModel cellViewModel: Dialog_iOS.MessageCellViewModel, handler: @escaping ((UIKit.UIAction) -> Swift.Void)) -> UIKit.UIContextMenuConfiguration?
}
public struct AttentionRedButtonStyle {
}
public typealias AudioPort = AVFoundation.AVAudioSession.Port
public typealias AudioPortDescription = AVFoundation.AVAudioSessionPortDescription
public enum AudioPortType {
  case input
  case output
  case inputOutput
  public static let portTypesInputOutput: Swift.Set<Dialog_iOS.AudioPort>
  public static let portTypesInputOnly: Swift.Set<Dialog_iOS.AudioPort>
  public static let portTypesOutputOnly: Swift.Set<Dialog_iOS.AudioPort>
  public static func == (a: Dialog_iOS.AudioPortType, b: Dialog_iOS.AudioPortType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public enum SupportedAudioPortOutputType : Swift.Int, Swift.Equatable, Swift.RawRepresentable {
  case builtInNearEar
  case speaker
  case airPods
  case carPlay
  case bluetoothHPF
  case headphones
  case usbAudio
  public static var nonEmbeddedPorts: [Dialog_iOS.SupportedAudioPortOutputType]
  public var nativeRepresentation: Dialog_iOS.AudioPort {
    get
  }
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
extension AVAudioSessionPortDescription {
  public func isPortType(_ args: Dialog_iOS.AudioPort...) -> Swift.Bool
  public func isPortType(_ sequence: [Dialog_iOS.AudioPort]) -> Swift.Bool
  public var isWifi: Swift.Bool {
    get
  }
  public var isWireless: Swift.Bool {
    get
  }
  public var isBluetooth: Swift.Bool {
    get
  }
  public var isCable: Swift.Bool {
    get
  }
  public var isCloseToEar: Swift.Bool {
    get
  }
  public var isHeadset: Swift.Bool {
    get
  }
  public var isHeadphones: Swift.Bool {
    get
  }
  public var isCarPlay: Swift.Bool {
    get
  }
  public var isSpeaker: Swift.Bool {
    get
  }
}
public protocol AudioPlayerViewModelProtocol : AnyObject {
  var didStopPlayAudio: RxRelay.PublishRelay<Foundation.URL> { get }
  var didStartPlayAudio: RxRelay.PublishRelay<Foundation.URL> { get }
  var content: DialogMessaging.DialogVoiceMessageContent? { get }
  var recognizer: Speech.SFSpeechRecognizer? { get }
  var didTapPlayAudioMessage: RxSwift.AnyObserver<(DialogMessaging.DialogVoiceMessageContent, Foundation.TimeInterval)> { get }
  var currentTime: Foundation.TimeInterval? { get set }
  var currentURL: Foundation.URL? { get }
  var isPlaying: Swift.Bool { get }
  var messages: RxSwift.Observable<[DialogProtocols.DialogMessage]>? { get set }
}
@objc @_hasMissingDesignatedInitializers final public class AudioPlayerViewModel : ObjectiveC.NSObject, Dialog_iOS.AudioPlayerViewModelProtocol {
  final public var currentTime: Foundation.TimeInterval? {
    get
    set
  }
  final public let didStopPlayAudio: RxRelay.PublishRelay<Foundation.URL>
  final public let didStartPlayAudio: RxRelay.PublishRelay<Foundation.URL>
  final public let didTapPlayAudioMessage: RxSwift.AnyObserver<(DialogMessaging.DialogVoiceMessageContent, Foundation.TimeInterval)>
  final public var currentURL: Foundation.URL? {
    get
  }
  final public var isPlaying: Swift.Bool {
    get
  }
  weak final public var messages: RxSwift.Observable<[DialogProtocols.DialogMessage]>? {
    get
    set
  }
  final public let recognizer: Speech.SFSpeechRecognizer?
  final public var content: DialogMessaging.DialogVoiceMessageContent?
  @objc override dynamic public init()
  @objc deinit
}
extension AudioPlayerViewModel : AVFoundation.AVAudioPlayerDelegate {
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  @objc final public func audioPlayerDidFinishPlaying(_ player: AVFoundation.AVAudioPlayer, successfully flag: Swift.Bool)
}
@_inheritsConvenienceInitializers final public class AuthCertificateScene : Dialog_iOS.Scene<DialogAuth.AuthFlowState, UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.AuthCertificateScene.Builder
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<DialogAuth.AuthFlowState, UIKit.UIViewController, Dialog_iOS.AuthCertificateViewModelProtocol> {
    override public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<DialogAuth.AuthFlowState>) -> Dialog_iOS.AuthCertificateViewModelProtocol
    override public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<DialogAuth.AuthFlowState>, viewModel: Dialog_iOS.AuthCertificateViewModelProtocol) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<DialogAuth.AuthFlowState, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
public protocol AuthCertificateViewProtocol {
}
@objc @_hasMissingDesignatedInitializers final public class AuthCertificateViewController : UIKit.UIViewController, Dialog_iOS.AuthCertificateViewProtocol {
  public typealias VM = Dialog_iOS.AuthCertificateViewModelProtocol
  final public let viewModel: Dialog_iOS.AuthCertificateViewController.VM
  required public init(viewModel: Dialog_iOS.AuthCertificateViewController.VM)
  @objc override final public func loadView()
  @objc override final public func viewDidLoad()
  final public func bind(to viewModel: Dialog_iOS.AuthCertificateViewController.VM)
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class AuthCertificateViewControllerView : UIKit.UIView, Dialog_iOS.Identifiable {
  @objc @IBOutlet public var instructionsTitleLabel: UIKit.UILabel!
  @objc @IBOutlet public var instructionsSubtitleLabel: UIKit.UILabel!
  @objc @IBOutlet public var detailsSubtitle: UIKit.UILabel!
  @objc @IBOutlet public var certificateLinkTextField: UIKit.UITextField!
  @objc @IBOutlet public var certificateLinkSubtitle: UIKit.UILabel!
  @objc @IBOutlet public var passphraseTextField: UIKit.UITextField!
  @objc @IBOutlet public var passphraseSubltitle: UIKit.UILabel!
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public protocol AuthCertificateViewModelProtocol : Dialog_iOS.ViewModelProtocol {
  var statusSubtitle: RxCocoa.Driver<Dialog_iOS.AuthCertificateStatus> { get }
  var instructionsTitle: RxCocoa.Driver<Swift.String> { get }
  var instructionsSubtitle: RxCocoa.Driver<Swift.String> { get }
  var certificateLinkSubtitle: RxCocoa.Driver<Swift.String> { get }
  var passphraseSubtitle: RxCocoa.Driver<Swift.String> { get }
  var startActionPermission: RxCocoa.Driver<Dialog_iOS.AuthCertificateStartPermission> { get }
  var certificaterLink: RxSwift.AnyObserver<Swift.String?> { get }
  var passphrase: RxSwift.AnyObserver<Swift.String?> { get }
  var doneAction: RxSwift.AnyObserver<Swift.Void> { get }
  var isLoading: RxCocoa.Driver<Swift.Bool> { get }
}
public enum AuthCertificateStatus {
  case idle
  case details(Swift.String)
  case failure(Swift.String)
}
public enum AuthCertificateStartPermission {
  case granted
  case invalidUrl
  case initialDataLoading
  case loadingCertificate
  public var startAllowed: Swift.Bool {
    get
  }
  public static func == (a: Dialog_iOS.AuthCertificateStartPermission, b: Dialog_iOS.AuthCertificateStartPermission) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
final public class AuthCertificateViewModel : Dialog_iOS.AuthCertificateViewModelProtocol {
  final public let statusSubtitle: RxCocoa.Driver<Dialog_iOS.AuthCertificateStatus>
  final public let onAuthenticated: RxCocoa.Driver<DialogAuth.AuthFlowState>
  final public let instructionsTitle: RxCocoa.Driver<Swift.String>
  final public let instructionsSubtitle: RxCocoa.Driver<Swift.String>
  final public let certificateLinkSubtitle: RxCocoa.Driver<Swift.String>
  final public let passphraseSubtitle: RxCocoa.Driver<Swift.String>
  final public let startActionPermission: RxCocoa.Driver<Dialog_iOS.AuthCertificateStartPermission>
  final public let certificaterLink: RxSwift.AnyObserver<Swift.String?>
  final public let passphrase: RxSwift.AnyObserver<Swift.String?>
  final public let doneAction: RxSwift.AnyObserver<Swift.Void>
  final public let isLoading: RxCocoa.Driver<Swift.Bool>
  public init(initialState: DialogAuth.AuthFlowState, authService: DialogProtocols.AuthServiceProtocol, routerService: Dialog_iOS.RouterServiceProtocol, registerInfoProvider: DialogAuth.RegistrationTaskPerformerRequestInfoProvider)
  @objc deinit
}
public typealias AuthRouter = XCoordinator.WeakRouter<Dialog_iOS.AuthRoute>
public typealias AnyAuthCoordinator = Dialog_iOS.AuthCoordinator.AnyCoordinatorType
public enum AuthRoute : XCoordinator.Route, Swift.Equatable {
  case authType
  case beginPhone
  case specifyLocale
  case dismissLocaleSpecifying
  case approvalCode(DialogAuth.AuthFlowState)
  case signUpUsername(DialogAuth.AuthFlowState)
  case beginCertificate
  case beginLoginPassword
  case beginPKI
  case beginSecIdentity
  case beginToken
  public static func == (a: Dialog_iOS.AuthRoute, b: Dialog_iOS.AuthRoute) -> Swift.Bool
}
final public class AuthCoordinator : XCoordinator.NavigationCoordinator<Dialog_iOS.AuthRoute> {
  final public let container: Swinject.Container
  public init(container: Swinject.Container)
  override final public func prepareTransition(for route: Dialog_iOS.AuthRoute) -> XCoordinator.NavigationTransition
  @objc deinit
  override public init(rootViewController: XCoordinator.NavigationCoordinator<Dialog_iOS.AuthRoute>.RootViewController = super, initialRoute: Dialog_iOS.AuthRoute? = super)
  override public init(rootViewController: XCoordinator.NavigationCoordinator<Dialog_iOS.AuthRoute>.RootViewController = super, root: XCoordinator.Presentable)
}
@_inheritsConvenienceInitializers final public class AuthCountryScene : Dialog_iOS.Scene<Swift.Void, UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.AuthCountryScene.Builder
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<Swift.Void, UIKit.UIViewController, Dialog_iOS.AuthCountryViewModelProtocol> {
    override final public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>) -> Dialog_iOS.AuthCountryViewModelProtocol
    override final public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>, viewModel: Dialog_iOS.AuthCountryViewModelProtocol) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<Swift.Void, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
@objc @_hasMissingDesignatedInitializers final public class AuthCountryViewController : UIKit.UIViewController {
  public typealias VM = Dialog_iOS.AuthCountryViewModelProtocol
  public init(viewModel: Dialog_iOS.AuthCountryViewController.VM)
  @objc override final public func viewDidLoad()
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc deinit
}
public struct AuthCountryItem : Swift.Equatable {
  public init?(code: Swift.String, locale: Foundation.Locale = .current, isDefault: Swift.Bool = false)
  public static func == (a: Dialog_iOS.AuthCountryItem, b: Dialog_iOS.AuthCountryItem) -> Swift.Bool
}
public protocol AuthCountryViewModelProtocol {
  var availableAuthCountries: RxCocoa.Driver<[Dialog_iOS.AuthCountryItem]> { get }
  var search: RxSwift.AnyObserver<Swift.String?> { get }
  var select: RxSwift.AnyObserver<Dialog_iOS.AuthCountryItem> { get }
}
final public class AuthCountryViewModel : Dialog_iOS.AuthCountryViewModelProtocol {
  final public var availableAuthCountries: RxCocoa.Driver<[Dialog_iOS.AuthCountryItem]>
  final public var search: RxSwift.AnyObserver<Swift.String?>
  final public var select: RxSwift.AnyObserver<Dialog_iOS.AuthCountryItem>
  public init(regionService: Dialog_iOS.PreferredRegionServiceProtocol, routerService: Dialog_iOS.RouterServiceProtocol)
  @objc deinit
}
@_inheritsConvenienceInitializers final public class AuthLoginPasswordScene : Dialog_iOS.Scene<DialogAuth.AuthFlowState, UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.AuthLoginPasswordScene.Builder
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<DialogAuth.AuthFlowState, UIKit.UIViewController, Dialog_iOS.AuthLoginPasswordViewModelProtocol> {
    override public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<DialogAuth.AuthFlowState>) -> Dialog_iOS.AuthLoginPasswordViewModelProtocol
    override public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<DialogAuth.AuthFlowState>, viewModel: Dialog_iOS.AuthLoginPasswordViewModelProtocol) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<DialogAuth.AuthFlowState, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
public protocol AuthLoginPasswordViewModelProtocol {
  var authUIViewModel: Dialog_iOS.AuthUIViewModelProtocol { get }
}
@_inheritsConvenienceInitializers final public class AuthPhoneScene : Dialog_iOS.Scene<DialogAuth.AuthFlowState, UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.AuthPhoneScene.Builder
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<DialogAuth.AuthFlowState, UIKit.UIViewController, Dialog_iOS.AuthPhoneViewModelProtocol> {
    override public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<DialogAuth.AuthFlowState>) -> Dialog_iOS.AuthPhoneViewModelProtocol
    override public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<DialogAuth.AuthFlowState>, viewModel: Dialog_iOS.AuthPhoneViewModelProtocol) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<DialogAuth.AuthFlowState, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
@objc @_inheritsConvenienceInitializers final public class AuthPhoneView : UIKit.UIView {
  @objc @IBOutlet final public var textField: PhoneNumberKit.PhoneNumberTextField! {
    get
  }
  @objc @IBOutlet final public var confirmationText: UIKit.UILabel! {
    get
  }
  @objc @IBOutlet final public var confirmationSwitcher: UIKit.UISwitch! {
    get
  }
  @objc @IBOutlet final public var statusLabel: UIKit.UILabel! {
    get
  }
  @objc @IBOutlet final public var localeButton: Dialog_iOS.TapAreaButton! {
    get
  }
  @objc override final public func awakeFromNib()
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
@objc @_hasMissingDesignatedInitializers final public class AuthPhoneViewController : UIKit.UIViewController {
  public typealias VM = Dialog_iOS.AuthPhoneViewModelProtocol
  public init(viewModel: Dialog_iOS.AuthPhoneViewController.VM?)
  @objc override final public func loadView()
  @objc override final public func viewDidLoad()
  @objc override final public func viewWillAppear(_ animated: Swift.Bool)
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc deinit
}
public protocol AuthPhoneViewModelProtocol {
  var confirmed: RxSwift.AnyObserver<Swift.Bool> { get }
  var goNext: RxSwift.AnyObserver<Swift.Void> { get }
  var phoneInput: RxSwift.AnyObserver<Swift.String?> { get }
  var phoneValidationResult: RxSwift.AnyObserver<Dialog_iOS.TextValidationResult> { get }
  var status: RxCocoa.Driver<Dialog_iOS.ContextedText> { get }
  var canGoNext: RxCocoa.Driver<Swift.Bool> { get }
  var loadingState: RxCocoa.Driver<Dialog_iOS.OneTextFieldViewModelLoadingState> { get }
  var preferredLocaleCode: RxCocoa.Driver<Swift.String?> { get }
  var presentLocalePicker: RxSwift.AnyObserver<Swift.Void> { get }
}
final public class AuthPhoneViewModel : Dialog_iOS.AuthPhoneViewModelProtocol {
  final public let goNext: RxSwift.AnyObserver<Swift.Void>
  final public let phoneValidationResult: RxSwift.AnyObserver<Dialog_iOS.TextValidationResult>
  final public let phoneInput: RxSwift.AnyObserver<Swift.String?>
  final public let canGoNext: RxCocoa.Driver<Swift.Bool>
  final public let status: RxCocoa.Driver<Dialog_iOS.ContextedText>
  final public let loadingState: RxCocoa.Driver<Dialog_iOS.OneTextFieldViewModelLoadingState>
  final public let confirmed: RxSwift.AnyObserver<Swift.Bool>
  final public let preferredLocaleCode: RxCocoa.Driver<Swift.String?>
  final public let presentLocalePicker: RxSwift.AnyObserver<Swift.Void>
  public init(initialState: DialogAuth.AuthFlowState, regionService: Dialog_iOS.PreferredRegionServiceProtocol, routerService: Dialog_iOS.RouterServiceProtocol, registerInfoProvider: DialogAuth.RegistrationTaskPerformerRequestInfoProvider)
  @objc deinit
}
@_inheritsConvenienceInitializers final public class AuthPKIScene : Dialog_iOS.Scene<DialogAuth.AuthFlowState, UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.AuthPKIScene.Builder
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<DialogAuth.AuthFlowState, UIKit.UIViewController, Dialog_iOS.AuthPKIViewModelProtocol> {
    override public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<DialogAuth.AuthFlowState>) -> Dialog_iOS.AuthPKIViewModelProtocol
    override public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<DialogAuth.AuthFlowState>, viewModel: Dialog_iOS.AuthPKIViewModelProtocol) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<DialogAuth.AuthFlowState, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
public protocol AuthPKIViewModelProtocol {
  var authUIViewModel: Dialog_iOS.AuthUIViewModelProtocol { get }
}
@_inheritsConvenienceInitializers final public class AuthSecIdentityScene : Dialog_iOS.Scene<DialogAuth.AuthFlowState, UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.AuthSecIdentityScene.Builder
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<DialogAuth.AuthFlowState, UIKit.UIViewController, Dialog_iOS.AuthSecIdentityViewModelProtocol> {
    override public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<DialogAuth.AuthFlowState>) -> Dialog_iOS.AuthSecIdentityViewModelProtocol
    override public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<DialogAuth.AuthFlowState>, viewModel: Dialog_iOS.AuthSecIdentityViewModelProtocol) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<DialogAuth.AuthFlowState, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
public protocol AuthSecIdentityViewModelProtocol {
  var authUIViewModel: Dialog_iOS.AuthUIViewModelProtocol { get }
}
@_inheritsConvenienceInitializers final public class AuthSignUpUsernameScene : Dialog_iOS.Scene<DialogAuth.AuthFlowState, UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.AuthSignUpUsernameScene.Builder
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<DialogAuth.AuthFlowState, UIKit.UIViewController, Dialog_iOS.AuthSignUpUsernameViewModelProtocol> {
    override final public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<DialogAuth.AuthFlowState>) -> Dialog_iOS.AuthSignUpUsernameViewModelProtocol
    override final public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<DialogAuth.AuthFlowState>, viewModel: Dialog_iOS.AuthSignUpUsernameViewModelProtocol) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<DialogAuth.AuthFlowState, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
public protocol AuthSignUpUsernameViewModelProtocol : Dialog_iOS.OneTextFieldViewModelProtocol {
}
final public class AuthSignUpUsernameViewModel : Dialog_iOS.AuthSignUpUsernameViewModelProtocol {
  final public let action: RxSwift.AnyObserver<Swift.Void>
  final public let textFieldInput: RxSwift.AnyObserver<Swift.String?>
  final public let textFieldValidationResult: RxSwift.AnyObserver<Dialog_iOS.TextValidationResult>
  final public let textFieldConfigurator: Dialog_iOS.TextFieldRxConfigurator<Dialog_iOS.TextField>
  final public let detailsLabelConfigurator: Dialog_iOS.LabelRxConfigurator<UIKit.UILabel>
  final public let canGoNext: RxCocoa.Driver<Swift.Bool>
  final public let loadingState: RxCocoa.Driver<Dialog_iOS.OneTextFieldViewModelLoadingState>
  public init(initialState: DialogAuth.AuthFlowState, authService: DialogProtocols.AuthServiceProtocol, routerService: Dialog_iOS.RouterServiceProtocol)
  @objc deinit
}
@_inheritsConvenienceInitializers final public class AuthTokenScene : Dialog_iOS.Scene<DialogAuth.AuthFlowState, UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.AuthTokenScene.Builder
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<DialogAuth.AuthFlowState, UIKit.UIViewController, Dialog_iOS.AuthTokenViewModelProtocol> {
    override public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<DialogAuth.AuthFlowState>) -> Dialog_iOS.AuthTokenViewModelProtocol
    override public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<DialogAuth.AuthFlowState>, viewModel: Dialog_iOS.AuthTokenViewModelProtocol) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<DialogAuth.AuthFlowState, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
public protocol AuthTokenViewModelProtocol {
  var authUIViewModel: Dialog_iOS.AuthUIViewModelProtocol { get }
}
public struct RestorableAuth {
  public let entry: DialogProtocols.RestorableAuthEntry
  public let title: Swift.String
  public let subtitle: Swift.String?
  public init(entry: DialogProtocols.RestorableAuthEntry, title: Swift.String, subtitle: Swift.String?)
}
@_hasMissingDesignatedInitializers public class AuthTypeCellViewModel {
  @objc deinit
}
@_inheritsConvenienceInitializers final public class AuthTypeScene : Dialog_iOS.Scene<Swift.Void, UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.AuthTypeScene.Builder
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<Swift.Void, UIKit.UIViewController, Dialog_iOS.AuthTypeViewModelProtocol> {
    override final public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>) -> Dialog_iOS.AuthTypeViewModelProtocol
    override final public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>, viewModel: Dialog_iOS.AuthTypeViewModelProtocol) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<Swift.Void, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
public protocol AuthTypeViewModelProtocol : Dialog_iOS.ViewModelProtocol {
  var title: RxCocoa.Driver<Swift.String> { get }
  var authTypeSections: RxCocoa.Driver<[Dialog_iOS.AuthTypesSection]> { get }
  var deleteRestorableAuth: RxSwift.AnyObserver<DialogProtocols.RestorableAuthEntry> { get }
  var selectAuthType: RxSwift.AnyObserver<Dialog_iOS.AuthTypeCellViewModel> { get }
}
public struct AuthTypesSection {
  public enum Kind {
    case newAuth
    case oldAuth
    public static func == (a: Dialog_iOS.AuthTypesSection.Kind, b: Dialog_iOS.AuthTypesSection.Kind) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public let title: Swift.String
  public let items: [Dialog_iOS.AuthTypeCellViewModel]
}
extension AuthTypesSection : Differentiator.SectionModelType {
  public typealias Item = Dialog_iOS.AuthTypeCellViewModel
  public init(original: Dialog_iOS.AuthTypesSection, items: [Dialog_iOS.AuthTypesSection.Item])
}
public enum AuthUIViewModelLoginMode : Swift.Int {
  case loginPassword
  case pki
  case secIdentity
  case token
  case none
  public static let `default`: Dialog_iOS.AuthUIViewModelLoginMode
  public var needToShowLoginAndPassword: Swift.Bool {
    get
  }
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public protocol AuthUIViewModelProtocol {
  var generalColor: RxCocoa.Driver<UIKit.UIColor> { get }
  var logoViewImage: RxCocoa.Driver<UIKit.UIImage?> { get }
  var loginTextFieldPlaceholder: RxCocoa.Driver<Swift.String> { get }
  var loginTextFieldTextOut: RxCocoa.Driver<Swift.String> { get }
  var loginTextFieldError: RxCocoa.Driver<Swift.String?> { get }
  var showLoginInfo: RxCocoa.Driver<Swift.Bool> { get }
  var loginInfoMessage: RxCocoa.Driver<Swift.String> { get }
  var loginInfoButtonImage: RxCocoa.Driver<UIKit.UIImage?> { get }
  var passwordTextFieldPlaceholder: RxCocoa.Driver<Swift.String> { get }
  var passwordTextFieldTextOut: RxCocoa.Driver<Swift.String> { get }
  var passwordTextFieldError: RxCocoa.Driver<Swift.String?> { get }
  var showPassword: RxCocoa.Driver<Swift.Bool> { get }
  var showPasswordButtonImage: RxCocoa.Driver<UIKit.UIImage?> { get }
  var proceedButtonTitle: RxCocoa.Driver<Swift.String> { get }
  var proceedButtonIsEnabled: RxCocoa.Driver<Swift.Bool> { get }
  var restorePasswordButtonTitle: RxCocoa.Driver<Swift.String> { get }
  var restorePasswordButtonVisibility: RxCocoa.Driver<Swift.Bool> { get }
  var needHelpButtonTitle: RxCocoa.Driver<Swift.String> { get }
  var needHelpButtonVisibility: RxCocoa.Driver<Swift.Bool> { get }
  var leaveFeedbackButtonTitle: RxCocoa.Driver<Swift.String> { get }
  var leaveFeedbackButtonVisibility: RxCocoa.Driver<Swift.Bool> { get }
  var versionLabelText: RxCocoa.Driver<Swift.String> { get }
  var isAuthInProgress: RxCocoa.Driver<Swift.Bool> { get }
  var endpoint: RxSwift.Observable<Swift.String> { get }
  var username: RxSwift.Observable<Swift.String> { get }
  var password: RxSwift.Observable<Swift.String> { get }
  var loginTextFieldTextIn: RxSwift.AnyObserver<Swift.String> { get }
  var loginInfoButtonTouchDown: RxSwift.AnyObserver<Swift.Void> { get }
  var loginInfoButtonTouchUp: RxSwift.AnyObserver<Swift.Void> { get }
  var passwordTextFieldTextIn: RxSwift.AnyObserver<Swift.String> { get }
  var showPasswordButtonTouchDown: RxSwift.AnyObserver<Swift.Void> { get }
  var showPasswordButtonTouchUp: RxSwift.AnyObserver<Swift.Void> { get }
  var proceedButtonTap: RxSwift.AnyObserver<Swift.Void> { get }
  var restorePasswordButtonTap: RxSwift.AnyObserver<Swift.Void> { get }
  var needHelpButtonTap: RxSwift.AnyObserver<Swift.Void> { get }
  var leaveFeedbackButtonTap: RxSwift.AnyObserver<Swift.Void> { get }
  var authResult: RxSwift.AnyObserver<RxSwift.Event<DialogAuth.AuthFlowState>> { get }
  var infoMessagePresenter: Dialog_iOS.InfoMessagePresenter { get }
  var loginMode: Dialog_iOS.AuthUIViewModelLoginMode { get }
  var isHorizontalLogo: Swift.Bool { get }
  var disposeBag: RxSwift.DisposeBag { get }
}
@_inheritsConvenienceInitializers final public class AuthValidateCodeScene : Dialog_iOS.Scene<DialogAuth.AuthFlowState, UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.AuthValidateCodeScene.Builder
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<DialogAuth.AuthFlowState, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
public struct AuthValidateCodeConfig {
  public static let `default`: Dialog_iOS.AuthValidateCodeConfig
  public var autoStartCodeLength: Swift.Int
  public var resendTimeout: Swift.Double
  public var shouldAutoStart: Swift.Bool {
    get
  }
}
public protocol AuthValidateViewModelProtocol : Dialog_iOS.ViewModelProtocol {
  var textFieldConfigurator: Dialog_iOS.TextFieldRxConfigurator<Dialog_iOS.TextField> { get }
  var textFieldUserInput: RxSwift.AnyObserver<Swift.String?> { get }
  var detailsLabelConfigurator: Dialog_iOS.LabelRxConfigurator<UIKit.UILabel> { get }
  var resendButtonConfigurator: Dialog_iOS.ButtonRxConfigurator<UIKit.UIButton> { get }
  var resendStatusLabelConfigurator: Dialog_iOS.LabelRxConfigurator<UIKit.UILabel> { get }
  var doneAction: RxSwift.AnyObserver<Swift.Void> { get }
  var isLoading: RxCocoa.Driver<Swift.Bool> { get }
  var resendAction: RxSwift.AnyObserver<Swift.Void> { get }
  var canStart: RxCocoa.Driver<Swift.Bool> { get }
}
final public class AuthValidateViewModel : Dialog_iOS.AuthValidateViewModelProtocol {
  final public let textFieldUserInput: RxSwift.AnyObserver<Swift.String?>
  final public let textFieldConfigurator: Dialog_iOS.TextFieldRxConfigurator<Dialog_iOS.TextField>
  final public let detailsLabelConfigurator: Dialog_iOS.LabelRxConfigurator<UIKit.UILabel>
  final public let resendButtonConfigurator: Dialog_iOS.ButtonRxConfigurator<UIKit.UIButton>
  final public var resendStatusLabelConfigurator: Dialog_iOS.LabelRxConfigurator<UIKit.UILabel>
  final public let doneAction: RxSwift.AnyObserver<Swift.Void>
  final public let resendAction: RxSwift.AnyObserver<Swift.Void>
  final public let canStart: RxCocoa.Driver<Swift.Bool>
  final public let onDidAuthenticate: RxCocoa.Driver<DialogAuth.AuthFlowState>
  final public let onRegistrationNeeded: RxCocoa.Driver<DialogAuth.AuthFlowState>
  final public let isLoading: RxCocoa.Driver<Swift.Bool>
  public init(initialState: DialogAuth.AuthFlowState, authService: DialogProtocols.AuthServiceProtocol, routerService: Dialog_iOS.RouterServiceProtocol, config: Dialog_iOS.AuthValidateCodeConfig = .default)
  @objc deinit
}
public protocol AvatarNodeModelProtocol {
  var userAvatarBasicColor: RxCocoa.Driver<UIKit.UIColor> { get }
  var avatarImage: RxSwift.Observable<UIKit.UIImage?> { get }
  var avatarCenterText: RxSwift.Observable<Swift.String?> { get }
  var avatarNodeDidTapped: RxRelay.PublishRelay<Swift.Void> { get set }
}
public protocol AvatarNodeStyleProtocol {
  var attributesText: [Foundation.NSAttributedString.Key : Any] { get }
  var cornerRadius: Dialog_iOS.CornerRadiusType { get }
  var avatarLoaderActivityStyle: UIKit.UIActivityIndicatorView.Style { get }
  var defaultBackgroundColor: UIKit.UIColor { get }
  var preserveAvatarUserColor: Swift.Bool { get }
  var gradientStartPoint: CoreGraphics.CGPoint { get }
  var gradientEndPoint: CoreGraphics.CGPoint { get }
}
extension AvatarNodeStyleProtocol {
  public var attributesText: [Foundation.NSAttributedString.Key : Any] {
    get
  }
  public var cornerRadius: Dialog_iOS.CornerRadiusType {
    get
  }
  public var avatarLoaderActivityStyle: UIKit.UIActivityIndicatorView.Style {
    get
  }
  public var defaultBackgroundColor: UIKit.UIColor {
    get
  }
  public var preserveAvatarUserColor: Swift.Bool {
    get
  }
  public var gradientStartPoint: CoreGraphics.CGPoint {
    get
  }
  public var gradientEndPoint: CoreGraphics.CGPoint {
    get
  }
}
@objc public class AvatarNode : AsyncDisplayKit.ASControlNode {
  public init(viewModel: Dialog_iOS.AvatarNodeModelProtocol, design: Dialog_iOS.AvatarNodeStyleProtocol, size: CoreGraphics.CGSize?)
  @objc override dynamic public func didLoad()
  @objc override dynamic public func layout()
  @objc override dynamic public func layoutSpecThatFits(_ constrainedSize: AsyncDisplayKit.ASSizeRange) -> AsyncDisplayKit.ASLayoutSpec
  @objc override dynamic public func layoutDidFinish()
  @objc deinit
  @objc override dynamic public init()
}
public struct AvatarNodeProfileStyle : Dialog_iOS.AvatarNodeStyleProtocol {
  public let preserveAvatarUserColor: Swift.Bool
  public let attributesText: [Foundation.NSAttributedString.Key : Any]
  public let cornerRadius: Dialog_iOS.CornerRadiusType
  public let avatarLoaderActivityStyle: UIKit.UIActivityIndicatorView.Style
  public let defaultBackgroundColor: UIKit.UIColor
  public let gradientStartPoint: CoreGraphics.CGPoint
  public let gradientEndPoint: CoreGraphics.CGPoint
}
public struct AvatarNodeInMessageCellNode : Dialog_iOS.AvatarNodeStyleProtocol {
  public var attributesText: [Foundation.NSAttributedString.Key : Any] {
    get
  }
  public let avatarSize: CoreGraphics.CGSize
  public let cornerRadius: Dialog_iOS.CornerRadiusType
  public let avatarLoaderActivityStyle: UIKit.UIActivityIndicatorView.Style
  public let defaultBackgroundColor: UIKit.UIColor
  public let gradientStartPoint: CoreGraphics.CGPoint
  public let gradientEndPoint: CoreGraphics.CGPoint
}
public protocol AvatarNodeViewModelDeferredSubscribeProtocol {
  func subscribe()
}
@_inheritsConvenienceInitializers final public class AvatarPreviewScene : Dialog_iOS.Scene<Dialog_iOS.AvatarPreviewItem, UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.AvatarPreviewScene.Builder
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<Dialog_iOS.AvatarPreviewItem, UIKit.UIViewController, Dialog_iOS.DUIPreviewControllerModelProtocol> {
    override final public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Dialog_iOS.AvatarPreviewItem>) -> Dialog_iOS.DUIPreviewControllerModelProtocol
    override final public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Dialog_iOS.AvatarPreviewItem>, viewModel: Dialog_iOS.DUIPreviewControllerModelProtocol) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<Dialog_iOS.AvatarPreviewItem, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
public enum AvatarPreviewItemError : Swift.Error {
  case emptyFile
  public static func == (a: Dialog_iOS.AvatarPreviewItemError, b: Dialog_iOS.AvatarPreviewItemError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
@objc public class AvatarPreviewItem : ObjectiveC.NSObject, QuickLook.QLPreviewItem {
  public init(avatarUrl: Foundation.URL, username: Swift.String)
  @objc public var previewItemURL: Foundation.URL? {
    @objc get
  }
  @objc public var previewItemTitle: Swift.String? {
    @objc get
  }
  public func extractImage() throws -> UIKit.UIImage
  @objc deinit
  @objc override dynamic public init()
}
public class AvatarPreviewViewModel : Dialog_iOS.DUIPreviewControllerModelProtocol {
  public var reloadDataAndGoToIndex: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Swift.Int>
  public var isLoading: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Swift.Bool>
  public init(item: Dialog_iOS.AvatarPreviewItem)
  @objc public func numberOfPreviewItems(in controller: QuickLook.QLPreviewController) -> Swift.Int
  @objc public func previewController(_ controller: QuickLook.QLPreviewController, previewItemAt index: Swift.Int) -> QuickLook.QLPreviewItem
  @objc deinit
}
public protocol AvatarProviderUtilityProtocol {
  func avatar(group: RxSwift.Observable<DialogProtocols.DialogGroup?>) -> RxSwift.Observable<UIKit.UIImage?>
  func avatar(user: RxSwift.Observable<DialogProtocols.DialogUser?>) -> RxSwift.Observable<UIKit.UIImage?>
}
extension EventBusServiceProtocol {
  public func user(id: DialogProtocols.DialogUserId, defaultUser: DialogProtocols.DialogUser?) -> RxSwift.Observable<DialogProtocols.DialogUser?>
  public func group(id: DialogProtocols.DialogGroupId, defaultGroup: DialogProtocols.DialogGroup?) -> RxSwift.Observable<DialogProtocols.DialogGroup?>
}
final public class AvatarProviderFileServiceUtility : Dialog_iOS.AvatarProviderUtilityProtocol {
  public init(fileService: DialogFiles.DialogFileServiceProtocol)
  final public func avatar(group: RxSwift.Observable<DialogProtocols.DialogGroup?>) -> RxSwift.Observable<UIKit.UIImage?>
  final public func avatar(user: RxSwift.Observable<DialogProtocols.DialogUser?>) -> RxSwift.Observable<UIKit.UIImage?>
  @objc deinit
}
public typealias CornerRadiusType = DialogSharedComponents.CornerRadiusType
public typealias AvatarViewStyleProtocol = DialogSharedComponents.AvatarViewStyleProtocol
public typealias AvatarViewModelProtocol = DialogSharedComponents.AvatarViewModelProtocol
public typealias CheckmarkableAvatarViewModelProtocol = DialogSharedComponents.CheckmarkableAvatarViewModelProtocol
public typealias CheckmarkableAvatarViewStyleProtocol = DialogSharedComponents.CheckmarkableAvatarViewStyleProtocol
public typealias AvatarViewProtocol = DialogSharedComponents.AvatarViewProtocol
public typealias AvatarView = DialogSharedComponents.AvatarView
public typealias AvatarUtils = DialogSharedComponents.AvatarUtils
extension Reactive where Base : AVFoundation.AVAudioSession {
  public func getRecordPermission(requestIfNeeded: Swift.Bool) -> RxSwift.Single<AVFoundation.AVAudioSession.RecordPermission>
}
extension AVCaptureDevice {
  @_hasMissingDesignatedInitializers public class AVCaptureDeviceRx {
    @objc deinit
  }
  public class var rx: AVFoundation.AVCaptureDevice.AVCaptureDeviceRx {
    get
  }
}
public protocol BadgeViewDesignProtocol {
  var backgroundColor: UIKit.UIColor { get }
  var valueColor: UIKit.UIColor { get }
  var valueFont: UIKit.UIFont { get }
  var valueOffset: UIKit.UIEdgeInsets { get }
}
public struct BadgeDefaultDesign : Dialog_iOS.BadgeViewDesignProtocol {
  public var backgroundColor: UIKit.UIColor
  public var valueColor: UIKit.UIColor
  public var valueFont: UIKit.UIFont
  public var valueOffset: UIKit.UIEdgeInsets
}
public protocol BadgeViewProtocol {
  func updateBadge(value: Swift.String, design: Dialog_iOS.BadgeViewDesignProtocol) -> CoreGraphics.CGFloat
}
public protocol BaseGroupProfileAvatarViewModelProtocol : DialogSharedComponents.AvatarViewModelProtocol {
  var imagePicked: RxSwift.AnyObserver<UIKit.UIImage> { get }
  var justMadePhoto: RxSwift.AnyObserver<UIKit.UIImage> { get }
  var deleteAvatarSelected: RxSwift.AnyObserver<Swift.Void> { get }
  var resetState: RxSwift.AnyObserver<Swift.Bool> { get }
  var hasAvatar: RxCocoa.Driver<Swift.Bool> { get }
  var avatarOption: RxSwift.Observable<Dialog_iOS.DialogAvatarOption> { get }
}
public class DefaultGroupProfileAvatarViewModel : Dialog_iOS.BaseGroupProfileAvatarViewModelProtocol {
  public var imagePicked: RxSwift.AnyObserver<UIKit.UIImage>
  public var justMadePhoto: RxSwift.AnyObserver<UIKit.UIImage>
  public var deleteAvatarSelected: RxSwift.AnyObserver<Swift.Void>
  public var resetState: RxSwift.AnyObserver<Swift.Bool>
  public var hasAvatar: RxCocoa.Driver<Swift.Bool>
  public var avatarOption: RxSwift.Observable<Dialog_iOS.DialogAvatarOption>
  public var avatarImage: RxCocoa.Driver<UIKit.UIImage?>
  public var basicColor: UIKit.UIColor
  public var isAvatarLoading: RxCocoa.Driver<Swift.Bool>
  public var avatarCenterText: RxCocoa.Driver<Swift.String?>
  public init(groupId: DialogProtocols.DialogGroupId? = nil, assetsService: Dialog_iOS.AssetsServiceProtocol, uploadFileService: DialogFiles.DialogUploadFileServiceProtocol, eventBusService: DialogProtocols.EventBusServiceProtocol, fileService: DialogFiles.DialogFileServiceProtocol, colorService: Dialog_iOS.DialogPeerColorsServiceProtocol)
  @objc deinit
}
public protocol BaseGroupProfileViewModelProtocol : Dialog_iOS.ViewModelProtocol {
  var avatarViewModel: Dialog_iOS.BaseGroupProfileAvatarViewModelProtocol { get }
  var proceed: RxSwift.AnyObserver<Swift.Bool> { get }
  var title: RxCocoa.Driver<Dialog_iOS.DUINavigationTitleModel> { get }
  var sections: RxCocoa.Driver<[Dialog_iOS.DUISimpleSection]> { get }
  var canProceed: RxCocoa.Driver<Swift.Bool> { get }
  var isLoading: RxCocoa.Driver<Swift.Bool> { get }
  var error: RxCocoa.Driver<Swift.Error> { get }
  func linkDidTapped(link: Foundation.URL)
}
public protocol MessageListItemMenuProvidable {
  func resolveMenu(source: Any) -> Dialog_iOS.MessageListControllerMenuResolve
  func handleMenuEvent(_ event: Dialog_iOS.MenuActionEvent)
  func handleDoubleTouchGesture(source: Any)
}
final public class BasicAvatarViewModel : Dialog_iOS.AvatarViewModelProtocol {
  final public var basicColor: UIKit.UIColor
  final public var isAvatarLoading: RxCocoa.Driver<Swift.Bool>
  final public var avatarImage: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, UIKit.UIImage?>
  final public var avatarCenterText: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Swift.String?>
  public init(user: DialogProtocols.DialogUser, filesService: DialogFiles.DialogFileServiceProtocol, colorService: Dialog_iOS.DialogPeerColorsServiceProtocol, startWithNilImage: Swift.Bool = true)
  @objc deinit
}
public enum TryToCallResult {
  case success
  case error
  case isBusy
  case featureHolder(forCallType: DialogProtocols.AccessibleCallType)
}
public enum BeginCallActionResponse : Swift.Equatable {
  case perform(DialogProtocols.AccessibleCallType)
  case cancel
  public static func == (a: Dialog_iOS.BeginCallActionResponse, b: Dialog_iOS.BeginCallActionResponse) -> Swift.Bool
}
public protocol BeginCallTypeChoiceViewModelProtocol : AnyObject {
  func bind(userId: DialogProtocols.DialogUserId)
  func choose(action: Dialog_iOS.BeginCallActionResponse)
  var didTapCallChoose: RxSwift.AnyObserver<DialogProtocols.DialogUserId> { get }
  func tryToCall(type: DialogProtocols.AccessibleCallType, id: DialogProtocols.DialogUserId) -> RxSwift.Single<Dialog_iOS.TryToCallResult>
  var begin: RxCocoa.Driver<[DialogProtocols.AccessibleCallType]> { get }
  var availableCallTypes: RxCocoa.Driver<[DialogProtocols.AccessibleCallType]> { get }
}
final public class BeginCallTypeChoiceViewModel : Dialog_iOS.BeginCallTypeChoiceViewModelProtocol {
  final public var begin: RxCocoa.Driver<[DialogProtocols.AccessibleCallType]>
  final public var didTapCallChoose: RxSwift.AnyObserver<DialogProtocols.DialogUserId>
  final public func choose(action: Dialog_iOS.BeginCallActionResponse)
  final public func bind(userId: DialogProtocols.DialogUserId)
  final public func tryToCall(type: DialogProtocols.AccessibleCallType, id: DialogProtocols.DialogUserId) -> RxSwift.Single<Dialog_iOS.TryToCallResult>
  final public var availableCallTypes: RxCocoa.Driver<[DialogProtocols.AccessibleCallType]> {
    get
  }
  public init(availableBeginCallTypes: [DialogProtocols.AccessibleCallType], callsService: DialogCalls.CallsServiceProtocol, eventBusService: DialogProtocols.EventBusServiceProtocol, featureFlagsService: DialogProtocols.DialogFeatureFlagsServiceProtocol, callsGateway: Dialog_iOS.CallsGatewayServiceProtocol)
  @objc deinit
}
extension CallSessionProtocol {
  public var recipientId: DialogProtocols.DialogUserId? {
    get
  }
}
extension BehaviorRelay {
  final public func mutate(_ closure: (inout Element) -> Swift.Void)
}
extension BehaviorRelay where Element : Swift.Equatable {
  final public func updateIfChanged(_ closure: (Element) -> Element)
}
open class BidirectionalCollectionViewController : AsyncDisplayKit.ASDKViewController<AsyncDisplayKit.ASCollectionNode> {
  public var batchFetchingContext: AsyncDisplayKit.ASBatchContext {
    get
    set
  }
  final public let collectionNode: AsyncDisplayKit.ASCollectionNode
  weak public var bidirectionalBatchingDelegate: Dialog_iOS.BidirectionalCollectionBatchingDelegate?
  required public init(layout: UIKit.UICollectionViewFlowLayout)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
  @objc override dynamic open func viewDidLoad()
  @objc override dynamic public init(node: AsyncDisplayKit.ASCollectionNode)
  @objc override dynamic public init()
}
public enum BatchFetchingDirection : Swift.Int {
  case prepend
  case append
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public protocol BidirectionalCollectionBatchingDelegate : AnyObject {
  func shouldAppendBatchFetch(for collectionNode: AsyncDisplayKit.ASCollectionNode) -> Swift.Bool
  func shouldPrependBatchFetch(for collectionNode: AsyncDisplayKit.ASCollectionNode) -> Swift.Bool
  func collectionNode(_ collectionNode: AsyncDisplayKit.ASCollectionNode, willBeginAppendingBatchFetchWith context: AsyncDisplayKit.ASBatchContext)
  func collectionNode(_ collectionNode: AsyncDisplayKit.ASCollectionNode, willBeginPrependingBatchFetchWith context: AsyncDisplayKit.ASBatchContext)
}
public protocol BubbleDesignProtocol {
  var bubbleInsets: UIKit.UIEdgeInsets { get }
  var contentInsets: UIKit.UIEdgeInsets { get }
  var cornerInsets: UIKit.UIEdgeInsets { get }
  var statusCornerRadius: CoreGraphics.CGFloat { get }
  var statusInsets: UIKit.UIEdgeInsets { get }
  var statusBackgroundColor: UIKit.UIColor { get }
}
public protocol BuilderProtocol : Dialog_iOS.ContainerServiceOutputProtocol {
  init(_ containerService: Dialog_iOS.ContainerServiceAccessProtocol)
  func setup()
}
extension Bundle {
  public static var dialogBundle: Foundation.Bundle?
  public static let externalURLScheme: Swift.String?
}
public enum BundleLookupStrategy {
  case dialogBundleOnly
  case mainBundleOnly
  case dialogBundleThenMainBundle
  case mainBundleThenDialogBundle
  public static func == (a: Dialog_iOS.BundleLookupStrategy, b: Dialog_iOS.BundleLookupStrategy) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
extension UIView {
  public static func loadFromNib(name: Swift.String) -> UIKit.UIView?
}
extension URL {
  public static func bundledUrl(forResource name: Swift.String, withExtension ext: Swift.String, lookupStrategy strategy: Dialog_iOS.BundleLookupStrategy = .dialogBundleThenMainBundle) -> (Foundation.URL?, Foundation.Bundle?)
}
extension UIImage {
  public static let imageCache: Foundation.NSCache<Swift.AnyObject, UIKit.UIImage>
  public static func bundled(_ name: Swift.String) -> UIKit.UIImage?
  public static func bundled(_ name: Swift.String, tint: UIKit.UIColor?) -> UIKit.UIImage?
  public static func bundled(_ name: Swift.String, tint: UIKit.UIColor) -> UIKit.UIImage?
}
extension UIColor {
  public static func bundled(_ name: Swift.String) -> UIKit.UIColor?
}
public typealias UIControlState = UIKit.UIControl.State
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class ButtonRxConfigurator<Button> : Dialog_iOS.ControlRxConfigurator<Button> where Button : UIKit.UIButton {
  public func title(for state: Dialog_iOS.UIControlState = .normal) -> RxCocoa.Binder<Swift.String?>
  public func image(for state: Dialog_iOS.UIControlState = .normal) -> RxCocoa.Binder<UIKit.UIImage?>
  override public func createBindings(to: Button) -> [RxSwift.Disposable]
  @objc deinit
}
extension Reactive where Base : QuartzCore.CALayer {
  public var borderColor: RxCocoa.Binder<UIKit.UIColor?> {
    get
  }
  public var backgroundColor: RxCocoa.Binder<UIKit.UIColor?> {
    get
  }
  public var opacity: RxCocoa.Binder<CoreGraphics.CGFloat> {
    get
  }
}
public enum CallActionViewButtonStyle {
  case normal
  case highlighted
  case selected
  public static func == (a: Dialog_iOS.CallActionViewButtonStyle, b: Dialog_iOS.CallActionViewButtonStyle) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol CallActionViewDesignProtocol {
  var iconSideLength: CoreGraphics.CGFloat { get }
  var buttonToLabelSpacing: CoreGraphics.CGFloat { get }
  var textFont: UIKit.UIFont { get }
  func textColor(for state: Dialog_iOS.UIControlState) -> UIKit.UIColor
  func backgroundColor(for state: Dialog_iOS.UIControlState) -> UIKit.UIColor?
  func tintColor(for state: Dialog_iOS.UIControlState) -> UIKit.UIColor?
  func borderColor(for state: Dialog_iOS.UIControlState) -> UIKit.UIColor?
  func borderWidth(for state: Dialog_iOS.UIControlState) -> CoreGraphics.CGFloat
}
extension CallActionViewDesignProtocol {
  public var iconSideLength: CoreGraphics.CGFloat {
    get
  }
  public var buttonToLabelSpacing: CoreGraphics.CGFloat {
    get
  }
  public var textFont: UIKit.UIFont {
    get
  }
  public func textColor(for state: Dialog_iOS.UIControlState) -> UIKit.UIColor
  public func backgroundColor(for state: Dialog_iOS.UIControlState) -> UIKit.UIColor?
  public func tintColor(for state: Dialog_iOS.UIControlState) -> UIKit.UIColor?
  public func borderWidth(for state: Dialog_iOS.UIControlState) -> CoreGraphics.CGFloat
  public func borderColor(for state: Dialog_iOS.UIControlState) -> UIKit.UIColor?
}
public struct CallMuteActionViewStyle : Dialog_iOS.CallActionViewDesignProtocol {
}
public struct CallVideoActionViewStyle : Dialog_iOS.CallActionViewDesignProtocol {
}
public struct CallSpeakerActionViewStyle : Dialog_iOS.CallActionViewDesignProtocol {
}
public struct CallAddActionViewStyle : Dialog_iOS.CallActionViewDesignProtocol {
}
public struct CallChatActionViewStyle : Dialog_iOS.CallActionViewDesignProtocol {
}
public struct CallDeclineActionViewStyle : Dialog_iOS.CallActionViewDesignProtocol {
  public func backgroundColor(for state: Dialog_iOS.UIControlState) -> UIKit.UIColor?
  public func tintColor(for state: Dialog_iOS.UIControlState) -> UIKit.UIColor?
}
@objc @_inheritsConvenienceInitializers public class CallActionView : UIKit.UIView {
  public func bindOptionallyTogglable(viewModel: Dialog_iOS.CallOptionallyTogglableActionViewModelProtocol, design: Dialog_iOS.CallActionViewDesignProtocol, usesMpVolumeControlButton: Swift.Bool = false)
  public func bind(viewModel: Dialog_iOS.CallActionViewModelProtocol, design: Dialog_iOS.CallActionViewDesignProtocol, usesMpVolumeControlButton: Swift.Bool = false)
  @objc override dynamic public func updateConstraints()
  @objc override dynamic public func layoutSubviews()
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
extension CallActionView {
  public func setEnabled(_ isEnabled: Swift.Bool)
  public func render(props: Dialog_iOS.CallActionViewProps)
}
extension Reactive where Base : Dialog_iOS.CallActionView {
  public var isEnabled: RxCocoa.Binder<Swift.Bool> {
    get
  }
}
public struct CallActionViewProps : Swift.Equatable {
  public var iconName: Swift.String
  public var title: Swift.String
  public var selected: Swift.Bool
  public static func == (a: Dialog_iOS.CallActionViewProps, b: Dialog_iOS.CallActionViewProps) -> Swift.Bool
}
public protocol CallActionViewModelProtocol {
  var userDidTap: RxSwift.AnyObserver<Swift.Void> { get }
  var setIsEnabled: RxSwift.AnyObserver<Swift.Bool> { get }
  var props: RxCocoa.Driver<Dialog_iOS.CallActionViewProps> { get }
  var isEnabled: RxCocoa.Driver<Swift.Bool> { get }
  var didTap: RxSwift.Observable<Swift.Void> { get }
  func createEventMetrics() -> [DialogMetrics.DialogMetricStoragableEvent]
}
public protocol CallOptionallyTogglableActionViewModelProtocol : Dialog_iOS.CallActionViewModelProtocol {
  var isTogglable: RxSwift.Observable<Swift.Bool> { get }
}
public class CallActionViewModel : Dialog_iOS.CallActionViewModelProtocol {
  final public let userDidTap: RxSwift.AnyObserver<Swift.Void>
  final public let props: RxCocoa.Driver<Dialog_iOS.CallActionViewProps>
  final public let setIsEnabled: RxSwift.AnyObserver<Swift.Bool>
  final public let isEnabled: RxCocoa.Driver<Swift.Bool>
  final public let didTap: RxSwift.Observable<Swift.Void>
  public init(props: Dialog_iOS.CallActionViewProps)
  public func createEventMetrics() -> [DialogMetrics.DialogMetricStoragableEvent]
  @objc deinit
}
public class CallTogglableActionViewModel : Dialog_iOS.CallActionViewModel {
  public enum State {
    case disabled
    case enabled
    public static func == (a: Dialog_iOS.CallTogglableActionViewModel.State, b: Dialog_iOS.CallTogglableActionViewModel.State) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  final public let allowedStates: RxRelay.BehaviorRelay<Swift.Set<Dialog_iOS.CallTogglableActionViewModel.State>>
  final public let _state: RxRelay.BehaviorRelay<Dialog_iOS.CallTogglableActionViewModel.State>
  public init(isOn: Swift.Bool, closure: @escaping (Dialog_iOS.CallTogglableActionViewModel.State) -> Dialog_iOS.CallActionViewProps)
  override public init(props: Dialog_iOS.CallActionViewProps)
  @objc deinit
}
final public class CallAudioActionViewModel : Dialog_iOS.CallTogglableActionViewModel {
  public init(isOn: Swift.Bool)
  override final public func createEventMetrics() -> [DialogMetrics.DialogMetricStoragableEvent]
  override public init(isOn: Swift.Bool, closure: @escaping (Dialog_iOS.CallTogglableActionViewModel.State) -> Dialog_iOS.CallActionViewProps)
  @objc deinit
}
final public class CallVideoActionViewModel : Dialog_iOS.CallTogglableActionViewModel {
  public init(isOn: Swift.Bool)
  override final public func createEventMetrics() -> [DialogMetrics.DialogMetricStoragableEvent]
  override public init(isOn: Swift.Bool, closure: @escaping (Dialog_iOS.CallTogglableActionViewModel.State) -> Dialog_iOS.CallActionViewProps)
  @objc deinit
}
final public class CallSpeakerActionViewModel : Dialog_iOS.CallActionViewModel, Dialog_iOS.CallOptionallyTogglableActionViewModelProtocol {
  final public let isTogglable: RxSwift.Observable<Swift.Bool>
  public init(mediaConfigService: DialogProtocols.MediaConfigServiceProtocol)
  override public init(props: Dialog_iOS.CallActionViewProps)
  @objc deinit
}
final public class CallAddActionViewModel : Dialog_iOS.CallActionViewModel {
  public init()
  override public init(props: Dialog_iOS.CallActionViewProps)
  @objc deinit
}
final public class CallDeclineActionViewModel : Dialog_iOS.CallActionViewModel {
  public init()
  override public init(props: Dialog_iOS.CallActionViewProps)
  @objc deinit
}
final public class CallChatActionViewModel : Dialog_iOS.CallActionViewModel {
  public init()
  override public init(props: Dialog_iOS.CallActionViewProps)
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class CallChoiceAlertControllerFactory {
  public static func alertController(availableBeginCallTypes: [DialogProtocols.AccessibleCallType], handler: @escaping (Dialog_iOS.BeginCallActionResponse) -> ()) -> UIKit.UIAlertController
  @objc deinit
}
public enum CallKitAdapterError : Swift.Error {
  case noCurrentCallModel
  case callModelAlreadyExist
  public static func == (a: Dialog_iOS.CallKitAdapterError, b: Dialog_iOS.CallKitAdapterError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
extension CXAction : DialogCalls.CallAction {
}
extension CXHandle {
  public static let dialogUnknownUser: CallKit.CXHandle
}
@objc public class CallKitAdapter : ObjectiveC.NSObject, CallKit.CXCallObserverDelegate, DialogCalls.CallKitAdapterProtocol {
  public static let callKitShowTimeInSeconds: Swift.Int
  public init(mediaConfigService: DialogProtocols.MediaConfigServiceProtocol, provider: CallKit.CXProvider)
  public func reset()
  public func assignCallsServiceDelegate(_ delegate: DialogCalls.CallsServiceProtocol?)
  public func requestMuted(uuid: Foundation.UUID, isMuted: Swift.Bool)
  public func bakeHandleAndDisplayName(forUser user: DialogProtocols.DialogUser) -> (Swift.String, Swift.String)
  public func bakeHandleAndDisplayName(forParameters params: DialogCalls.MappedCallParameters) -> (Swift.String, Swift.String)
  @objc override dynamic public init()
  @objc deinit
}
extension CallKitAdapter {
  public func reportNewIncomingCallCame(uuid: Foundation.UUID, handleValue: Swift.String, displayName: Swift.String, hasVideo: Swift.Bool, voipCompletion: @escaping (Swift.Error?) -> Swift.Void)
  public func startOutboundCall(uuid: Foundation.UUID, handleValue: Swift.String, displayName: Swift.String, hasVideo: Swift.Bool)
  public func reportOutboundCallConnected(uuid: Foundation.UUID, atDate date: Foundation.Date?)
  public func reportOutboundCallStartedConnecting(uuid: Foundation.UUID, atDate date: Foundation.Date?)
  public func requestEndCall(uuid: Foundation.UUID, completion: ((Swift.Error?) -> Swift.Void)?)
  public func reportCallEnded(uuid: Foundation.UUID, reason: DialogCalls.CallEndedReason)
  public func callKitUpdateReport(uuid: Foundation.UUID, update: CallKit.CXCallUpdate)
}
extension CallKitAdapter {
  @objc dynamic public func callObserver(_ callObserver: CallKit.CXCallObserver, callChanged call: CallKit.CXCall)
}
extension CallKitAdapter : CallKit.CXProviderDelegate {
  @objc dynamic public func providerDidReset(_ provider: CallKit.CXProvider)
  @objc dynamic public func provider(_ provider: CallKit.CXProvider, perform action: CallKit.CXStartCallAction)
  @objc dynamic public func provider(_ provider: CallKit.CXProvider, perform action: CallKit.CXAnswerCallAction)
  @objc dynamic public func provider(_ provider: CallKit.CXProvider, perform action: CallKit.CXEndCallAction)
  @objc dynamic public func provider(_ provider: CallKit.CXProvider, timedOutPerforming action: CallKit.CXAction)
  @objc dynamic public func provider(_ provider: CallKit.CXProvider, perform action: CallKit.CXSetMutedCallAction)
  @objc dynamic public func provider(_ provider: CallKit.CXProvider, perform action: CallKit.CXSetGroupCallAction)
  @objc dynamic public func provider(_ provider: CallKit.CXProvider, perform action: CallKit.CXSetHeldCallAction)
  @objc dynamic public func provider(_ provider: CallKit.CXProvider, didActivate audioSession: AVFoundation.AVAudioSession)
  @objc dynamic public func provider(_ provider: CallKit.CXProvider, didDeactivate audioSession: AVFoundation.AVAudioSession)
}
@_hasMissingDesignatedInitializers public class CallKitAdapterForSimulator : DialogCalls.CallKitAdapterProtocol {
  public func bakeHandleAndDisplayName(forUser user: DialogProtocols.DialogUser) -> (Swift.String, Swift.String)
  public func bakeHandleAndDisplayName(forParameters params: DialogCalls.MappedCallParameters) -> (Swift.String, Swift.String)
  public func assignCallsServiceDelegate(_ delegate: DialogCalls.CallsServiceProtocol?)
  public func reportNewIncomingCallCame(uuid: Foundation.UUID, handleValue: Swift.String, displayName: Swift.String, hasVideo: Swift.Bool, voipCompletion: @escaping (Swift.Error?) -> Swift.Void)
  public func startOutboundCall(uuid: Foundation.UUID, handleValue: Swift.String, displayName: Swift.String, hasVideo: Swift.Bool)
  public func reportOutboundCallConnected(uuid: Foundation.UUID, atDate date: Foundation.Date?)
  public func reportOutboundCallStartedConnecting(uuid: Foundation.UUID, atDate date: Foundation.Date?)
  public func requestEndCall(uuid: Foundation.UUID, completion: ((Swift.Error?) -> Swift.Void)?)
  public func reportCallEnded(uuid: Foundation.UUID, reason: DialogCalls.CallEndedReason)
  public func requestMuted(uuid: Foundation.UUID, isMuted: Swift.Bool)
  @objc deinit
}
public class CallKitCallModel {
  public init(identifier: Foundation.UUID, userId: DialogProtocols.DialogUserId?, title: Swift.String?, phone: Swift.String?, hasVideo: Swift.Bool, direction: DialogProtocols.CallDirection)
  @objc deinit
}
public enum CallTryResult {
  case success
  case inTheSameCall
  case cancelled
  case invalidArgument
  case error
  public static func == (a: Dialog_iOS.CallTryResult, b: Dialog_iOS.CallTryResult) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol CallsGatewayServiceProtocol {
  typealias Completion = (Dialog_iOS.CallTryResult) -> ()
  typealias ConferenceParsedLink = [Swift.String : Swift.String]
  func outboundCall(user: DialogProtocols.DialogUser, type: DialogProtocols.AccessibleCallType, completion: Self.Completion?)
  func outboundCall(conference: Self.ConferenceParsedLink, url: Foundation.URL, completion: Self.Completion?)
}
extension CallsGatewayServiceProtocol {
  public func outboundCall(user: DialogProtocols.DialogUser, type: DialogProtocols.AccessibleCallType, completion: Self.Completion? = nil)
  public func outboundCall(conference: Self.ConferenceParsedLink, url: Foundation.URL, completion: Self.Completion? = nil)
}
public typealias CallsHistoryRouter = XCoordinator.WeakRouter<Dialog_iOS.CallsHistoryRoute>
public typealias AnyCallsHistoryCoordinator = Dialog_iOS.CallsHistoryCoordinator.AnyCoordinatorType
public enum CallsHistoryRoute : XCoordinator.Route {
  case list
  case userProfile(Dialog_iOS.UserProfileRouteArgs)
}
final public class CallsHistoryCoordinator : XCoordinator.NavigationCoordinator<Dialog_iOS.CallsHistoryRoute> {
  public init(container: Swinject.Container, rootViewController: UIKit.UINavigationController)
  override final public func prepareTransition(for route: Dialog_iOS.CallsHistoryRoute) -> XCoordinator.NavigationTransition
  @objc deinit
  override public init(rootViewController: XCoordinator.NavigationCoordinator<Dialog_iOS.CallsHistoryRoute>.RootViewController = super, initialRoute: Dialog_iOS.CallsHistoryRoute? = super)
  override public init(rootViewController: XCoordinator.NavigationCoordinator<Dialog_iOS.CallsHistoryRoute>.RootViewController = super, root: XCoordinator.Presentable)
}
@_inheritsConvenienceInitializers final public class CallsHistoryScene : Dialog_iOS.Scene<Swift.Void, UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.CallsHistoryScene.Builder
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<Swift.Void, UIKit.UIViewController, Dialog_iOS.CallsHistoryViewModelProtocol> {
    override final public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>) -> Dialog_iOS.CallsHistoryViewModelProtocol
    override final public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>, viewModel: Dialog_iOS.CallsHistoryViewModelProtocol) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<Swift.Void, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
public typealias CallsHistorySearchResultsViewController = UIKit.UIViewController
@_inheritsConvenienceInitializers final public class CallsHistorySearchScene : Dialog_iOS.Scene<Swift.Void, Dialog_iOS.CallsHistorySearchResultsViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.AnySceneBuilder<Dialog_iOS.CallsHistorySearchResultsViewController, Swift.Void>
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<Swift.Void, Dialog_iOS.CallsHistorySearchResultsViewController, Dialog_iOS.CallsHistorySearchViewModelProtocol> {
    override final public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>) -> Dialog_iOS.CallsHistorySearchViewModelProtocol
    override final public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>, viewModel: Dialog_iOS.CallsHistorySearchViewModelProtocol) -> Dialog_iOS.CallsHistorySearchResultsViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<Swift.Void, Dialog_iOS.CallsHistorySearchResultsViewController>.Builder = super, resolver: Swinject.Resolver)
}
public struct CallsHistorySearchSection {
  public typealias Identity = Swift.String
  public typealias Item = Dialog_iOS.DUICellViewModel
  public var items: [Dialog_iOS.CallsHistorySearchSection.Item]
  public let title: Swift.String
  public let identity: Dialog_iOS.CallsHistorySearchSection.Identity
  public init(items: [Dialog_iOS.CallsHistorySearchSection.Item], title: Swift.String, identity: Swift.String)
}
extension CallsHistorySearchSection : Differentiator.AnimatableSectionModelType {
  public init(original: Dialog_iOS.CallsHistorySearchSection, items: [Dialog_iOS.DUICellViewModel])
}
extension CallsHistorySearchSection : Swift.Equatable {
  public static func == (a: Dialog_iOS.CallsHistorySearchSection, b: Dialog_iOS.CallsHistorySearchSection) -> Swift.Bool
}
public struct CallsHistorySearchSectionsBuilderDependencies {
}
@_hasMissingDesignatedInitializers public class CallsHistorySearchSectionsBuilder {
  public struct DataState : Swift.Equatable {
    public static func == (a: Dialog_iOS.CallsHistorySearchSectionsBuilder.DataState, b: Dialog_iOS.CallsHistorySearchSectionsBuilder.DataState) -> Swift.Bool
  }
  public struct Argument {
  }
  public func build(_ argument: Dialog_iOS.CallsHistorySearchSectionsBuilder.Argument) -> [Dialog_iOS.CallsHistorySearchSection]
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers final public class CallsHistorySearchViewController : UIKit.UITableViewController, UIKit.UISearchResultsUpdating {
  public init(viewModel: Dialog_iOS.CallsHistorySearchViewModelProtocol, configuratorService: Dialog_iOS.DUICellConfiguratorServiceProtocol)
  @objc override final public func viewDidLoad()
  @objc final public func updateSearchResults(for searchController: UIKit.UISearchController)
  @objc override final public func tableView(_ tableView: UIKit.UITableView, viewForHeaderInSection section: Swift.Int) -> UIKit.UIView?
  @objc override dynamic public init(style: UIKit.UITableView.Style)
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc deinit
}
public protocol CallsHistorySearchViewModelProtocol {
  typealias Sections = [Dialog_iOS.CallsHistorySearchSection]
  var beginCallChoiceViewModel: Dialog_iOS.BeginCallTypeChoiceViewModelProtocol { get }
  var emptyStateViewModel: Dialog_iOS.DUIEmptyStateViewModelProtocol { get }
  var searchQuery: RxSwift.AnyObserver<Swift.String?> { get }
  var openUser: RxSwift.AnyObserver<Dialog_iOS.UserProfileRouteArgs> { get }
  var startCall: RxSwift.AnyObserver<DialogProtocols.DialogHistoryCallGroup> { get }
  var sections: RxCocoa.Driver<Self.Sections> { get }
}
@_hasMissingDesignatedInitializers final public class CallsHistorySearchViewModel : Dialog_iOS.CallsHistorySearchViewModelProtocol {
  public struct Dependencies {
    public let beginCallChoiceViewModel: Dialog_iOS.BeginCallTypeChoiceViewModelProtocol
    public let emptyStateViewModel: Dialog_iOS.DUIEmptyStateViewModelProtocol
    public let eventBus: DialogProtocols.EventBusServiceProtocol
    public let routerService: Dialog_iOS.RouterServiceProtocol
    public let callSearcher: Dialog_iOS.DialogCallsSimpleSearcherProtocol
    public let combinedSearcher: DialogSearching.CombinedSearchServiceProtocol
  }
  final public let searchQuery: RxSwift.AnyObserver<Swift.String?>
  final public let beginCallChoiceViewModel: Dialog_iOS.BeginCallTypeChoiceViewModelProtocol
  final public var emptyStateViewModel: Dialog_iOS.DUIEmptyStateViewModelProtocol
  final public let openUser: RxSwift.AnyObserver<Dialog_iOS.UserProfileRouteArgs>
  final public let startCall: RxSwift.AnyObserver<DialogProtocols.DialogHistoryCallGroup>
  final public var sections: RxCocoa.Driver<[Dialog_iOS.CallsHistorySearchSection]>
  @objc deinit
}
public enum CallsHistorySegmentType : Swift.Int {
  case all
  case missed
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public enum CallsHistoryEditingOptionType {
  case edit
  case done
  case delete
  public static func == (a: Dialog_iOS.CallsHistoryEditingOptionType, b: Dialog_iOS.CallsHistoryEditingOptionType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public enum CallsHistorySelectType {
  case select(DialogProtocols.DialogHistoryCallGroup)
  case deselect(DialogProtocols.DialogHistoryCallGroup)
}
public enum CallsHistoryViewModelSearch {
  case none
  case heavy((UIKit.UIViewController & UIKit.UISearchResultsUpdating))
}
public enum MissedCountUpdatePolicy {
  case force
  case onIncrease
  case ignore
  public static func == (a: Dialog_iOS.MissedCountUpdatePolicy, b: Dialog_iOS.MissedCountUpdatePolicy) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol CallsHistoryViewModelProtocol {
  var itemsCount: Swift.Int { get }
  var themeService: Dialog_iOS.AppThemeService { get }
  var userSelectSegment: RxSwift.AnyObserver<Dialog_iOS.CallsHistorySegmentType> { get }
  var loadNextPage: RxSwift.AnyObserver<Swift.Void> { get }
  var callsGroupSelectAction: RxSwift.AnyObserver<Dialog_iOS.CallsHistorySelectType> { get }
  var userTappedEditing: RxSwift.AnyObserver<Dialog_iOS.CallsHistoryEditingOptionType> { get }
  var userConfirmSingleDelete: RxSwift.AnyObserver<DialogProtocols.DialogHistoryCallGroup> { get }
  var userConfirmMultiDelete: RxSwift.AnyObserver<Swift.Void> { get }
  var openContacts: RxSwift.AnyObserver<Swift.Void> { get }
  var sections: RxCocoa.Driver<[Dialog_iOS.DUISimpleSection]> { get }
  var isEditing: RxCocoa.Driver<Swift.Bool> { get }
  var isDeletingEnabled: RxCocoa.Driver<Swift.Bool> { get }
  var confirmDeletions: RxCocoa.Driver<Swift.Int> { get }
  var isLoadingNextPage: RxCocoa.Driver<Swift.Bool> { get }
  var emptyStateShown: RxCocoa.Driver<Swift.Bool> { get }
  var hasMissed: RxCocoa.Driver<Swift.Bool> { get }
  var updateMissedCount: RxCocoa.Driver<Dialog_iOS.MissedCountUpdatePolicy> { get }
  var searchModel: Dialog_iOS.CallsHistoryViewModelSearch { get }
  func markMissedCountViewed()
  func updateMissedCountPolicy(_ policy: Dialog_iOS.MissedCountUpdatePolicy)
}
public protocol CallVideoSourceViewModelAVDriven {
  var setSession: RxSwift.AnyObserver<AVFoundation.AVCaptureSession?> { get }
  var captureSession: RxCocoa.Driver<AVFoundation.AVCaptureSession?> { get }
}
public class CallVideoSourceViewModelAVDrivenBase : Dialog_iOS.CallVideoSourceViewModelAVDriven {
  public var setSession: RxSwift.AnyObserver<AVFoundation.AVCaptureSession?> {
    get
  }
  public var captureSession: RxCocoa.Driver<AVFoundation.AVCaptureSession?> {
    get
  }
  public init()
  @objc deinit
}
public struct CallLocalVideoOverlayViewStyle {
}
extension CallLocalVideoOverlayViewStyle {
  public static let `default`: Dialog_iOS.CallLocalVideoOverlayViewStyle
}
@objc @_hasMissingDesignatedInitializers public class CallVideoSourceViewAVDriven : UIKit.UIView {
  final public let overlayView: Dialog_iOS.CallLocalVideoOverlayView
  public init(viewModel: Dialog_iOS.CallVideoSourceViewModelAVDriven, videoContentMode: Dialog_iOS.CallVideoViewContentMode, overlayStyle: Dialog_iOS.CallLocalVideoOverlayViewStyle = .default)
  @objc override dynamic public func layoutSubviews()
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
}
extension Reactive where Base : Dialog_iOS.CallVideoSourceViewAVDriven {
  public var captureSession: RxCocoa.Binder<AVFoundation.AVCaptureSession?> {
    get
  }
}
@objc @_hasMissingDesignatedInitializers public class CallLocalVideoOverlayView : UIKit.UIView {
  public init(style: Dialog_iOS.CallLocalVideoOverlayViewStyle)
  @objc override dynamic public func layoutSubviews()
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
}
public protocol CallVideoSourceViewModelRTCDriven {
  var setVideoTrack: RxSwift.AnyObserver<WebRTC.RTCVideoTrack?> { get }
  var videoTrack: RxCocoa.Driver<WebRTC.RTCVideoTrack?> { get }
  var setVideoPosition: RxSwift.AnyObserver<DialogCalls.LocalVideoPositionState> { get }
  var isVideoFrontOriented: RxCocoa.Driver<Swift.Bool> { get }
  var isHidden: RxCocoa.Driver<Swift.Bool> { get }
}
@_hasMissingDesignatedInitializers public class CallVideoSourceViewModelRTCDrivenBase : Dialog_iOS.CallVideoSourceViewModelRTCDriven {
  public var setVideoTrack: RxSwift.AnyObserver<WebRTC.RTCVideoTrack?> {
    get
  }
  public var videoTrack: RxCocoa.Driver<WebRTC.RTCVideoTrack?> {
    get
  }
  public var setVideoPosition: RxSwift.AnyObserver<DialogCalls.LocalVideoPositionState>
  public var isVideoFrontOriented: RxCocoa.Driver<Swift.Bool>
  public var isHidden: RxCocoa.Driver<Swift.Bool>
  @objc deinit
}
@_hasMissingDesignatedInitializers public class CallLocalVideoSourceViewModelRTCDriven : Dialog_iOS.CallVideoSourceViewModelRTCDrivenBase {
  public init()
  @objc deinit
}
@_hasMissingDesignatedInitializers public class CallRemoteVideoSourceViewModelRTCDriven : Dialog_iOS.CallVideoSourceViewModelRTCDrivenBase {
  public init()
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers public class CallVideoSourceViewRTCDriven : UIKit.UIView {
  final public let overlayView: Dialog_iOS.CallLocalVideoOverlayView
  public var rendererRectifier: Dialog_iOS.VideoRendererRectifier?
  public var targetSize: CoreGraphics.CGSize {
    get
    set
  }
  public init(viewModel: Dialog_iOS.CallVideoSourceViewModelRTCDriven, videoContentMode: Dialog_iOS.CallVideoViewContentMode, overlayStyle: Dialog_iOS.CallLocalVideoOverlayViewStyle = .default)
  @objc override dynamic public func layoutSubviews()
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
}
extension CallVideoSourceViewRTCDriven {
  public func clear()
}
extension Reactive where Base : Dialog_iOS.CallVideoSourceViewRTCDriven {
  public var videoTrack: RxCocoa.Binder<WebRTC.RTCVideoTrack?> {
    get
  }
}
extension CallVideoSourceViewRTCDriven : WebRTC.RTCVideoViewDelegate {
  @objc dynamic public func videoView(_ videoView: WebRTC.RTCVideoRenderer, didChangeVideoSize size: CoreGraphics.CGSize)
}
public enum CallVideoViewSource {
  case rtcDriven(viewModel: Dialog_iOS.CallVideoSourceViewModelRTCDriven)
  case avDriven(viewModel: Dialog_iOS.CallVideoSourceViewModelAVDriven)
}
public protocol CallVideoView : AnyObject {
  var videoSource: Dialog_iOS.CallVideoViewSource { get }
  var isShown: RxSwift.AnyObserver<Swift.Bool> { get }
}
public enum VideoViewSizingStrategy {
  case flexibleSide(withMaxSide: CoreGraphics.CGFloat)
  case fixedSize(constant: CoreGraphics.CGSize)
}
public typealias VideoRendererRectifier = (CoreGraphics.CGRect, CoreGraphics.CGSize) -> CoreGraphics.CGRect
@objc @_hasMissingDesignatedInitializers final public class CallVideoViewBase : UIKit.UIView, Dialog_iOS.CallVideoView {
  final public let videoSource: Dialog_iOS.CallVideoViewSource
  final public let isShown: RxSwift.AnyObserver<Swift.Bool>
  final public let setAspectRatio: RxSwift.AnyObserver<CoreGraphics.CGFloat>
  final public let disposeBag: RxSwift.DisposeBag
  final public var retainBag: RxSwift.DisposeBag
  public init(videoSource: Dialog_iOS.CallVideoViewSource, sizingStrategy: Dialog_iOS.VideoViewSizingStrategy, design: Dialog_iOS.CallVideoViewDesignProtocol, rendererRectifier: Dialog_iOS.VideoRendererRectifier? = nil)
  @objc override final public func layoutSubviews()
  @objc override final public var intrinsicContentSize: CoreGraphics.CGSize {
    @objc get
  }
  @objc override final public func sizeThatFits(_ size: CoreGraphics.CGSize) -> CoreGraphics.CGSize
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
public enum CallVideoViewContentMode {
  case fit
  case fill
  public static func == (a: Dialog_iOS.CallVideoViewContentMode, b: Dialog_iOS.CallVideoViewContentMode) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol CallVideoViewDesignProtocol {
  var shadow: UIKit.NSShadow? { get }
  var cornerType: Dialog_iOS.CornerRadiusType { get }
  var contentMode: Dialog_iOS.CallVideoViewContentMode { get }
  var blurEffectStyle: UIKit.UIBlurEffect.Style { get }
  var isOverlayViewHidden: Swift.Bool { get }
}
public struct CallVideoViewFullScreenStyle : Dialog_iOS.CallVideoViewDesignProtocol {
  public let shadow: UIKit.NSShadow?
  public let cornerType: DialogSharedComponents.CornerRadiusType
  public let contentMode: Dialog_iOS.CallVideoViewContentMode
  public let blurEffectStyle: UIKit.UIBlurEffect.Style
  public var isOverlayViewHidden: Swift.Bool {
    get
  }
}
public struct CallVideoViewContainerStyle : Dialog_iOS.CallVideoViewDesignProtocol {
  public var shadow: UIKit.NSShadow? {
    get
  }
  public let cornerType: DialogSharedComponents.CornerRadiusType
  public let contentMode: Dialog_iOS.CallVideoViewContentMode
  public let blurEffectStyle: UIKit.UIBlurEffect.Style
  public var isOverlayViewHidden: Swift.Bool {
    get
  }
}
extension Reactive where Base : QuartzCore.CAShapeLayer {
  public var strokeEnd: RxCocoa.Binder<CoreGraphics.CGFloat> {
    get
  }
}
public enum AttachmentCategory : Swift.CaseIterable, Swift.Hashable, Swift.Comparable {
  case media
  case documents
  case urls
  case audios
  case voices
  public static func < (lhs: Dialog_iOS.AttachmentCategory, rhs: Dialog_iOS.AttachmentCategory) -> Swift.Bool
  public static func == (a: Dialog_iOS.AttachmentCategory, b: Dialog_iOS.AttachmentCategory) -> Swift.Bool
  public typealias AllCases = [Dialog_iOS.AttachmentCategory]
  public static var allCases: [Dialog_iOS.AttachmentCategory] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public struct CategoryItem : Swift.Equatable, DialogProtocols.BaseStruct {
  public static func == (lhs: Dialog_iOS.CategoryItem, rhs: Dialog_iOS.CategoryItem) -> Swift.Bool
}
extension CategoryItem : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension CategoryItem : Swift.Comparable {
  public static func < (lhs: Dialog_iOS.CategoryItem, rhs: Dialog_iOS.CategoryItem) -> Swift.Bool
}
public enum ChangeAvatarResult {
  case removed
  case changed(UIKit.UIImage)
}
open class ChangeAvatarOperation : Dialog_iOS.DLGAsyncOperation<Dialog_iOS.ChangeAvatarResult>, UIKit.UINavigationControllerDelegate {
  final public let viewController: UIKit.UIViewController
  public var isPhotoRemovable: Swift.Bool
  public var cropNeeded: Swift.Bool
  public var cameraEnabled: Swift.Bool
  public var isUserAvatar: Swift.Bool
  public init(viewController: UIKit.UIViewController)
  @objc deinit
  override open func onDidStart()
  public func finish(error: Swift.Error?)
  @objc override dynamic public init()
}
extension ChangeAvatarOperation : UIKit.UIImagePickerControllerDelegate {
  @objc dynamic public func imagePickerController(_ picker: UIKit.UIImagePickerController, didFinishPickingMediaWithInfo info: [UIKit.UIImagePickerController.InfoKey : Any])
  @objc dynamic open func imagePickerControllerDidCancel(_ picker: UIKit.UIImagePickerController)
}
extension ChangeAvatarOperation : RSKImageCropper.RSKImageCropViewControllerDelegate {
  @objc dynamic open func imageCropViewController(_ controller: RSKImageCropper.RSKImageCropViewController, didCropImage croppedImage: UIKit.UIImage, usingCropRect cropRect: CoreGraphics.CGRect, rotationAngle: CoreGraphics.CGFloat)
  @objc dynamic open func imageCropViewControllerDidCancelCrop(_ controller: RSKImageCropper.RSKImageCropViewController)
}
extension ChangeAvatarOperation : Photos.PHPhotoLibraryChangeObserver {
  @objc dynamic public func photoLibraryDidChange(_ changeInstance: Photos.PHChange)
}
public protocol ChannelAccessoryViewStyle {
  var controlsFont: UIKit.UIFont { get }
  var buttonsColor: UIKit.UIColor { get }
  var textColor: UIKit.UIColor { get }
  var backgroundColor: UIKit.UIColor { get }
  var textInsets: UIKit.UIEdgeInsets { get }
}
public struct DefaultChannelAccessoryViewStyle : Dialog_iOS.ChannelAccessoryViewStyle {
  public var controlsFont: UIKit.UIFont
  public var buttonsColor: UIKit.UIColor
  public var textColor: UIKit.UIColor
  public var backgroundColor: UIKit.UIColor
  public var textInsets: UIKit.UIEdgeInsets
}
@objc @_hasMissingDesignatedInitializers public class ChannelAccessoryView : UIKit.UIView {
  public init(style: Dialog_iOS.ChannelAccessoryViewStyle)
  public func bind(viewModel: Dialog_iOS.ChannelAccessoryViewModelProtocol)
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
}
public protocol ChannelAccessoryViewModelProtocol {
  var showMuteButton: RxCocoa.Driver<Swift.Bool> { get }
  var muteButtonTitle: RxCocoa.Driver<Swift.String> { get }
  var muteAction: RxSwift.AnyObserver<Swift.Void> { get }
  var showSubscribeButton: RxCocoa.Driver<Swift.Bool> { get }
  var subscribeButtonTitle: RxCocoa.Driver<Swift.String> { get }
  var subscribeAction: RxSwift.AnyObserver<Swift.Void> { get }
  var showPrivateChannelLabel: RxCocoa.Driver<Swift.Bool> { get }
  var privateChannelLabelText: RxCocoa.Driver<Swift.String> { get }
  var needShowChannelAccessoryView: RxCocoa.Driver<Swift.Bool> { get }
}
public class ChannelAccessoryViewModel : Dialog_iOS.ChannelAccessoryViewModelProtocol {
  final public let showMuteButton: RxCocoa.Driver<Swift.Bool>
  final public let muteButtonTitle: RxCocoa.Driver<Swift.String>
  final public let muteAction: RxSwift.AnyObserver<Swift.Void>
  final public let showSubscribeButton: RxCocoa.Driver<Swift.Bool>
  final public let subscribeButtonTitle: RxCocoa.Driver<Swift.String>
  final public let subscribeAction: RxSwift.AnyObserver<Swift.Void>
  final public let showPrivateChannelLabel: RxCocoa.Driver<Swift.Bool>
  final public let privateChannelLabelText: RxCocoa.Driver<Swift.String>
  final public let needShowChannelAccessoryView: RxCocoa.Driver<Swift.Bool>
  public init(peer: DialogProtocols.DialogPeer, activeUserId: DialogProtocols.DialogUserId, eventBus: DialogProtocols.EventBusServiceProtocol, muteService: DialogMuteSettingsService.DialogMuteSettingsServiceProtocol, groupService: DialogProtocols.DialogGroupServiceProtocol)
  @objc deinit
}
public struct ReactionViewModel : Differentiator.IdentifiableType, Swift.Equatable {
  public var identity: Swift.String {
    get
  }
  public let value: Swift.String
  public let isSelected: Swift.Bool
  public typealias Identity = Swift.String
  public var size: CoreGraphics.CGSize {
    get
  }
  public static func == (lhs: Dialog_iOS.ReactionViewModel, rhs: Dialog_iOS.ReactionViewModel) -> Swift.Bool
}
public struct ReactionSection : Differentiator.SectionModelType {
  public let items: [Dialog_iOS.ReactionViewModel]
  public init(items: [Dialog_iOS.ReactionViewModel])
  public init(original: Dialog_iOS.ReactionSection, items: [Dialog_iOS.ReactionViewModel])
  public typealias Item = Dialog_iOS.ReactionViewModel
}
public protocol ChooseReactionViewModelProtocol {
  var sections: RxCocoa.Driver<[Dialog_iOS.ReactionSection]> { get }
  var choose: RxSwift.AnyObserver<Swift.String> { get }
  var mid: DialogProtocols.DialogUUID { get }
  var themeService: Dialog_iOS.AppThemeService { get }
}
public struct ChooseReactionViewModel : Dialog_iOS.ChooseReactionViewModelProtocol {
  public let sections: RxCocoa.Driver<[Dialog_iOS.ReactionSection]>
  public let choose: RxSwift.AnyObserver<Swift.String>
  public var mid: DialogProtocols.DialogUUID {
    get
  }
  public let themeService: Dialog_iOS.AppThemeService
}
extension Collection {
  public typealias Element = Self.Iterator.Element
  public func safeIndex(after index: Self.Index) -> Self.Index?
}
extension Collection where Self.Element : Swift.Equatable, Self.Index == Swift.Int {
  public func item(after item: Self.Element) -> Self.Element?
}
extension BidirectionalCollection {
  public typealias Element = Self.Iterator.Element
  public func safeIndex(before index: Self.Index) -> Self.Index?
}
extension BidirectionalCollection where Self.Element : Swift.Equatable, Self.Index == Swift.Int {
  public func item(before item: Self.Element) -> Self.Element?
}
public protocol CombinedSearchServiceFilterProtocol : DialogSearching.CombinedSearchStateModifierProtocol {
}
extension CombinedSearchRemoteDuplicatesFilter : Dialog_iOS.CombinedSearchServiceFilterProtocol {
}
@objc @_inheritsConvenienceInitializers open class CommonAppDelegate : UIKit.UIResponder {
  public var supportedInterfaceOrientations: UIKit.UIInterfaceOrientationMask
  final public let container: Dialog_iOS.DialogContainer
  final public let disposeBag: RxSwift.DisposeBag
  @objc(application:supportedInterfaceOrientationsForWindow:) public func application(_ application: UIKit.UIApplication, supportedInterfaceOrientationsFor window: UIKit.UIWindow?) -> UIKit.UIInterfaceOrientationMask
  open func applicationWillEnterForeground(_ application: UIKit.UIApplication)
  @objc deinit
  @objc override dynamic public init()
}
extension ConcurrentDispatchQueueScheduler {
  convenience public init(qos: Dispatch.DispatchQoS, labelPrefix: Swift.String = "", leeway: Dispatch.DispatchTimeInterval = DispatchTimeInterval.nanoseconds(0))
}
public typealias ContactsRouter = XCoordinator.WeakRouter<Dialog_iOS.ContactsRoute>
public typealias AnyContactsCoordinator = Dialog_iOS.ContactsCoordinator.AnyCoordinatorType
public enum ContactsRoute : XCoordinator.Route {
  case main
  case userProfile(Dialog_iOS.UserProfileRouteArgs)
}
final public class ContactsCoordinator : XCoordinator.NavigationCoordinator<Dialog_iOS.ContactsRoute> {
  public init(container: Swinject.Container, rootViewController: UIKit.UINavigationController)
  override final public func prepareTransition(for route: Dialog_iOS.ContactsRoute) -> XCoordinator.NavigationTransition
  @objc deinit
  override public init(rootViewController: XCoordinator.NavigationCoordinator<Dialog_iOS.ContactsRoute>.RootViewController = super, initialRoute: Dialog_iOS.ContactsRoute? = super)
  override public init(rootViewController: XCoordinator.NavigationCoordinator<Dialog_iOS.ContactsRoute>.RootViewController = super, root: XCoordinator.Presentable)
}
extension Theme.Domain {
  public static let sharedContactsListFooterStyle: Dialog_iOS.Theme.Domain
}
extension Theme.Keys.SharedContactsListFooterStyle {
  public static let separatorWidth: Dialog_iOS.Theme.Keys.SharedContactsListFooterStyle
  public static let separatorHeight: Dialog_iOS.Theme.Keys.SharedContactsListFooterStyle
  public static let separatorInsets: Dialog_iOS.Theme.Keys.SharedContactsListFooterStyle
  public static let separatorColor: Dialog_iOS.Theme.Keys.SharedContactsListFooterStyle
}
extension Theme.Keys {
  public struct SharedContactsListFooterStyle : Dialog_iOS.DomainSpecificKey, Swift.RawRepresentable {
    public static var domain: Dialog_iOS.Theme.Domain
    public var domainInternalId: Swift.String {
      get
    }
    public let rawValue: Swift.String
    public init(rawValue: Swift.String)
    public typealias RawValue = Swift.String
  }
}
extension Theme.Defaults {
  public static let sharedContactsListFooterStyle: DialogSharedComponents.Subtheme<Dialog_iOS.Theme.Keys.SharedContactsListFooterStyle>
}
@objc final public class ContactsListFooterView : UIKit.UIView {
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  public init(frame: CoreGraphics.CGRect, staticTheme: DialogSharedComponents.Subtheme<Dialog_iOS.Theme.Keys.SharedContactsListFooterStyle>?)
  @objc override final public func layoutSubviews()
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
}
@objc @_hasMissingDesignatedInitializers final public class ContactsListHeaderView : UIKit.UIView {
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
}
@_inheritsConvenienceInitializers final public class ContactsListScene : Dialog_iOS.Scene<Swift.Void, UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.ContactsListScene.Builder
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<Swift.Void, UIKit.UIViewController, Dialog_iOS.ContactsListViewModelProtocol> {
    override final public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>) -> Dialog_iOS.ContactsListViewModelProtocol
    override final public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>, viewModel: Dialog_iOS.ContactsListViewModelProtocol) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<Swift.Void, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
@_inheritsConvenienceInitializers final public class ContactsListSearchResultsScene : Dialog_iOS.Scene<Swift.Void, Dialog_iOS.DialogListSearchResultsSceneViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.AnySceneBuilder<Dialog_iOS.DialogListSearchResultsSceneViewController, Swift.Void>
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<Swift.Void, Dialog_iOS.DialogListSearchResultsSceneViewController, Dialog_iOS.DialogListSearchViewModelProtocol> {
    override final public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>) -> Dialog_iOS.DialogListSearchViewModelProtocol
    override final public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>, viewModel: Dialog_iOS.DialogListSearchViewModelProtocol) -> Dialog_iOS.DialogListSearchResultsSceneViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<Swift.Void, Dialog_iOS.DialogListSearchResultsSceneViewController>.Builder = super, resolver: Swinject.Resolver)
}
public protocol ContactsListViewModelProtocol : Dialog_iOS.ViewModelProtocol {
  var title: RxCocoa.Driver<Swift.String> { get }
  var tabBarItem: RxCocoa.Driver<UIKit.UITabBarItem> { get }
  var tabBarBadgeValue: RxCocoa.Driver<Swift.Int> { get }
  var beginCallTypeChoiceViewModel: Dialog_iOS.BeginCallTypeChoiceViewModelProtocol { get }
  var contactCellTap: RxSwift.AnyObserver<Dialog_iOS.DUIContactCellViewModel> { get }
  var sections: RxCocoa.Driver<[Dialog_iOS.ContactsListSection]> { get }
  var placeholder: RxCocoa.Driver<Dialog_iOS.PlaceholderState?> { get }
  var requestRemoveFromContacts: RxCocoa.Driver<DialogProtocols.DialogUserId> { get }
  var removeFromContactsActionTap: RxSwift.AnyObserver<DialogProtocols.DialogUserId> { get }
  var removeFromContacts: RxSwift.AnyObserver<DialogProtocols.DialogUserId> { get }
  func isDeletable(userID: DialogProtocols.DialogUserId) -> Swift.Bool
  var search: Dialog_iOS.DialogListViewModelSearch { get }
  var themeService: Dialog_iOS.AppThemeService { get }
}
public enum PlaceholderState {
  case empty
  case noResults
  public static func == (a: Dialog_iOS.PlaceholderState, b: Dialog_iOS.PlaceholderState) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public class ContactsListViewModel : Dialog_iOS.ContactsListViewModelProtocol {
  final public let title: RxCocoa.Driver<Swift.String>
  final public let tabBarItem: RxCocoa.Driver<UIKit.UITabBarItem>
  final public let tabBarBadgeValue: RxCocoa.Driver<Swift.Int>
  final public let contactCellTap: RxSwift.AnyObserver<Dialog_iOS.DUIContactCellViewModel>
  public var beginCallTypeChoiceViewModel: Dialog_iOS.BeginCallTypeChoiceViewModelProtocol
  public var requestRemoveFromContacts: RxCocoa.Driver<DialogProtocols.DialogUserId> {
    get
  }
  public var removeFromContactsActionTap: RxSwift.AnyObserver<DialogProtocols.DialogUserId> {
    get
  }
  public var removeFromContacts: RxSwift.AnyObserver<DialogProtocols.DialogUserId> {
    get
  }
  final public let sections: RxCocoa.Driver<[Dialog_iOS.ContactsListSection]>
  public var placeholder: RxCocoa.Driver<Dialog_iOS.PlaceholderState?>
  public var search: Dialog_iOS.DialogListViewModelSearch
  final public let themeService: Dialog_iOS.AppThemeService
  required public init(routerService: Dialog_iOS.RouterServiceProtocol, fileService: DialogFiles.DialogFileServiceProtocol, eventBusService: DialogProtocols.EventBusServiceProtocol, contactsService: DialogMessaging.DialogContactsServiceProtocol, colorService: Dialog_iOS.DialogPeerColorsServiceProtocol, callsService: DialogCalls.CallsServiceProtocol, featureFlagsService: DialogProtocols.DialogFeatureFlagsServiceProtocol, myId: DialogProtocols.DialogUserId, searchService: DialogSearching.LocalSearchServiceProtocol, searchResultsProvider: Dialog_iOS.SearchResultsViewControllerProviderProtocol, beginCallChoiceViewModel: Dialog_iOS.BeginCallTypeChoiceViewModelProtocol, themeService: Dialog_iOS.AppThemeService)
  public func isDeletable(userID: DialogProtocols.DialogUserId) -> Swift.Bool
  @objc deinit
}
public struct ContactsListSection {
  public let items: [Dialog_iOS.DUIContactCellViewModel]
  public let type: Dialog_iOS.ContactsListSection.SectionType
  public init(items: [Dialog_iOS.DUIContactCellViewModel], type: Dialog_iOS.ContactsListSection.SectionType)
}
extension ContactsListSection : Differentiator.AnimatableSectionModelType {
  public enum SectionType {
    case contacts(startingWith: Swift.String)
  }
  public typealias Identity = Swift.String
  public var identity: Swift.String {
    get
  }
  public typealias Item = Dialog_iOS.DUIContactCellViewModel
  public init(original: Dialog_iOS.ContactsListSection, items: [Dialog_iOS.ContactsListSection.Item])
}
extension Theme.Domain {
  public static let contacts: Dialog_iOS.Theme.Domain
}
extension Theme.Keys.Contacts {
  public static let searchResultsSeparatorInsetsLeft: Dialog_iOS.Theme.Keys.Contacts
}
extension Theme.Defaults {
  public static let contacts: DialogSharedComponents.Subtheme<Dialog_iOS.Theme.Keys.Contacts>
}
extension Theme.Keys {
  public struct Contacts : Dialog_iOS.DomainSpecificKey, Swift.RawRepresentable {
    public static var domain: Dialog_iOS.Theme.Domain
    public var domainInternalId: Swift.String {
      get
    }
    public let rawValue: Swift.String
    public init(rawValue: Swift.String)
    public typealias RawValue = Swift.String
  }
}
public protocol ContainerServiceOutputProtocol {
  func resolve<T>(_ type: T.Type, name: Swift.String?) -> T?
}
public protocol ContainerServiceInputProtocol {
  @discardableResult
  func register<T>(_ type: T.Type, name: Swift.String?, factory: @escaping (Swinject.Resolver) -> T) -> Swinject.ServiceEntry<T>
}
public protocol ContainerServiceAccessProtocol : Dialog_iOS.ContainerServiceInputProtocol, Dialog_iOS.ContainerServiceOutputProtocol {
  var container: Swinject.Container { get }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class ControlRxConfigurator<View> : Dialog_iOS.ViewRxConfigurator<View> where View : UIKit.UIControl {
  public var enabled: RxSwift.AnyObserver<Swift.Bool> {
    get
  }
  public var selected: RxSwift.AnyObserver<Swift.Bool> {
    get
  }
  public var userInteractionEnablef: RxSwift.AnyObserver<Swift.Bool> {
    get
  }
  override public func createBindings(to: View) -> [RxSwift.Disposable]
  @objc deinit
}
public struct ConversationAttachmentsState : Swift.Equatable {
  public static let empty: Dialog_iOS.ConversationAttachmentsState
  public var reply: DialogProtocols.DialogMessage?
  public var forwards: [DialogProtocols.DialogMessage]?
  public var editing: DialogProtocols.DialogMessageEditingState?
  public var isEmpty: Swift.Bool {
    get
  }
  public static func == (a: Dialog_iOS.ConversationAttachmentsState, b: Dialog_iOS.ConversationAttachmentsState) -> Swift.Bool
}
@_inheritsConvenienceInitializers final public class ConversationEventBusAttachContext : Dialog_iOS.ConversationEventBusContext<Dialog_iOS.ConversationAttachmentsState>, Dialog_iOS.NewEventBusIdentifiableContext {
  public static let contextId: Dialog_iOS.ConversationEventBusContextId
  @objc deinit
  override public init(anyStore: Dialog_iOS.NewEventBusBaseStateContext<Dialog_iOS.ConversationAttachmentsState, Dialog_iOS.ConversationEventBusContextId, Dialog_iOS.ConversationEventId>.AnyStore)
}
final public class ConversationAttachForwardsDidChangeEvent : Dialog_iOS.NewEventBusEventRepresentable {
  public typealias Context = Dialog_iOS.ConversationEventBusAttachContext
  public static let id: Dialog_iOS.ConversationEventId
  final public let forwards: [DialogProtocols.DialogMessage]?
  public init(forwards: [DialogProtocols.DialogMessage]?)
  public static var update: (Dialog_iOS.ConversationAttachForwardsDidChangeEvent, Dialog_iOS.ConversationAttachmentsState) -> Dialog_iOS.ConversationAttachmentsState {
    get
  }
  @objc deinit
}
final public class ConversationAttachReplyDidChangeEvent : Dialog_iOS.NewEventBusEventRepresentable {
  public typealias Context = Dialog_iOS.ConversationEventBusAttachContext
  public static let id: Dialog_iOS.ConversationEventId
  final public let reply: DialogProtocols.DialogMessage?
  public init(reply: DialogProtocols.DialogMessage?)
  public static var update: (Dialog_iOS.ConversationAttachReplyDidChangeEvent, Dialog_iOS.ConversationAttachmentsState) -> Dialog_iOS.ConversationAttachmentsState {
    get
  }
  @objc deinit
}
final public class ConversationAttachMessageEditionDidChangeEvent : Dialog_iOS.NewEventBusEventRepresentable {
  public typealias Context = Dialog_iOS.ConversationEventBusAttachContext
  public static let id: Dialog_iOS.ConversationEventId
  final public let state: DialogProtocols.DialogMessageEditingState?
  public init(state: DialogProtocols.DialogMessageEditingState?)
  public static var update: (Dialog_iOS.ConversationAttachMessageEditionDidChangeEvent, Dialog_iOS.ConversationAttachmentsState) -> Dialog_iOS.ConversationAttachmentsState {
    get
  }
  @objc deinit
}
public typealias ConversationEventBus = Dialog_iOS.NewEventBus<Dialog_iOS.ConversationEventBusContextId>
public typealias ConversationEventBusContext<State> = Dialog_iOS.NewEventBusBaseStateContext<State, Dialog_iOS.ConversationEventBusContextId, Dialog_iOS.ConversationEventId>
extension NewEventBus where ContextId == Dialog_iOS.ConversationEventBusContextId {
  final public func registerDefaultContexts()
}
public struct ConversationEventBusContextId : Swift.RawRepresentable, Swift.Hashable, Dialog_iOS.NewEventBusContextIdRepresentable {
  public typealias RawValue = Swift.String
  public let rawValue: Dialog_iOS.ConversationEventBusContextId.RawValue
  public init(rawValue: Dialog_iOS.ConversationEventBusContextId.RawValue)
  public init(_ rawValue: Dialog_iOS.ConversationEventBusContextId.RawValue)
  public static func reflecting<Context>(contextType: Context.Type) -> Dialog_iOS.ConversationEventBusContextId
}
public struct ConversationEventId : Swift.RawRepresentable, Swift.Equatable, Dialog_iOS.NewEventBusEventIdRepresentable {
  public typealias RawValue = Swift.String
  public let rawValue: Dialog_iOS.ConversationEventId.RawValue
  public init(rawValue: Dialog_iOS.ConversationEventId.RawValue)
  public init(_ rawValue: Dialog_iOS.ConversationEventId.RawValue)
  public static let base: Swift.String
  public static func named(_ name: Swift.String) -> Dialog_iOS.ConversationEventId
}
@_inheritsConvenienceInitializers final public class ConversationEventBusActionsContext : Dialog_iOS.ConversationEventBusContext<Dialog_iOS.ConversationEventBusActionEvent?>, Dialog_iOS.NewEventBusIdentifiableContext {
  public static let contextId: Dialog_iOS.ConversationEventBusContextId
  override public init(anyStore: Dialog_iOS.NewEventBusBaseStateContext<Dialog_iOS.ConversationEventBusActionEvent?, Dialog_iOS.ConversationEventBusContextId, Dialog_iOS.ConversationEventId>.AnyStore)
  @objc deinit
}
final public class ConversationEventBusActionEvent : Dialog_iOS.NewEventBusEventRepresentable {
  public typealias Context = Dialog_iOS.ConversationEventBusActionsContext
  public enum Action : Swift.Equatable {
    case forward([DialogSDK_GRPC.Dialog_UUIDValue])
    case join
    case send
    case start
    public static func == (a: Dialog_iOS.ConversationEventBusActionEvent.Action, b: Dialog_iOS.ConversationEventBusActionEvent.Action) -> Swift.Bool
  }
  final public let action: Dialog_iOS.ConversationEventBusActionEvent.Action
  public init(action: Dialog_iOS.ConversationEventBusActionEvent.Action)
  public static var id: Dialog_iOS.ConversationEventId
  public static var update: (Dialog_iOS.ConversationEventBusActionEvent, Dialog_iOS.ConversationEventBusActionEvent.Context.State) -> Dialog_iOS.ConversationEventBusActionEvent.Context.State {
    get
  }
  @objc deinit
}
public struct ConversationEventBusInputBarState {
  public enum JoinState {
    case notNeeded
    case required
    case joining
    case startBot
    public static func == (a: Dialog_iOS.ConversationEventBusInputBarState.JoinState, b: Dialog_iOS.ConversationEventBusInputBarState.JoinState) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public static let empty: Dialog_iOS.ConversationEventBusInputBarState
  public var joinState: Dialog_iOS.ConversationEventBusInputBarState.JoinState
}
@_inheritsConvenienceInitializers final public class ConversationEventBusInputBarStateContext : Dialog_iOS.ConversationEventBusContext<Dialog_iOS.ConversationEventBusInputBarState>, Dialog_iOS.NewEventBusIdentifiableContext {
  public static let contextId: Dialog_iOS.ConversationEventBusContextId
  override public init(anyStore: Dialog_iOS.NewEventBusBaseStateContext<Dialog_iOS.ConversationEventBusInputBarState, Dialog_iOS.ConversationEventBusContextId, Dialog_iOS.ConversationEventId>.AnyStore)
  @objc deinit
}
final public class ConversationEventBusInputBarEvent : Dialog_iOS.NewEventBusEventRepresentable {
  public typealias Context = Dialog_iOS.ConversationEventBusInputBarStateContext
  public enum Action {
    case setJoinState(Dialog_iOS.ConversationEventBusInputBarState.JoinState)
  }
  final public let action: Dialog_iOS.ConversationEventBusInputBarEvent.Action
  public init(action: Dialog_iOS.ConversationEventBusInputBarEvent.Action)
  public static var id: Dialog_iOS.ConversationEventId
  public static var update: (Dialog_iOS.ConversationEventBusInputBarEvent, Dialog_iOS.ConversationEventBusInputBarEvent.Context.State) -> Dialog_iOS.ConversationEventBusInputBarEvent.Context.State {
    get
  }
  @objc deinit
}
public struct ConversationInputState : Swift.Equatable {
  public static let empty: Dialog_iOS.ConversationInputState
  public var verticalSpace: CoreGraphics.CGFloat
  public static func == (a: Dialog_iOS.ConversationInputState, b: Dialog_iOS.ConversationInputState) -> Swift.Bool
}
@_inheritsConvenienceInitializers final public class ConversationInputStateContext : Dialog_iOS.ConversationEventBusContext<Dialog_iOS.ConversationInputState>, Dialog_iOS.NewEventBusIdentifiableContext {
  public static var contextId: Dialog_iOS.ConversationEventBusContextId {
    get
  }
  override public init(anyStore: Dialog_iOS.NewEventBusBaseStateContext<Dialog_iOS.ConversationInputState, Dialog_iOS.ConversationEventBusContextId, Dialog_iOS.ConversationEventId>.AnyStore)
  @objc deinit
}
final public class ConversationInputStateDidChangeVerticalSpaceEvent : Dialog_iOS.NewEventBusEventRepresentable {
  public typealias Context = Dialog_iOS.ConversationInputStateContext
  public static var id: Dialog_iOS.ConversationEventId
  final public let verticalSpace: CoreGraphics.CGFloat
  public init(verticalSpace: CoreGraphics.CGFloat)
  public static var update: (Dialog_iOS.ConversationInputStateDidChangeVerticalSpaceEvent, Dialog_iOS.ConversationInputState) -> Dialog_iOS.ConversationInputState {
    get
  }
  @objc deinit
}
public protocol ConversationJoinPanelViewModelProtocol {
  var text: RxCocoa.Driver<Swift.String> { get }
  var isJoining: RxCocoa.Driver<Swift.Bool> { get }
  var join: RxSwift.AnyObserver<Swift.Void> { get }
}
@_hasMissingDesignatedInitializers final public class ConversationJoinPanelViewModel : Dialog_iOS.ConversationJoinPanelViewModelProtocol {
  final public var text: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Swift.String>
  final public var isJoining: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Swift.Bool>
  final public var join: RxSwift.AnyObserver<Swift.Void>
  convenience public init(state: RxSwift.Observable<Dialog_iOS.ConversationEventBusInputBarState.JoinState>, joinObserver: RxSwift.AnyObserver<Swift.Void>)
  @objc deinit
}
public protocol ConversationLoadingViewDesign {
  var containerSize: CoreGraphics.CGSize { get }
  var containerBackgroundColor: UIKit.UIColor { get }
  var indicatorStyle: UIKit.UIActivityIndicatorView.Style { get }
  var cornerType: Dialog_iOS.CornerRadiusType { get }
  var blurStyle: UIKit.UIBlurEffect.Style { get }
}
@objc @_hasMissingDesignatedInitializers final public class ConversationLoadingView : UIKit.UIView {
  public init(design: Dialog_iOS.ConversationLoadingViewDesign)
  @objc override final public func layoutSubviews()
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
}
extension ConversationLoadingView {
  final public func animateAppearing()
  final public func animateDisappearing()
}
@_inheritsConvenienceInitializers final public class ConversationEventBusMessageJumpContext : Dialog_iOS.ConversationEventBusContext<Swift.Void>, Dialog_iOS.NewEventBusIdentifiableContext {
  public static let contextId: Dialog_iOS.ConversationEventBusContextId
  override public init(anyStore: Dialog_iOS.NewEventBusBaseStateContext<Swift.Void, Dialog_iOS.ConversationEventBusContextId, Dialog_iOS.ConversationEventId>.AnyStore)
  @objc deinit
}
final public class ConversationJumpToMessageRequestEvent : Dialog_iOS.NewEventBusEventRepresentable {
  public typealias Context = Dialog_iOS.ConversationEventBusMessageJumpContext
  public static let id: Dialog_iOS.ConversationEventId
  final public let targetMessage: DialogProtocols.DialogMessage
  public init(targetMessage: DialogProtocols.DialogMessage)
  public static var update: (Dialog_iOS.ConversationJumpToMessageRequestEvent, Dialog_iOS.ConversationJumpToMessageRequestEvent.Context.State) -> Dialog_iOS.ConversationJumpToMessageRequestEvent.Context.State {
    get
  }
  @objc deinit
}
public protocol ConversationMessageListEmbeddable {
  var asViewController: UIKit.UIViewController { get }
  func assignItemsMenu(_ menu: Dialog_iOS.ControllerMenuProtocol)
  func assignConversationEventBus(_ eventBus: Dialog_iOS.ConversationEventBus)
  func bindJumpToMessageFromAttach(_ jumpToMessage: RxSwift.Observable<DialogProtocols.DialogMessage>)
  func bindJumpToDown(_ jumpToDown: RxSwift.Observable<Swift.Void>)
  func bind(conversationViewModel: Dialog_iOS.ConversationViewModelProtocol)
  func bind(placeholder: UIKit.UIView?)
  var contentOffset: RxCocoa.Driver<CoreGraphics.CGPoint> { get }
  func closeReactionsViewControllerIfNeeded()
}
public struct ConversationInfo : DialogProtocols.BaseStruct {
  public let dialogState: DialogProtocols.DialogState
  public let unreadCountState: DialogProtocols.DialogUnreadCountState?
  public let initialPeer: Dialog_iOS.ConversationPeer?
  public let messageId: DialogProtocols.DialogUUID?
  public init(dialogState: DialogProtocols.DialogState, unreadCountState: DialogProtocols.DialogUnreadCountState?, initialPeer: Dialog_iOS.ConversationPeer?, messageId: DialogProtocols.DialogUUID? = nil)
}
public protocol ConversationSceneViewControllerInterface {
  func forwardingDone()
}
@_inheritsConvenienceInitializers final public class ConversationScene : Dialog_iOS.Scene<Dialog_iOS.ConversationInfo, UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.ConversationScene.Builder
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<Dialog_iOS.ConversationInfo, UIKit.UIViewController, Dialog_iOS.ConversationViewModelProtocol> {
    override final public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Dialog_iOS.ConversationScene.DefaultBuilder.MainArgument>) -> Dialog_iOS.ConversationViewModelProtocol
    override final public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Dialog_iOS.ConversationScene.DefaultBuilder.MainArgument>, viewModel: Dialog_iOS.ConversationViewModelProtocol) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<Dialog_iOS.ConversationInfo, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
@_inheritsConvenienceInitializers final public class ConversationEventBusSelectedMidsContext : Dialog_iOS.ConversationEventBusContext<Dialog_iOS.ConversationSelectedMidsState>, Dialog_iOS.NewEventBusIdentifiableContext {
  public static let contextId: Dialog_iOS.ConversationEventBusContextId
  override public init(anyStore: Dialog_iOS.NewEventBusBaseStateContext<Dialog_iOS.ConversationSelectedMidsState, Dialog_iOS.ConversationEventBusContextId, Dialog_iOS.ConversationEventId>.AnyStore)
  @objc deinit
}
public struct ConversationSelectedMidsState : Swift.Equatable {
  public static let empty: Dialog_iOS.ConversationSelectedMidsState
  public let mids: [DialogSDK_GRPC.Dialog_UUIDValue]
  public var isEmpty: Swift.Bool {
    get
  }
  public init(mids: [DialogSDK_GRPC.Dialog_UUIDValue])
  public func adding(mids: [DialogSDK_GRPC.Dialog_UUIDValue]) -> Dialog_iOS.ConversationSelectedMidsState
  public func removing(mids: [DialogSDK_GRPC.Dialog_UUIDValue]) -> Dialog_iOS.ConversationSelectedMidsState
  public static func == (a: Dialog_iOS.ConversationSelectedMidsState, b: Dialog_iOS.ConversationSelectedMidsState) -> Swift.Bool
}
extension ConversationEventId {
  public static let selectedMessageIDs: Dialog_iOS.ConversationEventId
  public static let addSelectedMessageIDs: Dialog_iOS.ConversationEventId
  public static let removeSelectedMessageIDs: Dialog_iOS.ConversationEventId
}
final public class ConversationSelectedMidsEvent : Dialog_iOS.NewEventBusEventRepresentable {
  public typealias Context = Dialog_iOS.ConversationEventBusSelectedMidsContext
  public static var id: Dialog_iOS.ConversationEventId {
    get
  }
  final public let mids: [DialogSDK_GRPC.Dialog_UUIDValue]
  public init(mids: [DialogSDK_GRPC.Dialog_UUIDValue])
  public static var update: (Dialog_iOS.ConversationSelectedMidsEvent, Dialog_iOS.ConversationSelectedMidsState) -> Dialog_iOS.ConversationSelectedMidsState {
    get
  }
  @objc deinit
}
final public class ConversationAddSelectedMidsEvent : Dialog_iOS.NewEventBusEventRepresentable {
  public typealias Context = Dialog_iOS.ConversationEventBusSelectedMidsContext
  public static var id: Dialog_iOS.ConversationEventId {
    get
  }
  final public let addedMids: [DialogSDK_GRPC.Dialog_UUIDValue]
  public init(addedMids: [DialogSDK_GRPC.Dialog_UUIDValue])
  public static var update: (Dialog_iOS.ConversationAddSelectedMidsEvent, Dialog_iOS.ConversationSelectedMidsState) -> Dialog_iOS.ConversationSelectedMidsState {
    get
  }
  @objc deinit
}
final public class ConversationRemoveSelectedMidsEvent : Dialog_iOS.NewEventBusEventRepresentable {
  public typealias Context = Dialog_iOS.ConversationEventBusSelectedMidsContext
  public static var id: Dialog_iOS.ConversationEventId {
    get
  }
  final public let removedMids: [DialogSDK_GRPC.Dialog_UUIDValue]
  public init(removedMids: [DialogSDK_GRPC.Dialog_UUIDValue])
  public static var update: (Dialog_iOS.ConversationRemoveSelectedMidsEvent, Dialog_iOS.ConversationSelectedMidsState) -> Dialog_iOS.ConversationSelectedMidsState {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers public class ConversationEventBusSelectionRxAdapter {
  @objc deinit
}
public enum ConversationSelectionMode : Swift.Equatable {
  case on
  case off
  public var isOn: Swift.Bool {
    get
  }
  public var isOff: Swift.Bool {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Dialog_iOS.ConversationSelectionMode, b: Dialog_iOS.ConversationSelectionMode) -> Swift.Bool
}
@_inheritsConvenienceInitializers public class ConversationEventBusSelectionContext : Dialog_iOS.ConversationEventBusContext<Dialog_iOS.ConversationSelectionMode>, Dialog_iOS.NewEventBusIdentifiableContext {
  public static var contextId: Dialog_iOS.ConversationEventBusContextId {
    get
  }
  override public init(anyStore: Dialog_iOS.NewEventBusBaseStateContext<Dialog_iOS.ConversationSelectionMode, Dialog_iOS.ConversationEventBusContextId, Dialog_iOS.ConversationEventId>.AnyStore)
  @objc deinit
}
final public class ConversationEventBusSelectionEvent : Dialog_iOS.NewEventBusEventRepresentable {
  public typealias Context = Dialog_iOS.ConversationEventBusSelectionContext
  public static var id: Dialog_iOS.ConversationEventId
  final public let newMode: Dialog_iOS.ConversationSelectionMode
  public init(newMode: Dialog_iOS.ConversationSelectionMode)
  public static var update: (Dialog_iOS.ConversationEventBusSelectionEvent, Dialog_iOS.ConversationSelectionMode) -> Dialog_iOS.ConversationSelectionMode {
    get
  }
  @objc deinit
}
@objc public protocol ConversationStandardEditActionResponder : ObjectiveC.NSObjectProtocol {
  @objc func forwardMessage(_ sender: Any?)
  @objc func replyToMessage(_ sender: Any?)
  @objc func synthesizeMessage(_ sender: Any?)
  @objc func stopSynthesizingCurrentMessage(_ sender: Any?)
  @objc func copyMessageContent(_ sender: Any?)
  @objc func selectMessage(_ sender: Any?)
  @objc func resendMessage(_ sender: Any?)
  @objc func deselectMessage(_ sender: Any?)
  @objc func editMessage(_ sender: Any?)
  @objc func deleteMessage(_ sender: Any?)
  @objc func saveMessage(_ sender: Any?)
  @objc func showInConversation(_ sender: Any?)
  @objc func addReaction(_ sender: Any?)
}
public struct ConversationStandardEditActionType : Swift.RawRepresentable, Swift.Equatable {
  public typealias RawValue = ObjectiveC.Selector
  public let rawValue: ObjectiveC.Selector
  public var action: ObjectiveC.Selector {
    get
  }
  public init(rawValue: ObjectiveC.Selector)
  public init(_ rawValue: ObjectiveC.Selector)
  public static let forward: Dialog_iOS.ConversationStandardEditActionType
  public static let reply: Dialog_iOS.ConversationStandardEditActionType
  public static let synthesizeMessage: Dialog_iOS.ConversationStandardEditActionType
  public static let stopSynthesizingCurrentMessage: Dialog_iOS.ConversationStandardEditActionType
  public static let copy: Dialog_iOS.ConversationStandardEditActionType
  public static let select: Dialog_iOS.ConversationStandardEditActionType
  public static let resend: Dialog_iOS.ConversationStandardEditActionType
  public static let deselect: Dialog_iOS.ConversationStandardEditActionType
  public static let edit: Dialog_iOS.ConversationStandardEditActionType
  public static let delete: Dialog_iOS.ConversationStandardEditActionType
  public static let save: Dialog_iOS.ConversationStandardEditActionType
  public static let showInConversation: Dialog_iOS.ConversationStandardEditActionType
  public static let addReaction: Dialog_iOS.ConversationStandardEditActionType
}
extension Theme.Domain {
  public static let conversation: Dialog_iOS.Theme.Domain
}
extension Theme.Keys.Conversation {
  public static let controlsColor: Dialog_iOS.Theme.Keys.Conversation
  public static let sendButtonColor: Dialog_iOS.Theme.Keys.Conversation
  public static let sendButtonImage: Dialog_iOS.Theme.Keys.Conversation
  public static let attachmentsButtonColor: Dialog_iOS.Theme.Keys.Conversation
  public static let stickersButtonColor: Dialog_iOS.Theme.Keys.Conversation
}
extension Theme.Defaults {
  public static let conversation: DialogSharedComponents.Subtheme<Dialog_iOS.Theme.Keys.Conversation>
}
extension Theme.Keys {
  public struct Conversation : Dialog_iOS.DomainSpecificKey, Swift.RawRepresentable {
    public static var domain: Dialog_iOS.Theme.Domain
    public var domainInternalId: Swift.String {
      get
    }
    public let rawValue: Swift.String
    public init(rawValue: Swift.String)
    public typealias RawValue = Swift.String
  }
}
public protocol ConversationViewMessageSelectionProtocol {
  func deselectAllMessages()
}
@objc @_hasMissingDesignatedInitializers final public class ConversationViewController : UIKit.UIViewController, Dialog_iOS.ConversationViewMessageSelectionProtocol {
  final public var messageListController: UIKit.UIViewController {
    get
  }
  public init(viewModel: Dialog_iOS.ConversationViewModelProtocol, messageList: Dialog_iOS.ConversationMessageListEmbeddable, messageInput: Dialog_iOS.MessageInputUIEmbeddable, pickerFactory: Dialog_iOS.PickerFactoryProtocol)
  @objc override final public var inputAccessoryView: UIKit.UIView {
    @objc get
  }
  @objc override final public var canBecomeFirstResponder: Swift.Bool {
    @objc get
  }
  @objc override final public var keyCommands: [UIKit.UIKeyCommand]? {
    @objc get
  }
  @objc override final public func viewDidLoad()
  @objc override final public func viewDidLayoutSubviews()
  final public func deselectAllMessages()
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc deinit
}
extension ConversationViewController : Dialog_iOS.ConversationSceneViewControllerInterface {
  final public func forwardingDone()
}
extension ConversationViewController : UIKit.UIGestureRecognizerDelegate {
  @objc final public func gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
  @objc final public func gestureRecognizerShouldBegin(_ gestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
  @objc final public func gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldReceive touch: UIKit.UITouch) -> Swift.Bool
}
extension ConversationViewController : UIKit.UIImagePickerControllerDelegate, UIKit.UINavigationControllerDelegate {
  @objc final public func imagePickerController(_ picker: UIKit.UIImagePickerController, didFinishPickingMediaWithInfo info: [UIKit.UIImagePickerController.InfoKey : Any])
  @objc final public func imagePickerControllerDidCancel(_ picker: UIKit.UIImagePickerController)
}
extension ConversationViewModel : Dialog_iOS.MenuInteractorProtocol {
  @_hasMissingDesignatedInitializers public class Permissions {
    final public let canReply: RxSwift.BehaviorSubject<Swift.Bool>
    final public let canForward: RxSwift.BehaviorSubject<Swift.Bool>
    final public let canDelete: RxSwift.BehaviorSubject<Swift.Bool>
    final public let canEdit: RxSwift.BehaviorSubject<Swift.Bool>
    final public let canAddReaction: RxSwift.BehaviorSubject<Swift.Bool>
    @objc deinit
  }
  final public func canPerformAction(_ action: ObjectiveC.Selector, item: Dialog_iOS.MessageCellViewModel.Content, messageStatus: DialogProtocols.DialogMyMessageStatusType?, fileError: DialogProtocols.DialogFileError?) -> Swift.Bool
  final public func handleEvent(_ event: Dialog_iOS.MenuActionEvent, item: Dialog_iOS.MessageCellViewModel.Content) throws
}
public enum StopButtonState {
  case present(progress: CoreGraphics.CGFloat)
  case hidden
}
public enum ConversationPeer {
  case group(DialogProtocols.DialogGroup)
  case user(DialogProtocols.DialogUser)
  public var group: DialogProtocols.DialogGroup? {
    get
  }
  public var user: DialogProtocols.DialogUser? {
    get
  }
  public var dialogPeer: DialogProtocols.DialogPeer {
    get
  }
}
public enum PerformMediaActionType {
  case showPicker(pickerData: Dialog_iOS.PickerData, mediaData: Dialog_iOS.InteractiveMediaSelectData, confirmData: DialogMessaging.DialogInteractiveMediaConfirm?)
  case showAlert(request: DialogProtocols.DialogMediaActionRequest, confirmData: DialogMessaging.DialogInteractiveMediaConfirm)
}
public enum PerformMediaActionResult {
  case confirm(request: DialogProtocols.DialogMediaActionRequest)
  case didSelect(selectedItem: Dialog_iOS.PickerItem, mediaData: Dialog_iOS.InteractiveMediaSelectData)
}
public struct CallIconType {
  public enum DisplayMode {
    case none
    case disabled
    case enabled
    public static func == (a: Dialog_iOS.CallIconType.DisplayMode, b: Dialog_iOS.CallIconType.DisplayMode) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
}
public protocol ConversationViewModelProtocol : Dialog_iOS.DialogHeaderViewModelProtocol {
  var callIconDidTap: RxSwift.AnyObserver<DialogProtocols.AccessibleCallType> { get }
  var callIconTapResult: RxCocoa.Driver<Dialog_iOS.TryToCallResult> { get }
  var callIconTypes: RxCocoa.Driver<[Dialog_iOS.CallIconType]> { get }
  var isCallButtonEnabled: RxCocoa.Driver<Swift.Bool> { get }
  var stopSelection: RxSwift.AnyObserver<Swift.Void> { get }
  var shouldShowStopSelectionButton: RxCocoa.Driver<Swift.Bool> { get }
  var menuInteractor: Dialog_iOS.MenuInteractorProtocol { get }
  var conversationEventBus: Dialog_iOS.ConversationEventBus { get }
  var beginCallTypeChoiceViewModel: Dialog_iOS.BeginCallTypeChoiceViewModelProtocol { get }
  var performMediaAction: RxSwift.AnyObserver<Dialog_iOS.InteractiveMediaAction> { get }
  var handleMediaActionResult: RxSwift.AnyObserver<Dialog_iOS.PerformMediaActionResult> { get }
  var mediaActionHandler: RxSwift.Observable<Dialog_iOS.PerformMediaActionType> { get }
  var showActivity: RxCocoa.Driver<Swift.Bool> { get }
  var isEmptyConversation: RxSwift.AnyObserver<Swift.Bool> { get }
  var themeColor: UIKit.UIColor { get }
  func image(for callType: DialogProtocols.AccessibleCallType) -> UIKit.UIImage?
  var didTapReactions: RxCocoa.Driver<DialogProtocols.DialogUUID> { get }
  var removeBetaForcedlyForConference: Swift.Bool { get }
  var stopButtonState: RxCocoa.Driver<Dialog_iOS.StopButtonState> { get }
  var stopButtonTapped: RxSwift.AnyObserver<Swift.Void> { get }
  var backgroundImage: RxCocoa.Driver<UIKit.UIImage?> { get }
  var isFavorites: Swift.Bool { get }
}
final public class ConversationViewModel : Dialog_iOS.ConversationViewModelProtocol {
  final public let dialog: DialogProtocols.DialogState
  final public let myId: DialogProtocols.DialogUserId
  final public var menuInteractor: Dialog_iOS.MenuInteractorProtocol {
    get
  }
  final public let beginCallTypeChoiceViewModel: Dialog_iOS.BeginCallTypeChoiceViewModelProtocol
  final public let conversationEventBus: Dialog_iOS.ConversationEventBus
  final public let permissions: Dialog_iOS.ConversationViewModel.Permissions
  final public var showActivity: RxCocoa.Driver<Swift.Bool>
  final public var themeColor: UIKit.UIColor
  final public var didTapReactions: RxCocoa.Driver<DialogProtocols.DialogUUID> {
    get
  }
  final public var stopButtonState: RxCocoa.Driver<Dialog_iOS.StopButtonState> {
    get
  }
  final public var stopButtonTapped: RxSwift.AnyObserver<Swift.Void> {
    get
  }
  final public var callIconTapResult: RxCocoa.Driver<Dialog_iOS.TryToCallResult>
  final public let removeBetaForcedlyForConference: Swift.Bool
  final public var backgroundImage: RxCocoa.Driver<UIKit.UIImage?> {
    get
  }
  final public let isFavorites: Swift.Bool
  final public let basicColor: UIKit.UIColor
  final public let avatarCenterText: RxCocoa.Driver<Swift.String?>
  final public let avatarImage: RxCocoa.Driver<UIKit.UIImage?>
  final public let isAvatarLoading: RxCocoa.Driver<Swift.Bool>
  final public let shouldShowStopSelectionButton: RxCocoa.Driver<Swift.Bool>
  final public let stopSelection: RxSwift.AnyObserver<Swift.Void>
  final public let headerTitle: RxCocoa.Driver<Swift.String?>
  final public let headerDescription: RxCocoa.Driver<Dialog_iOS.HeaderDescriptionMode>
  final public let didTapHeader: RxSwift.AnyObserver<Swift.Void>
  final public let typingViewModel: Dialog_iOS.UserStatusViewModelProtocol
  final public var callIconTypes: RxCocoa.Driver<[Dialog_iOS.CallIconType]>
  final public let isCallButtonEnabled: RxCocoa.Driver<Swift.Bool>
  final public var callIconDidTap: RxSwift.AnyObserver<DialogProtocols.AccessibleCallType>
  final public let performMediaAction: RxSwift.AnyObserver<Dialog_iOS.InteractiveMediaAction>
  final public let handleMediaActionResult: RxSwift.AnyObserver<Dialog_iOS.PerformMediaActionResult>
  final public let mediaActionHandler: RxSwift.Observable<Dialog_iOS.PerformMediaActionType>
  final public let isEmptyConversation: RxSwift.AnyObserver<Swift.Bool>
  final public let availableBeginCallTypes: RxRelay.BehaviorRelay<[DialogProtocols.AccessibleCallType]>
  public init(conversationInfo: Dialog_iOS.ConversationInfo, routerService: Dialog_iOS.RouterServiceProtocol, router: Dialog_iOS.UserSpecifiedRouterProtocol, fileService: DialogFiles.DialogFileServiceProtocol, mediaActionService: DialogMessaging.DialogMediaActionServiceProtocol, eventBus: DialogProtocols.EventBusServiceProtocol, userEvenBus: DialogProtocols.UserEventBusServiceProtocol, seqService: DialogMessaging.DialogSeqUpdatesServiceProtocol, conversationEventBus: Dialog_iOS.ConversationEventBus, offlineService: DialogMessaging.DialogOfflineMessagesServiceProtocol, featureFlagsService: DialogProtocols.DialogFeatureFlagsServiceProtocol, dialogStickerService: DialogMessaging.DialogStickersServiceProtocol, messageService: DialogMessaging.DialogOneMessageServiceProtocol, colorService: Dialog_iOS.DialogPeerColorsServiceProtocol, groupsService: DialogProtocols.DialogGroupServiceProtocol, editService: DialogMessaging.DialogMessageEditingServiceProtocol, callsService: DialogCalls.CallsServiceProtocol, activeUserId: DialogProtocols.DialogUserId, themeService: Dialog_iOS.AppThemeService, presenceService: DialogProtocols.UserPresenceStateServiceProtocol, conferenceService: DialogCalls.DialogConferenceServiceProtocol, beginCallChoiceViewModel: Dialog_iOS.BeginCallTypeChoiceViewModelProtocol, deepLinkOpener: Dialog_iOS.DeepLinkOpenerProtocol, dialogConferenceUIConfig: Dialog_iOS.DialogConferenceUIConfig)
  @objc deinit
}
extension ConversationViewModel {
  final public func image(for callType: DialogProtocols.AccessibleCallType) -> UIKit.UIImage?
}
extension Theme.Domain {
  public static let conversationView: Dialog_iOS.Theme.Domain
}
extension Theme.Keys.ConversationView {
  public static let audioCallImage: Dialog_iOS.Theme.Keys.ConversationView
  public static let videoCallImage: Dialog_iOS.Theme.Keys.ConversationView
  public static let externalCallImage: Dialog_iOS.Theme.Keys.ConversationView
  public static let conferenceCallImage: Dialog_iOS.Theme.Keys.ConversationView
}
extension Theme.Defaults {
  public static let conversationView: DialogSharedComponents.Subtheme<Dialog_iOS.Theme.Keys.ConversationView>
}
extension Theme.Keys {
  public struct ConversationView : Dialog_iOS.DomainSpecificKey, Swift.RawRepresentable {
    public static var domain: Dialog_iOS.Theme.Domain
    public var domainInternalId: Swift.String {
      get
    }
    public let rawValue: Swift.String
    public init(rawValue: Swift.String)
    public typealias RawValue = Swift.String
  }
}
public struct CoordinatableItem<ViewController, ViewModel> where ViewController : UIKit.UIViewController {
}
public struct CoordinatableNodeItem<Controller, ViewModel> where Controller : AsyncDisplayKit.ASNodeController<AsyncDisplayKit.ASDisplayNode> {
}
public protocol CoordinatorFabricRegistrarProtocol {
  func register<R, T, C, Arg>(_ fabric: @escaping (Swinject.Container, Arg) -> C) where R : XCoordinator.Route, T : XCoordinator.TransitionProtocol, C : XCoordinator.AnyCoordinator<R, T>
  func register<R, T, C>(_ fabric: @escaping (Swinject.Container) -> C) where R : XCoordinator.Route, T : XCoordinator.TransitionProtocol, C : XCoordinator.AnyCoordinator<R, T>
}
public protocol CoordinatorFabricProtocol {
  func create<R, T, C, Arg>(parentContainer: Swinject.Container, arg: Arg) -> C where R : XCoordinator.Route, T : XCoordinator.TransitionProtocol, C : XCoordinator.AnyCoordinator<R, T>
  func create<R, T, C>(parentContainer: Swinject.Container) -> C where R : XCoordinator.Route, T : XCoordinator.TransitionProtocol, C : XCoordinator.AnyCoordinator<R, T>
}
open class CoordinatorFabric : Dialog_iOS.CoordinatorFabricProtocol, Dialog_iOS.CoordinatorFabricRegistrarProtocol {
  public init(container: Swinject.Container = Container())
  public func register<R, T, C, Arg>(_ fabric: @escaping (Swinject.Container, Arg) -> C) where R : XCoordinator.Route, T : XCoordinator.TransitionProtocol, C : XCoordinator.AnyCoordinator<R, T>
  public func register<R, T, C>(_ fabric: @escaping (Swinject.Container) -> C) where R : XCoordinator.Route, T : XCoordinator.TransitionProtocol, C : XCoordinator.AnyCoordinator<R, T>
  public func create<R, T, C, Arg>(parentContainer: Swinject.Container, arg: Arg) -> C where R : XCoordinator.Route, T : XCoordinator.TransitionProtocol, C : XCoordinator.AnyCoordinator<R, T>
  public func create<R, T, C>(parentContainer: Swinject.Container) -> C where R : XCoordinator.Route, T : XCoordinator.TransitionProtocol, C : XCoordinator.AnyCoordinator<R, T>
  @objc deinit
}
extension Coordinator {
  public typealias AnyCoordinatorType = XCoordinator.AnyCoordinator<Self.RouteType, Self.TransitionType>
}
final public class CoordinatorsAssembler : Swinject.Assembly {
  public init()
  final public func assemble(container: Swinject.Container)
  @objc deinit
}
final public class CoreServicesAssembler : Swinject.Assembly {
  public init()
  final public func assemble(container: Swinject.Container)
  @objc deinit
}
public enum CreateDialogCellViewModel : Differentiator.IdentifiableType, Swift.Equatable {
  public typealias Identity = Dialog_iOS.CreateDialogRowType
  public var identity: Dialog_iOS.CreateDialogCellViewModel.Identity {
    get
  }
  case newDialog(Dialog_iOS.CreateDialogNewDialogViewModelProtocol)
  case contact(Dialog_iOS.CreateDialogContactViewModelProtocol)
  public static func == (lhs: Dialog_iOS.CreateDialogCellViewModel, rhs: Dialog_iOS.CreateDialogCellViewModel) -> Swift.Bool
}
public enum CreateDialogType {
  case personal
  case group
  case channel
  public static func == (a: Dialog_iOS.CreateDialogType, b: Dialog_iOS.CreateDialogType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public enum CreateDialogRowType : Swift.Hashable {
  public enum NewDialogType : Swift.Hashable {
    case group
    case channel
    case personal
    case conference
    public static func == (a: Dialog_iOS.CreateDialogRowType.NewDialogType, b: Dialog_iOS.CreateDialogRowType.NewDialogType) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  case createGroup(Dialog_iOS.CreateDialogRowType.NewDialogType)
  case contact(DialogProtocols.DialogUserId)
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Dialog_iOS.CreateDialogRowType, b: Dialog_iOS.CreateDialogRowType) -> Swift.Bool
}
public protocol CreateDialogCellBasicViewModelProtocol {
  var rowType: Dialog_iOS.CreateDialogRowType { get }
  var title: RxCocoa.Driver<Swift.String> { get }
}
public protocol CreateDialogNewDialogViewModelProtocol : Dialog_iOS.CreateDialogCellBasicViewModelProtocol {
  var description: Swift.String { get }
  var newDialogType: Dialog_iOS.CreateDialogRowType.NewDialogType { get }
  var icon: RxCocoa.Driver<UIKit.UIImage?> { get }
  var isEnabled: RxCocoa.Driver<Swift.Bool> { get }
  var isBeta: RxCocoa.Driver<Swift.Bool> { get }
}
public protocol CreateDialogContactViewModelProtocol : Dialog_iOS.CreateDialogCellBasicViewModelProtocol {
  var user: DialogProtocols.DialogUser { get }
  var avatar: Dialog_iOS.AvatarViewModelProtocol { get }
  var occupation: RxCocoa.Driver<Swift.String> { get }
  var callImage: RxCocoa.Driver<UIKit.UIImage> { get }
}
@_hasMissingDesignatedInitializers public class CreateDialogCellBasicViewModel : Dialog_iOS.CreateDialogCellBasicViewModelProtocol {
  public typealias Identity = Dialog_iOS.CreateDialogRowType
  public var title: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Swift.String>
  final public let rowType: Dialog_iOS.CreateDialogRowType
  public var identity: Dialog_iOS.CreateDialogRowType {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers public class CreateDialogNewDialogViewModel : Dialog_iOS.CreateDialogCellBasicViewModel, Dialog_iOS.CreateDialogNewDialogViewModelProtocol {
  final public let description: Swift.String
  final public let newDialogType: Dialog_iOS.CreateDialogRowType.NewDialogType
  final public let isEnabled: RxCocoa.Driver<Swift.Bool>
  final public let icon: RxCocoa.Driver<UIKit.UIImage?>
  public var isBeta: RxCocoa.Driver<Swift.Bool>
  @objc deinit
}
@_hasMissingDesignatedInitializers public class CreateDialogContactViewModel : Dialog_iOS.CreateDialogCellBasicViewModel, Dialog_iOS.CreateDialogContactViewModelProtocol {
  final public let occupation: RxCocoa.Driver<Swift.String>
  final public let avatar: Dialog_iOS.AvatarViewModelProtocol
  final public let callImage: RxCocoa.Driver<UIKit.UIImage>
  final public let user: DialogProtocols.DialogUser
  @objc deinit
}
public enum CreateDialogRoute : XCoordinator.Route {
  case initial
  case group
  case channel
  case groupCreated(DialogProtocols.DialogState)
  case usersInvited
  case createAvc
}
public typealias CreateDialogRouter = XCoordinator.WeakRouter<Dialog_iOS.CreateDialogRoute>
public typealias AnyCreateDialogCoordinator = Dialog_iOS.CreateDialogCoordinator.AnyCoordinatorType
final public class CreateDialogCoordinator : XCoordinator.NavigationCoordinator<Dialog_iOS.CreateDialogRoute> {
  override final public var viewController: UIKit.UIViewController! {
    get
  }
  public init(container: Swinject.Container, rootViewController: UIKit.UINavigationController)
  override final public func prepareTransition(for route: Dialog_iOS.CreateDialogRoute) -> XCoordinator.NavigationTransition
  override public init(rootViewController: XCoordinator.NavigationCoordinator<Dialog_iOS.CreateDialogRoute>.RootViewController = super, initialRoute: Dialog_iOS.CreateDialogRoute? = super)
  override public init(rootViewController: XCoordinator.NavigationCoordinator<Dialog_iOS.CreateDialogRoute>.RootViewController = super, root: XCoordinator.Presentable)
  @objc deinit
}
public protocol CreateDialogCellStyleProtocol {
  var backgroundColor: UIKit.UIColor { get }
  var titleAttributes: [Foundation.NSAttributedString.Key : Any] { get }
  var descriptionAttributes: [Foundation.NSAttributedString.Key : Any] { get }
  var betaViewAttributes: [Foundation.NSAttributedString.Key : Any] { get }
  var disabledTextColor: UIKit.UIColor { get }
  var paddings: UIKit.UIEdgeInsets { get }
  var spacing: CoreGraphics.CGFloat { get }
  var separatorInsets: UIKit.UIEdgeInsets { get }
  var iconBackgroundColor: UIKit.UIColor { get }
}
public struct CreateDialogCellDefaultStyle : Dialog_iOS.CreateDialogCellStyleProtocol {
  public let backgroundColor: UIKit.UIColor
  public let titleAttributes: [Foundation.NSAttributedString.Key : Any]
  public let descriptionAttributes: [Foundation.NSAttributedString.Key : Any]
  public let betaViewAttributes: [Foundation.NSAttributedString.Key : Any]
  public let disabledTextColor: UIKit.UIColor
  public let paddings: UIKit.UIEdgeInsets
  public let spacing: CoreGraphics.CGFloat
  public var separatorInsets: UIKit.UIEdgeInsets {
    get
  }
  public let iconBackgroundColor: UIKit.UIColor
  public static let shared: Dialog_iOS.CreateDialogCellDefaultStyle
}
public enum DialogAvatarOption {
  case none
  case picked(DialogMessaging.DialogDocumentMessageContent)
  case deleted
}
public struct CreateDialogOptionsModel {
  public enum GroupType : Swift.Int {
    case group
    case channel
    public typealias RawValue = Swift.Int
    public init?(rawValue: Swift.Int)
    public var rawValue: Swift.Int {
      get
    }
  }
  public init(type: Dialog_iOS.CreateDialogOptionsModel.GroupType, users: [DialogProtocols.DialogUser] = [], name: Swift.String, description: Swift.String? = nil, shortlink: Swift.String? = nil, isPublic: Swift.Bool = false)
}
extension CreateDialogOptionsModel {
  public func asCreateGroupRequest() -> DialogProtocols.DialogGroup.Create.Request
}
public protocol CreateDialogOptionsServiceProtocol {
  var currentOptions: Dialog_iOS.CreateDialogOptionsModel? { get }
  func createNewOptions(name: Swift.String, type: Dialog_iOS.CreateDialogOptionsModel.GroupType) -> Dialog_iOS.CreateDialogOptionsModel
  @discardableResult
  func updateOptions(with newValue: [DialogProtocols.DialogUser]) -> Dialog_iOS.CreateDialogOptionsModel?
  @discardableResult
  func updateOptions(with newValue: Dialog_iOS.DialogAvatarOption) -> Dialog_iOS.CreateDialogOptionsModel?
  func clearOptions()
  func saveNewOptions(_ options: Dialog_iOS.CreateDialogOptionsModel)
}
@_hasMissingDesignatedInitializers public class CreateDialogOptionsService : Dialog_iOS.CreateDialogOptionsServiceProtocol {
  public var currentOptions: Dialog_iOS.CreateDialogOptionsModel?
  @discardableResult
  public func updateOptions(with newValue: [DialogProtocols.DialogUser]) -> Dialog_iOS.CreateDialogOptionsModel?
  @discardableResult
  public func updateOptions(with newValue: Dialog_iOS.DialogAvatarOption) -> Dialog_iOS.CreateDialogOptionsModel?
  public func clearOptions()
  public func saveNewOptions(_ options: Dialog_iOS.CreateDialogOptionsModel)
  public func createNewOptions(name: Swift.String, type: Dialog_iOS.CreateDialogOptionsModel.GroupType) -> Dialog_iOS.CreateDialogOptionsModel
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class EditGroupOptionsService : Dialog_iOS.CreateDialogOptionsService {
  @objc deinit
}
@_inheritsConvenienceInitializers final public class CreateDialogScene : Dialog_iOS.Scene<Swift.Void, UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.CreateDialogScene.Builder
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<Swift.Void, UIKit.UIViewController, Dialog_iOS.CreateDialogViewModelProtocol> {
    override final public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>) -> Dialog_iOS.CreateDialogViewModelProtocol
    override final public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>, viewModel: Dialog_iOS.CreateDialogViewModelProtocol) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<Swift.Void, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
@_inheritsConvenienceInitializers final public class CreateDialogSearchScene : Dialog_iOS.Scene<Swift.Void, Dialog_iOS.DialogListSearchResultsSceneViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.AnySceneBuilder<Dialog_iOS.DialogListSearchResultsSceneViewController, Swift.Void>
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<Swift.Void, Dialog_iOS.DialogListSearchResultsSceneViewController, Dialog_iOS.DialogListSearchViewModelProtocol> {
    override final public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>) -> Dialog_iOS.DialogListSearchViewModelProtocol
    override final public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>, viewModel: Dialog_iOS.DialogListSearchViewModelProtocol) -> Dialog_iOS.DialogListSearchResultsSceneViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<Swift.Void, Dialog_iOS.DialogListSearchResultsSceneViewController>.Builder = super, resolver: Swinject.Resolver)
}
public enum CreateDialogViewModelOutputEvent : Swift.Hashable {
  case startSearch
  public static func == (a: Dialog_iOS.CreateDialogViewModelOutputEvent, b: Dialog_iOS.CreateDialogViewModelOutputEvent) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol CreateDialogViewModelProtocol : Dialog_iOS.ViewModelProtocol {
  var createDialogCellTap: RxSwift.AnyObserver<Dialog_iOS.CreateDialogCellViewModel> { get }
  var title: RxCocoa.Driver<Swift.String> { get }
  var sections: RxCocoa.Driver<[Dialog_iOS.CreateDialogSection]> { get }
  var search: Dialog_iOS.DialogListViewModelSearch { get }
  var outputEvents: RxCocoa.Driver<Dialog_iOS.CreateDialogViewModelOutputEvent> { get }
}
public struct CreateDialogSection : Swift.Equatable {
  public enum Kind : Swift.Hashable {
    case newDialog
    case contacts(letter: Swift.String)
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Dialog_iOS.CreateDialogSection.Kind, b: Dialog_iOS.CreateDialogSection.Kind) -> Swift.Bool
  }
  public var items: [Dialog_iOS.CreateDialogCellViewModel]
  public let kind: Dialog_iOS.CreateDialogSection.Kind
  public init(kind: Dialog_iOS.CreateDialogSection.Kind, items: [Dialog_iOS.CreateDialogCellViewModel])
  public static func == (a: Dialog_iOS.CreateDialogSection, b: Dialog_iOS.CreateDialogSection) -> Swift.Bool
}
extension CreateDialogSection : Differentiator.AnimatableSectionModelType {
  public typealias Identity = Dialog_iOS.CreateDialogSection.Kind
  public typealias Item = Dialog_iOS.CreateDialogCellViewModel
  public var identity: Dialog_iOS.CreateDialogSection.Kind {
    get
  }
  public var title: Swift.String {
    get
  }
  public init(original: Dialog_iOS.CreateDialogSection, items: [Dialog_iOS.CreateDialogCellViewModel])
}
public protocol CreateLinkTextFieldStyleProtocol : Dialog_iOS.FloatingTextInputStyleProtocol {
  var endpointTextColor: UIKit.UIColor { get }
}
public struct CreateLinkTextFieldDefaultStyle : Dialog_iOS.CreateLinkTextFieldStyleProtocol {
  public var isUnderlineHidden: Swift.Bool
  public var endpointTextColor: UIKit.UIColor
  public var textColor: UIKit.UIColor {
    get
  }
  public var textFont: UIKit.UIFont {
    get
  }
  public var placeholderColor: UIKit.UIColor {
    get
  }
  public var placeholderFont: UIKit.UIFont {
    get
  }
  public var placeholderTitleFont: UIKit.UIFont {
    get
  }
  public var underlineColor: UIKit.UIColor {
    get
  }
  public var underlineHeight: CoreGraphics.CGFloat {
    get
  }
  public var spacingBetweenUnderlineAndText: CoreGraphics.CGFloat {
    get
  }
  public var spacingBetweenPlacholderAndText: CoreGraphics.CGFloat {
    get
  }
  public var errorTextColor: UIKit.UIColor {
    get
  }
  public var errorUnderlineColor: UIKit.UIColor {
    get
  }
  public var fadeInDuration: Foundation.TimeInterval {
    get
  }
  public var fadeOutDuration: Foundation.TimeInterval {
    get
  }
  public init(attrs: Dialog_iOS.BasicAppTheme)
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class CreateLinkTextField : Dialog_iOS.FloatingTextField {
  override public var style: Dialog_iOS.FloatingTextInputStyleProtocol {
    get
    set
  }
  public var shortlinkDomain: Swift.String {
    get
    set
  }
  @objc override dynamic public var hasText: Swift.Bool {
    @objc get
  }
  public func shortlinkEndpointRect(forBounds bounds: CoreGraphics.CGRect) -> CoreGraphics.CGRect
  @objc override dynamic public func textRect(forBounds bounds: CoreGraphics.CGRect) -> CoreGraphics.CGRect
  @objc override dynamic public func placeholderRect(forBounds bounds: CoreGraphics.CGRect) -> CoreGraphics.CGRect
  @objc override dynamic public func editingRect(forBounds bounds: CoreGraphics.CGRect) -> CoreGraphics.CGRect
  @objc override dynamic public func layoutSubviews()
  @objc deinit
}
@_inheritsConvenienceInitializers final public class CreateNewChannelScene : Dialog_iOS.Scene<Swift.Void, UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.CreateNewChannelScene.Builder
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<Swift.Void, UIKit.UIViewController, Dialog_iOS.BaseGroupProfileViewModelProtocol> {
    override final public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>) -> Dialog_iOS.BaseGroupProfileViewModelProtocol
    override final public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>, viewModel: Dialog_iOS.BaseGroupProfileViewModelProtocol) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<Swift.Void, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
public struct CreateNewChannelNameValidationMapper : Dialog_iOS.ErrorTextEmitter {
  public var errorText: RxCocoa.Driver<Swift.String?>
  public init<T>(validator: T) where T : Dialog_iOS.TextValidator, T.Output == Dialog_iOS.CreateNewDialogNameValidationType?
}
public struct CreateNewChannelDescriptionValidationMapper : Dialog_iOS.ErrorTextEmitter {
  public var errorText: RxCocoa.Driver<Swift.String?>
  public init<T>(validator: T) where T : Dialog_iOS.TextValidator, T.Output == Dialog_iOS.CreateNewDialogDescriptionValidationType?
}
public struct CreateNewChannelCreateLinkValidationMapper : Dialog_iOS.ErrorTextEmitter {
  public var errorText: RxCocoa.Driver<Swift.String?>
  public init<T>(validator: T) where T : Dialog_iOS.TextValidator, T.Output == Dialog_iOS.CreateNewDialogCreateLinkValidationType?
}
@_inheritsConvenienceInitializers final public class CreateNewConferenceScene : Dialog_iOS.Scene<Swift.Void, UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.CreateNewConferenceScene.Builder
  public typealias VM = Dialog_iOS.CreateNewConferenceViewModelProtocol
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<Swift.Void, UIKit.UIViewController, Dialog_iOS.CreateNewConferenceScene.VM> {
    override final public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>) -> Dialog_iOS.CreateNewConferenceScene.VM
    override final public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>, viewModel: Dialog_iOS.CreateNewConferenceScene.VM) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<Swift.Void, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
public enum CreateNewConferenceNameValidationType : Swift.Int {
  case nameTooShort
  case nameTooLong
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public struct CreateNewConferenceValidator : Dialog_iOS.TextValidator {
  public struct Input : Swift.Equatable {
    public static func == (a: Dialog_iOS.CreateNewConferenceValidator.Input, b: Dialog_iOS.CreateNewConferenceValidator.Input) -> Swift.Bool
  }
  public typealias Output = Dialog_iOS.CreateNewConferenceNameValidationType?
  public var errorType: RxCocoa.Driver<Dialog_iOS.CreateNewConferenceValidator.Output>
  public var canProceed: RxCocoa.Driver<Swift.Bool>
  public init(driver: RxCocoa.Driver<Dialog_iOS.CreateNewConferenceValidator.Input>)
}
public struct CreateNewConferenceNameValidationMapper : Dialog_iOS.ErrorTextEmitter {
  public var errorText: RxCocoa.Driver<Swift.String?>
  public init<T>(validator: T) where T : Dialog_iOS.TextValidator, T.Output == Dialog_iOS.CreateNewConferenceNameValidationType?
}
extension Theme.Domain {
  public static let newConference: Dialog_iOS.Theme.Domain
}
extension Theme.Keys.NewConferenceScene {
  public static func newKey(_ key: Swift.String) -> Dialog_iOS.Theme.Keys.NewConferenceScene
  public static let tableViewBackgroundColor: Dialog_iOS.Theme.Keys.NewConferenceScene
  public static let backgroundColor: Dialog_iOS.Theme.Keys.NewConferenceScene
}
extension Theme.Defaults {
  public static let newConferenceScene: DialogSharedComponents.Subtheme<Dialog_iOS.Theme.Keys.NewConferenceScene>
}
extension Theme.Keys {
  public struct NewConferenceScene : Dialog_iOS.DomainSpecificKey, Swift.RawRepresentable {
    public static var domain: Dialog_iOS.Theme.Domain
    public var domainInternalId: Swift.String {
      get
    }
    public let rawValue: Swift.String
    public init(rawValue: Swift.String)
    public typealias RawValue = Swift.String
  }
}
public protocol CreateNewConferenceViewModelProtocol : Dialog_iOS.ViewModelProtocol {
  var proceed: RxSwift.AnyObserver<Swift.Bool> { get }
  var title: RxCocoa.Driver<Dialog_iOS.DUINavigationTitleModel> { get }
  var sections: RxCocoa.Driver<[Dialog_iOS.DUISimpleSection]> { get }
  var canProceed: RxCocoa.Driver<Swift.Bool> { get }
  var isLoading: RxCocoa.Driver<Swift.Bool> { get }
  var error: RxCocoa.Driver<Swift.Error> { get }
  var errorText: RxCocoa.Driver<Swift.String?> { get }
  var attrs: RxCocoa.Driver<Dialog_iOS.BasicAppTheme> { get }
}
public class CreateNewConferenceViewModel : Dialog_iOS.CreateNewConferenceViewModelProtocol {
  final public let disposeBag: RxSwift.DisposeBag
  public var proceed: RxSwift.AnyObserver<Swift.Bool>
  public var title: RxCocoa.Driver<Dialog_iOS.DUINavigationTitleModel>
  public var sections: RxCocoa.Driver<[Dialog_iOS.DUISimpleSection]>
  public var canProceed: RxCocoa.Driver<Swift.Bool>
  public var isLoading: RxCocoa.Driver<Swift.Bool>
  public var error: RxCocoa.Driver<Swift.Error>
  public var errorText: RxCocoa.Driver<Swift.String?>
  public var attrs: RxCocoa.Driver<Dialog_iOS.BasicAppTheme>
  public init(themeService: Dialog_iOS.AppThemeService, conferenceService: DialogCalls.DialogConferenceServiceProtocol, routerService: Dialog_iOS.RouterServiceProtocol, featureFlagService: DialogProtocols.DialogFeatureFlagsServiceProtocol, eventBus: DialogProtocols.EventBusServiceProtocol)
  @objc deinit
}
public enum CreateNewDialogNameValidationType : Swift.Int {
  case nameTooShort
  case nameTooLong
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public enum CreateNewDialogDescriptionValidationType : Swift.Int {
  case nameTooLong
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public enum CreateNewDialogCreateLinkValidationType : Swift.Int {
  case nameTooLong
  case containWhiteSpaces
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public struct CreateNewDialogValidator {
  public var canProceed: RxCocoa.Driver<Swift.Bool>
  public var mayProceed: RxCocoa.Driver<Swift.Bool>
  public var groupNameError: RxCocoa.Driver<Swift.String?> {
    get
  }
  public var descriptionError: RxCocoa.Driver<Swift.String?> {
    get
  }
  public var createLinkError: RxCocoa.Driver<Swift.String?> {
    get
  }
  public init(groupEmitter: Dialog_iOS.ErrorTextEmitter, descriptionEmitter: Dialog_iOS.ErrorTextEmitter, createLinkEmitter: Dialog_iOS.ErrorTextEmitter, enablePublicGroup: RxCocoa.Driver<Swift.Bool>, isCreateLinkEmpty: RxCocoa.Driver<Swift.Bool>)
  public init()
}
public struct CreateNewDialogGroupNameValidator : Dialog_iOS.TextValidator {
  public struct Input : Swift.Equatable {
    public static func == (a: Dialog_iOS.CreateNewDialogGroupNameValidator.Input, b: Dialog_iOS.CreateNewDialogGroupNameValidator.Input) -> Swift.Bool
  }
  public typealias Output = Dialog_iOS.CreateNewDialogNameValidationType?
  public var errorType: RxCocoa.Driver<Dialog_iOS.CreateNewDialogGroupNameValidator.Output>
  public init(driver: RxCocoa.Driver<Dialog_iOS.CreateNewDialogGroupNameValidator.Input>)
}
public struct CreateNewDialogDescriptionValidator : Dialog_iOS.TextValidator {
  public typealias Input = Swift.String?
  public typealias Output = Dialog_iOS.CreateNewDialogDescriptionValidationType?
  public var errorType: RxCocoa.Driver<Dialog_iOS.CreateNewDialogDescriptionValidator.Output>
  public init(driver: RxCocoa.Driver<Dialog_iOS.CreateNewDialogDescriptionValidator.Input>)
}
public struct CreateNewDialogCreateLinkValidator : Dialog_iOS.TextValidator {
  public typealias Input = Swift.String?
  public typealias Output = Dialog_iOS.CreateNewDialogCreateLinkValidationType?
  public var errorType: RxCocoa.Driver<Dialog_iOS.CreateNewDialogCreateLinkValidator.Output>
  public init(driver: RxCocoa.Driver<Dialog_iOS.CreateNewDialogCreateLinkValidator.Input>)
}
public struct CreateNewDialogViewModelDependencies {
}
public class CreateNewDialogViewModel : Dialog_iOS.BaseGroupProfileViewModelProtocol {
  final public let disposeBag: RxSwift.DisposeBag
  final public let avatarViewModel: Dialog_iOS.BaseGroupProfileAvatarViewModelProtocol
  public var proceed: RxSwift.AnyObserver<Swift.Bool>
  public var title: RxCocoa.Driver<Dialog_iOS.DUINavigationTitleModel>
  public var sections: RxCocoa.Driver<[Dialog_iOS.DUISimpleSection]>
  public var canProceed: RxCocoa.Driver<Swift.Bool>
  public var isLoading: RxCocoa.Driver<Swift.Bool>
  public var error: RxCocoa.Driver<Swift.Error>
  final public let groupNameObserver: RxRelay.BehaviorRelay<Swift.String>
  final public let descriptionObserver: RxRelay.BehaviorRelay<Swift.String?>
  final public let enablePublicGroupObserver: RxRelay.BehaviorRelay<Swift.Bool>
  final public let enableAVConferenceObserver: RxRelay.BehaviorRelay<Swift.Bool>
  final public let createLinkObserver: RxRelay.BehaviorRelay<Swift.String?>
  public var validator: Dialog_iOS.CreateNewDialogValidator
  final public let optionsService: Dialog_iOS.CreateDialogOptionsServiceProtocol
  final public let activeUsers: RxSwift.Observable<[DialogProtocols.AuthUserEntry]>
  final public let failEmitter: RxSwift.PublishSubject<Swift.Void>
  public init(dependencies: Dialog_iOS.CreateNewDialogViewModelDependencies)
  public func titleText() -> Swift.String
  public func dialogType() -> Dialog_iOS.CreateDialogOptionsModel.GroupType
  public func nameValidationTextEmitter() -> Dialog_iOS.ErrorTextEmitter
  public func descriptionValidationTextEmitter() -> Dialog_iOS.ErrorTextEmitter
  public func createLinkValidationTextEmitter() -> Dialog_iOS.ErrorTextEmitter
  public func createLinkPlaceholderText() -> Swift.String
  public func publicSelectionTitleText() -> Swift.String
  public func descriptionInfoText() -> Swift.String
  public func descriptionOfPublicStateOfGroup() -> Swift.String
  public func descriptionOfPublicLink() -> Swift.String
  public func headerPlaceholderText() -> Swift.String
  public func avConferencingTitleText() -> Swift.String
  public func avConferencingSwitchText() -> Swift.String
  public func linkDidTapped(link: Foundation.URL)
  @objc deinit
}
@_inheritsConvenienceInitializers final public class CreateNewGroupScene : Dialog_iOS.Scene<Swift.Void, UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.CreateNewGroupScene.Builder
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<Swift.Void, UIKit.UIViewController, Dialog_iOS.BaseGroupProfileViewModelProtocol> {
    override final public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>) -> Dialog_iOS.BaseGroupProfileViewModelProtocol
    override final public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>, viewModel: Dialog_iOS.BaseGroupProfileViewModelProtocol) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<Swift.Void, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
public struct CreateNewGroupNameValidationMapper : Dialog_iOS.ErrorTextEmitter {
  public var errorText: RxCocoa.Driver<Swift.String?>
  public init<T>(validator: T) where T : Dialog_iOS.TextValidator, T.Output == Dialog_iOS.CreateNewDialogNameValidationType?
}
public struct CreateNewGroupDescriptionValidationMapper : Dialog_iOS.ErrorTextEmitter {
  public var errorText: RxCocoa.Driver<Swift.String?>
  public init<T>(validator: T) where T : Dialog_iOS.TextValidator, T.Output == Dialog_iOS.CreateNewDialogDescriptionValidationType?
}
public struct CreateNewGroupCreateLinkValidationMapper : Dialog_iOS.ErrorTextEmitter {
  public var errorText: RxCocoa.Driver<Swift.String?>
  public init<T>(validator: T) where T : Dialog_iOS.TextValidator, T.Output == Dialog_iOS.CreateNewDialogCreateLinkValidationType?
}
public struct CubeAttributesAnimator : Dialog_iOS.LayoutAttributesAnimator {
  public var perspective: CoreGraphics.CGFloat
  public var totalAngle: CoreGraphics.CGFloat
  public init(perspective: CoreGraphics.CGFloat = -1 / 500, totalAngle: CoreGraphics.CGFloat = .pi / 2)
  public func animate(collectionView: UIKit.UICollectionView, attributes: Dialog_iOS.AnimatedCollectionViewLayoutAttributes)
}
public protocol CurrentUserServiceProtocol {
  var user: DialogProtocols.AuthUserEntry { get }
}
public class ActiveUserKeeper : Dialog_iOS.CurrentUserServiceProtocol {
  public var user: DialogProtocols.AuthUserEntry
  public init(user: DialogProtocols.AuthUserEntry)
  @objc deinit
}
extension Data {
  public func saveInDocumentsWith(filename: Swift.String) throws -> Foundation.URL
}
public struct DateComponentRange {
  public enum Component {
    case day
    case month
    case year
    public static func == (a: Dialog_iOS.DateComponentRange.Component, b: Dialog_iOS.DateComponentRange.Component) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public var component: Dialog_iOS.DateComponentRange.Component
  public var range: Swift.ClosedRange<Swift.Int>
  public init(_ component: Dialog_iOS.DateComponentRange.Component, range: Swift.ClosedRange<Swift.Int>)
}
public struct DateFormaterRule {
  public var permittedRanges: [Dialog_iOS.DateComponentRange]
  public var dateFormat: Swift.String
  public typealias Validator = ([Dialog_iOS.DateComponentRange]) -> (Swift.Bool)
  public func present(_ validator: ([Dialog_iOS.DateComponentRange]) -> (Swift.Bool)) -> Swift.String?
  public init(_ permittedRanges: [Dialog_iOS.DateComponentRange], dateFormat: Swift.String)
}
extension Calendar {
  public func difference(from: Foundation.Date, to: Foundation.Date, component: Dialog_iOS.DateComponentRange.Component) -> Swift.Int?
}
extension DateComponentRange.Component {
  public var asCalendarComponent: Foundation.Calendar.Component {
    get
  }
}
extension DateFormaterRule {
  public static func defaultValidator(from: Foundation.Date, to: Foundation.Date, calendar: Foundation.Calendar) -> Dialog_iOS.DateFormaterRule.Validator
}
public typealias DateFormatRules = [Dialog_iOS.DateFormaterRule]
extension Array where Element == Dialog_iOS.DateFormaterRule {
  public static let lastMessageRules: [Dialog_iOS.DateFormaterRule]
  public static let callsHistoryRules: [Dialog_iOS.DateFormaterRule]
}
extension DateFormatter {
  public static let day: Foundation.DateFormatter
}
extension Date {
  public static var defaultComponentsFormat: [Foundation.Calendar.Component : Swift.String] {
    get
  }
  public func formatted(by componentsFormat: [Foundation.Calendar.Component : Swift.String]) -> Swift.String
  public func formattedInDayInterval() -> Swift.String
  public func formatted(by rules: Dialog_iOS.DateFormatRules, locale: Foundation.Locale = .current, timeZone: Foundation.TimeZone = .current, calendar: Foundation.Calendar = .current, onFailureJustFormat defaultFormat: Swift.String = "dd.MM.yy") -> Swift.String
}
public func FileLog(_ line: Swift.String)
final public class DebugFileWriter : Swift.CustomDebugStringConvertible {
  public static let shared: Dialog_iOS.DebugFileWriter
  public struct Config {
    public static let `default`: Dialog_iOS.DebugFileWriter.Config
    public static func defaultUrl() -> Foundation.URL
    public var url: Foundation.URL
  }
  @objc deinit
  final public func removeLogs()
  public init(config: Dialog_iOS.DebugFileWriter.Config = .default)
  final public func write(_ string: Swift.String)
  final public var debugDescription: Swift.String {
    get
  }
}
public protocol DeepLinkHandlerProtocol {
  func handle(url: Foundation.URL, appRouter: Dialog_iOS.AppStrongRouter?)
}
final public class DeepLinkHandler : Dialog_iOS.DeepLinkHandlerProtocol {
  public typealias UserActivator = ((DialogProtocols.AuthUserEntry) -> RxSwift.Single<Swift.Bool>)
  public init(resolver: Dialog_iOS.DeepLinkResolver, activeUsersService: Dialog_iOS.ActiveUsersServiceProtocol, authService: DialogProtocols.AuthServiceProtocol, resolversProvider: Dialog_iOS.SwinjectUserContainersServiceProtocol, appAuthStateService: Dialog_iOS.AppAuthStateServiceProtocol, userActivator: @escaping Dialog_iOS.DeepLinkHandler.UserActivator)
  final public func handle(url: Foundation.URL, appRouter: Dialog_iOS.AppStrongRouter?)
  @objc deinit
}
public protocol DeepLinkOpenerProtocol {
  func open(url: Foundation.URL, wrapForWebView: Swift.Bool, completion: ((Swift.Bool) -> ())?)
  func open(url: Foundation.URL, wrapForWebView: Swift.Bool) -> RxSwift.Single<Swift.Bool>
}
extension DeepLinkOpenerProtocol {
  public func open(urlString: Swift.String, wrapForWebView: Swift.Bool) -> RxSwift.Single<Swift.Bool>
}
final public class DeepLinkOpener : Dialog_iOS.DeepLinkOpenerProtocol {
  public init(application: UIKit.UIApplication, deepLinkResolver: Dialog_iOS.DeepLinkResolver)
  final public func open(url: Foundation.URL, wrapForWebView: Swift.Bool, completion: ((Swift.Bool) -> ())?)
  final public func open(url: Foundation.URL, wrapForWebView: Swift.Bool) -> RxSwift.Single<Swift.Bool>
  @objc deinit
}
final public class DeepLinkResolver {
  public init(config: Dialog_iOS.DeepLinkResolver.Config)
  final public func resolve(url: Foundation.URL) -> Dialog_iOS.DeepLinkResolver.ResolveResult
  final public func resolveConferenceCalls(url: Foundation.URL) -> [Swift.String : Swift.String]?
  final public func resolve(webView url: Foundation.URL) -> Foundation.URL?
  @objc deinit
}
extension DeepLinkResolver {
  public struct Config {
    public static let `default`: Dialog_iOS.DeepLinkResolver.Config
    public var scheme: Swift.String?
    public var baseUrls: [Swift.String]
    public var conferenceCallsConfig: Dialog_iOS.DeepLinkResolver.Config.CallsConfig
    public var userСallsConfig: Dialog_iOS.DeepLinkResolver.Config.CallsConfig
    public var webViewConfig: Dialog_iOS.DeepLinkResolver.Config.WebViewConfig
    public var inviteUrlConfig: Dialog_iOS.DeepLinkResolver.Config.InviteUrlConfig
    public struct CallsConfig {
      public static let `default`: Dialog_iOS.DeepLinkResolver.Config.CallsConfig
      public var deepLinkPath: Swift.String
      public var allowCallWithDeepLink: Swift.Bool
      public var requiredParams: [Swift.String]
      public var availableParamsOptions: [Swift.String : Swift.Set<Swift.String>]
    }
    public struct WebViewConfig {
      public static let `default`: Dialog_iOS.DeepLinkResolver.Config.WebViewConfig
      public var key: Swift.String
      public var path: Swift.String
      public func prefix() -> Swift.String
      public func wrap(url: Foundation.URL, scheme: Swift.String) -> Foundation.URL?
    }
    public struct InviteUrlConfig {
      public static let `default`: Dialog_iOS.DeepLinkResolver.Config.InviteUrlConfig
      public var privateGroupPrefix: Swift.String?
      public var shortnamePrefix: Swift.String?
      public var duplicateLinkPrefix: Swift.String?
      public var usernamePrefix: Swift.String?
      public var privateGroupTokenRegexPattern: Swift.String?
      public var shortnameRegexPattern: Swift.String?
    }
  }
}
extension DeepLinkResolver {
  public enum ResolveResult : Swift.Hashable {
    case none
    case unknownDeepLink
    case deepLinkConferenceCall(params: [Swift.String : Swift.String])
    case deepLinkUserCall(username: Swift.String, hasVideo: Swift.Bool)
    case webView(url: Foundation.URL)
    case deepLinkPeer(shortname: Swift.String)
    case deepLinkJoinPrivateGroup(token: Swift.String)
    case deepLinkUser(username: Swift.String)
    public var isNone: Swift.Bool {
      get
    }
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Dialog_iOS.DeepLinkResolver.ResolveResult, b: Dialog_iOS.DeepLinkResolver.ResolveResult) -> Swift.Bool
  }
  final public func wrapForWebView(url: Foundation.URL, scheme: Swift.String) -> Foundation.URL?
  final public func wrapIfNeeded(url: Foundation.URL, scheme: Swift.String, needWrapForWebView: Swift.Bool) -> Foundation.URL?
}
public protocol _DefaultInitable {
  static var `default`: Self { get }
}
extension _DefaultInitable {
  public static func createFromDefault(_ modifier: (inout Self) -> Swift.Void) -> Self
}
extension DeepLinkResolver.Config : Dialog_iOS._DefaultInitable {
}
extension DeepLinkResolver.Config.CallsConfig : Dialog_iOS._DefaultInitable {
}
extension DeepLinkResolver.Config.WebViewConfig : Dialog_iOS._DefaultInitable {
}
extension DeepLinkResolver.Config.InviteUrlConfig : Dialog_iOS._DefaultInitable {
}
extension UIColor {
  public struct Default {
    public static let commonTableViewCellBackgroundColor: UIKit.UIColor
  }
  public struct StickerCollection {
  }
}
extension UIColor {
  public struct InputBarColors {
  }
  public struct InputTextViewColors {
  }
}
extension UIColor {
  public struct Profile {
  }
}
extension UIColor {
  public struct StickerCollectionView {
  }
}
extension UIColor {
  public static let compatibleDarkTextColor: UIKit.UIColor
  public static let compatibleGrayColor: UIKit.UIColor
  public static let compatibleDarkGray: UIKit.UIColor
  public static let compatibleBackground: UIKit.UIColor
  public static let compatibleLightGray: UIKit.UIColor
  public static let compatibleWhite: UIKit.UIColor
  public static let compatibleBlack: UIKit.UIColor
  public static let disabledControlText: UIKit.UIColor
  public struct Tags {
  }
}
public struct DefaultMessageInputUIStyle : Dialog_iOS.MessageInputUIStyle {
  public var autocompleteUserSymbol: Swift.String
  public var autocompleteUserTextAttributes: [Foundation.NSAttributedString.Key : Any] {
    get
  }
  public var autocompleteUserNameAttributes: [Foundation.NSAttributedString.Key : Any] {
    get
  }
}
public typealias DialogAssembler = Swinject.Assembler
public typealias DialogContainer = Swinject.Container
public struct DialogAuthConfig {
  public enum Strategy {
    case all
    case phone
    case loginPassword
    case pki
    case secIdentity
    case token
    public static func == (a: Dialog_iOS.DialogAuthConfig.Strategy, b: Dialog_iOS.DialogAuthConfig.Strategy) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public static let `default`: Dialog_iOS.DialogAuthConfig
  public var strategy: Dialog_iOS.DialogAuthConfig.Strategy
  public var defaultEndpoints: [Swift.String]
  public var singleAuthOnly: Swift.Bool
  public var isFirstInitOfApp: Swift.Bool
  public static func createFromDefault(_ modifier: (inout Dialog_iOS.DialogAuthConfig) -> Swift.Void) -> Dialog_iOS.DialogAuthConfig
  public init(strategy: Dialog_iOS.DialogAuthConfig.Strategy, defaultEndpoints: [Swift.String])
  public init()
}
public struct DialogAuthUIConfig {
  public static let `default`: Dialog_iOS.DialogAuthUIConfig
  public var corporateLogo: UIKit.UIImage?
  public var isHorizontalLogo: Swift.Bool
  public var restorePasswordLink: Swift.String
  public var needHelpLink: Swift.String
  public static func createFromDefault(_ modifier: (inout Dialog_iOS.DialogAuthUIConfig) -> Swift.Void) -> Dialog_iOS.DialogAuthUIConfig
}
public struct DialogConferenceUIConfig {
  public static let `default`: Dialog_iOS.DialogConferenceUIConfig
  public var removeBetaForcedly: Swift.Bool
  public static func createFromDefault(_ modifier: (inout Dialog_iOS.DialogConferenceUIConfig) -> Swift.Void) -> Dialog_iOS.DialogConferenceUIConfig
}
public struct DialogFeedbackConfig {
  public static let `default`: Dialog_iOS.DialogFeedbackConfig
  public var supportPhoneNumber: Swift.String
  public static func createFromDefault(_ modifier: (inout Dialog_iOS.DialogFeedbackConfig) -> Swift.Void) -> Dialog_iOS.DialogFeedbackConfig
}
public struct DialogAuthPKIConfig {
  public static let `default`: Dialog_iOS.DialogAuthPKIConfig
  public var tokenEndpoint: Swift.String
  public var clientId: Swift.String
  public var certificateEndpoint: Swift.String
  public var pinningValidator: TrustKit.TSKPinningValidator?
  public var certificatesChain: Swift.String
  public static func createFromDefault(_ modifier: (inout Dialog_iOS.DialogAuthPKIConfig) -> Swift.Void) -> Dialog_iOS.DialogAuthPKIConfig
}
public struct DialogAuthSecIdentityConfig {
  public static let `default`: Dialog_iOS.DialogAuthSecIdentityConfig
  public var getSecIdentity: () -> Security.SecIdentity?
  public var certificatesChain: Swift.String
  public static func createFromDefault(_ modifier: (inout Dialog_iOS.DialogAuthSecIdentityConfig) -> Swift.Void) -> Dialog_iOS.DialogAuthSecIdentityConfig
}
public struct DialogAuthTokenConfig {
  public var token: Swift.String
  public init(token: Swift.String)
}
public struct DialogSecurityConfig {
  public static let `default`: Dialog_iOS.DialogSecurityConfig
  public var useSslPinning: Swift.Bool
  public var useDatabaseEncryption: Swift.Bool
  public static func createFromDefault(_ modifier: (inout Dialog_iOS.DialogSecurityConfig) -> Swift.Void) -> Dialog_iOS.DialogSecurityConfig
}
public enum DialogPushConfig {
  case obsolete(apnsId: Swift.Int32, voipId: Swift.Int32)
  @available(*, unavailable, message: "Server is not ready for this yet")
  case modern(bundleId: Swift.String)
  public var apnsPushProjectId: Swift.Int32? {
    get
  }
  public var voipPushProjectId: Swift.Int32? {
    get
  }
  public var isModern: Swift.Bool {
    get
  }
}
public struct DialogEntryViewConfig {
  public var backgroundColor: UIKit.UIColor
  public var logoImage: UIKit.UIImage?
  public var logoSize: CoreGraphics.CGSize?
  public static let `default`: Dialog_iOS.DialogEntryViewConfig
  public init(backgroundColor: UIKit.UIColor, logoImage: UIKit.UIImage?, logoSize: CoreGraphics.CGSize?)
}
public struct DialogAppGroupConfig {
  public var appGroupId: Swift.String
  public static let `default`: Dialog_iOS.DialogAppGroupConfig
  public init(appGroupId: Swift.String)
}
public struct DialogBadgesConfig {
  public var needUpdateCallsBadge: Swift.Bool
  public var needUpdateDialogsBadge: Swift.Bool
  public var needUpdateApplicationBadge: Swift.Bool
  public static let `default`: Dialog_iOS.DialogBadgesConfig
  public init(needUpdateCallsBadge: Swift.Bool = true, needUpdateDialogsBadge: Swift.Bool = true, needUpdateApplicationBadge: Swift.Bool = true)
}
public enum DialogAlertButtonsConfigError : Swift.Error {
  case noValuesProvided
  case inputArraysSizesMismatch
  public static func == (a: Dialog_iOS.DialogAlertButtonsConfigError, b: Dialog_iOS.DialogAlertButtonsConfigError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public struct DialogAlertButtonsConfig {
  public typealias AlertActionHandler = ((UIKit.UIAlertAction) -> Swift.Void)?
}
extension DialogAlertButtonsConfig {
  public static var openSettingsOrCancelButtonsConfig: Dialog_iOS.DialogAlertButtonsConfig {
    get
  }
  public static var cancelButtonsConfig: Dialog_iOS.DialogAlertButtonsConfig {
    get
  }
  public static var okButtonsConfig: Dialog_iOS.DialogAlertButtonsConfig {
    get
  }
}
public struct DialogAlertContext {
  public enum IdempotentId : Swift.Int {
    case endCurrentCallAndJoinNew
    case couldntConnectToCall
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
    public init?(rawValue: Swift.Int)
  }
  public static let notificationUserInfoContextKey: Swift.String
  public let title: Swift.String?
  public let message: Swift.String?
  public let style: UIKit.UIAlertController.Style
  public let buttonsConfig: Dialog_iOS.DialogAlertButtonsConfig
  public let idempotentId: Dialog_iOS.DialogAlertContext.IdempotentId?
  public init(title: Swift.String?, message: Swift.String?, style: UIKit.UIAlertController.Style, buttonsConfig: Dialog_iOS.DialogAlertButtonsConfig, idempotentId: Dialog_iOS.DialogAlertContext.IdempotentId? = nil)
}
extension DialogAlertContext {
  public static func commonOk(localizedReason: Swift.String, idempotentId: Dialog_iOS.DialogAlertContext.IdempotentId?) -> Dialog_iOS.DialogAlertContext
}
public struct DialogActivityContext {
  public let activityItems: [Any]
  public let applicationActivities: [UIKit.UIActivity]?
  public static let notificationUserInfoContextKey: Swift.String
  public init(activityItems: [Any], applicationActivities: [UIKit.UIActivity]?)
}
extension NotificationCenter {
  public func postAlertRequest(context: Dialog_iOS.DialogAlertContext)
  public func postActivityRequest(context: Dialog_iOS.DialogActivityContext)
}
extension Reactive where Base : Foundation.NotificationCenter {
  public var postAlertRequest: RxSwift.AnyObserver<Dialog_iOS.DialogAlertContext> {
    get
  }
  public var postActivityRequest: RxSwift.AnyObserver<Dialog_iOS.DialogActivityContext> {
    get
  }
  public var alertRequests: RxSwift.Observable<Dialog_iOS.DialogAlertContext> {
    get
  }
  public var activityRequests: RxSwift.Observable<Dialog_iOS.DialogActivityContext> {
    get
  }
}
extension NSNotification.Name {
  public static let presentAlertNotificationName: Foundation.NSNotification.Name
  public static let presentActivityNotificationName: Foundation.NSNotification.Name
}
@_hasMissingDesignatedInitializers public class DialogAutocompleteTableViewCellViewModel : Dialog_iOS.AvatarViewModelProtocol {
  final public let basicColor: UIKit.UIColor
  final public let isAvatarLoading: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Swift.Bool>
  final public let avatarImage: RxCocoa.Driver<UIKit.UIImage?>
  final public let avatarCenterText: RxCocoa.Driver<Swift.String?>
  public var formattedName: Foundation.NSAttributedString {
    get
    set
  }
  public var nick: Swift.String? {
    get
  }
  final public let themeService: Dialog_iOS.AppThemeService
  final public let stringForSearch: Swift.String
  final public let userDescription: Swift.String?
  @objc deinit
}
public struct DialogListAvatarViewDefaultStyle : Dialog_iOS.AvatarViewStyleProtocol, DialogProtocols.BaseStruct {
  public var centerTextFont: UIKit.UIFont
  public var centerTextColor: UIKit.UIColor
  public var cornerRadius: Dialog_iOS.CornerRadiusType
  public var avatarLoaderActivityStyle: UIKit.UIActivityIndicatorView.Style
  public var sideLength: CoreGraphics.CGFloat
  public var gradientStartPoint: CoreGraphics.CGPoint
  public var gradientEndPoint: CoreGraphics.CGPoint
  public var gradientColors: [Any]?
}
public struct ForwardTargetsAvatarViewDefaultStyle : Dialog_iOS.CheckmarkableAvatarViewStyleProtocol, DialogProtocols.BaseStruct {
  public var centerTextFont: UIKit.UIFont
  public var centerTextColor: UIKit.UIColor
  public var cornerRadius: Dialog_iOS.CornerRadiusType
  public var avatarLoaderActivityStyle: UIKit.UIActivityIndicatorView.Style
  public var sideLength: CoreGraphics.CGFloat
  public var gradientStartPoint: CoreGraphics.CGPoint
  public var gradientEndPoint: CoreGraphics.CGPoint
  public var selectionImage: UIKit.UIImage?
  public var selectionOverlayColor: UIKit.UIColor?
  public var gradientColors: [Any]?
}
public struct ConversationAvatarViewDefaultStyle : Dialog_iOS.AvatarViewStyleProtocol {
  public let centerTextFont: UIKit.UIFont
  public let cornerRadius: Dialog_iOS.CornerRadiusType
  public let centerTextColor: UIKit.UIColor
  public let avatarLoaderActivityStyle: UIKit.UIActivityIndicatorView.Style
  public let sideLength: CoreGraphics.CGFloat
  public let gradientStartPoint: CoreGraphics.CGPoint
  public let gradientEndPoint: CoreGraphics.CGPoint
  public var gradientColors: [Any]?
}
extension MappedCallParameters {
  public var formattedTitle: Swift.String? {
    get
  }
}
public protocol DialogCallsIntentsServiceProtocol {
}
public class DialogCallsIntentsService : Dialog_iOS.DialogCallsIntentsServiceProtocol {
  public init(eventBusService: DialogProtocols.EventBusServiceProtocol)
  @objc deinit
}
public enum DialogCallsSimpleSearcherState : Swift.Equatable {
  case idle
  case searching
  case results([DialogProtocols.DialogHistoryCall])
  public static func == (lhs: Dialog_iOS.DialogCallsSimpleSearcherState, rhs: Dialog_iOS.DialogCallsSimpleSearcherState) -> Swift.Bool
}
public protocol DialogCallsSimpleSearcherProtocol {
  var state: RxSwift.Observable<Dialog_iOS.DialogCallsSimpleSearcherState> { get }
  var search: RxSwift.AnyObserver<Swift.String> { get }
}
final public class DialogCallsSimpleSearcher : Dialog_iOS.DialogCallsSimpleSearcherProtocol {
  public struct Config : DialogProtocols.BaseStruct {
    public var remoteSearchLimit: Swift.Int
    public var remoteSearchQueryMinLength: Swift.Int
    public var stateCombinationDebounce: Dispatch.DispatchTimeInterval
    public static let `default`: Dialog_iOS.DialogCallsSimpleSearcher.Config
  }
  final public let state: RxSwift.Observable<Dialog_iOS.DialogCallsSimpleSearcherState>
  final public let search: RxSwift.AnyObserver<Swift.String>
  public init(localSearch: DialogSearching.LocalCallSearchServiceProtocol, remoteSearch: DialogCalls.DialogCallHistorySearchServiceProtocol, config: Dialog_iOS.DialogCallsSimpleSearcher.Config = .default)
  @objc deinit
}
extension DialogCurrentForwardsState {
  public static func update() -> (DialogProtocols.BusEvent, DialogProtocols.DialogCurrentForwardsState) -> DialogProtocols.DialogCurrentForwardsState
}
extension DialogFeatureFlagsServiceProtocol {
  public var availableBeginCallTypes: RxSwift.Observable<[DialogProtocols.AccessibleCallType]> {
    get
  }
  public var isConferenceEnabledAndAnnounced: RxSwift.Observable<Swift.Bool> {
    get
  }
  public var isConferenceEnabledAndNotAnnounced: RxSwift.Observable<Swift.Bool> {
    get
  }
}
extension DialogFileDownloadError {
  public var localizedDescription: Swift.String {
    get
  }
}
extension DialogFileUploadError {
  public var localizedDescription: Swift.String {
    get
  }
}
extension DialogGroup {
  public var avatarCenterText: Swift.String {
    get
  }
}
public enum DialogGroupType : Swift.Int, Swift.CaseIterable {
  case all
  case unread
  case people
  case groups
  case channels
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
  public typealias AllCases = [Dialog_iOS.DialogGroupType]
  public static var allCases: [Dialog_iOS.DialogGroupType] {
    get
  }
}
public protocol DialogGroupingViewModelProtocol : AnyObject {
  var activate: RxSwift.AnyObserver<Dialog_iOS.DialogGroupType> { get }
  var items: RxRelay.BehaviorRelay<[Dialog_iOS.DialogGroupingItemViewModelProtocol]> { get }
  var generalThemeColor: RxCocoa.Driver<UIKit.UIColor?> { get }
  var backgroundColor: RxCocoa.Driver<UIKit.UIColor> { get }
  var willReload: RxCocoa.Driver<Dialog_iOS.DialogGroupType> { get }
}
public protocol DialogGroupingItemViewModelProtocol : AnyObject {
  var setActive: RxSwift.AnyObserver<Swift.Bool> { get }
  var type: Dialog_iOS.DialogGroupType { get }
  var isActive: RxCocoa.Driver<Swift.Bool> { get }
  var activeColor: RxCocoa.Driver<UIKit.UIColor> { get }
  var unreadCount: RxSwift.BehaviorSubject<Swift.String?> { get }
}
public class DialogGroupingItemViewModel : Dialog_iOS.DialogGroupingItemViewModelProtocol {
  public var setActive: RxSwift.AnyObserver<Swift.Bool>
  public var type: Dialog_iOS.DialogGroupType
  public var isActive: RxCocoa.Driver<Swift.Bool>
  public var activeColor: RxCocoa.Driver<UIKit.UIColor>
  public var unreadCount: RxSwift.BehaviorSubject<Swift.String?>
  public init(type: Dialog_iOS.DialogGroupType, theme: Dialog_iOS.AppThemeService, unread: RxSwift.Observable<Swift.Int>)
  @objc deinit
}
extension DialogGroupMember {
  public var isAdmin: Swift.Bool {
    get
  }
}
public protocol DialogHeaderViewModelProtocol : DialogSharedComponents.AvatarViewModelProtocol, Dialog_iOS.ViewModelProtocol {
  var headerTitle: RxCocoa.Driver<Swift.String?> { get }
  var headerDescription: RxCocoa.Driver<Dialog_iOS.HeaderDescriptionMode> { get }
  var typingViewModel: Dialog_iOS.UserStatusViewModelProtocol { get }
  var didTapHeader: RxSwift.AnyObserver<Swift.Void> { get }
}
public enum HeaderDescriptionMode {
  case selection(Swift.String)
  case membersAmount(Swift.Int)
  case typing([Swift.String])
  case online(Swift.String)
  case none
}
extension HeaderDescriptionMode : Swift.Equatable {
  public static func == (lhs: Dialog_iOS.HeaderDescriptionMode, rhs: Dialog_iOS.HeaderDescriptionMode) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers final public class DialogHeaderView : UIKit.UIView {
  @objc override final public var intrinsicContentSize: CoreGraphics.CGSize {
    @objc get
  }
  @objc override final public func tintColorDidChange()
  @objc override final public func layoutSubviews()
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public protocol DialogItemContentStringBuilderProtocol {
  typealias Source = (message: DialogProtocols.DialogMessage?, dialog: DialogProtocols.DialogState, users: [Swift.Int32 : DialogProtocols.DialogUser], draft: DialogProtocols.DialogMyDraft?)
  func buildContentString(source: RxSwift.Observable<Self.Source>, design: RxSwift.Observable<Dialog_iOS.DialogsListCellDesignProtocol>, scheduler: RxSwift.ImmediateSchedulerType) -> RxSwift.Observable<Foundation.NSAttributedString>
}
final public class DialogItemContentStringBuilder : Dialog_iOS.DialogItemContentStringBuilderProtocol {
  public struct Components {
  }
  final public let myId: DialogProtocols.DialogUserId
  public init(myId: DialogProtocols.DialogUserId, eventBus: DialogProtocols.EventBusServiceProtocol, featureFlagsService: DialogProtocols.DialogFeatureFlagsServiceProtocol)
  final public func buildContentString(source: RxSwift.Observable<Dialog_iOS.DialogItemContentStringBuilder.Source>, design: RxSwift.Observable<Dialog_iOS.DialogsListCellDesignProtocol>, scheduler: RxSwift.ImmediateSchedulerType) -> RxSwift.Observable<Foundation.NSAttributedString>
  @objc deinit
}
@objc @_inheritsConvenienceInitializers final public class DialogListSearchLoadingCell : UIKit.UITableViewCell {
  final public var spinner: UIKit.UIActivityIndicatorView
  @objc override dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers final public class DialogListSearchLoadMoreCell : Dialog_iOS.DisposableTableViewCell {
  @objc @IBOutlet final public var titleLabel: UIKit.UILabel!
  @objc @IBOutlet final public var frameView: UIKit.UIView!
  @objc override dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  final public func bind(viewModel: Dialog_iOS.DialogListSearchLoadMoreCellViewModelProtocol)
  @objc deinit
}
public typealias DialogListSearchResultsSceneViewController = UIKit.UIViewController
@_inheritsConvenienceInitializers final public class DialogListSearchResultsScene : Dialog_iOS.Scene<Swift.Void, Dialog_iOS.DialogListSearchResultsSceneViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.AnySceneBuilder<Dialog_iOS.DialogListSearchResultsSceneViewController, Swift.Void>
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<Swift.Void, Dialog_iOS.DialogListSearchResultsSceneViewController, Dialog_iOS.DialogListSearchViewModelProtocol> {
    override final public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>) -> Dialog_iOS.DialogListSearchViewModelProtocol
    override final public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>, viewModel: Dialog_iOS.DialogListSearchViewModelProtocol) -> Dialog_iOS.DialogListSearchResultsSceneViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<Swift.Void, Dialog_iOS.DialogListSearchResultsSceneViewController>.Builder = super, resolver: Swinject.Resolver)
}
public struct DialogListSearchTableData : Swift.Equatable {
  public typealias ResultViewModel = Dialog_iOS.DialogListSearchResultCellViewModelProtocol
  public typealias LoadingViewModel = Dialog_iOS.DialogListSearchLoadingCellViewModelProtocol
  public typealias NoResultsViewModel = Dialog_iOS.DialogListSearchNoResultsCellViewModelProtocol
  public typealias LoadMoreViewModel = Dialog_iOS.DialogListSearchLoadMoreCellViewModelProtocol
  public enum RowViewModelKey : Swift.Hashable {
    public enum Peer : Swift.Hashable {
      case group(peer: DialogProtocols.DialogGroupId)
      case user(peer: DialogProtocols.DialogUserId)
      public var hashValue: Swift.Int {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: Dialog_iOS.DialogListSearchTableData.RowViewModelKey.Peer, b: Dialog_iOS.DialogListSearchTableData.RowViewModelKey.Peer) -> Swift.Bool
    }
    case loading(sectionKind: Dialog_iOS.DialogListSearchTableData.SectionKind)
    case noResults(sectionKind: Dialog_iOS.DialogListSearchTableData.SectionKind)
    case peer(sectionsKind: Dialog_iOS.DialogListSearchTableData.SectionKind, peer: Dialog_iOS.DialogListSearchTableData.RowViewModelKey.Peer)
    case loadMore(sectionKind: Dialog_iOS.DialogListSearchTableData.SectionKind)
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Dialog_iOS.DialogListSearchTableData.RowViewModelKey, b: Dialog_iOS.DialogListSearchTableData.RowViewModelKey) -> Swift.Bool
  }
  public enum Row : Swift.Hashable {
    case result(Dialog_iOS.DialogListSearchTableData.ResultViewModel)
    case loading(Dialog_iOS.DialogListSearchTableData.LoadingViewModel)
    case noResults(Dialog_iOS.DialogListSearchTableData.NoResultsViewModel)
    case loadMore(Dialog_iOS.DialogListSearchTableData.LoadMoreViewModel)
    public var basicViewModel: Dialog_iOS.DialogListSearchBasicCellViewModelProtocol {
      get
    }
    public var key: Dialog_iOS.DialogListSearchTableData.RowViewModelKey {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (lhs: Dialog_iOS.DialogListSearchTableData.Row, rhs: Dialog_iOS.DialogListSearchTableData.Row) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let empty: Dialog_iOS.DialogListSearchTableData
  public typealias Section = Differentiator.SectionModel<Dialog_iOS.DialogListSearchTableData.SectionKind, Dialog_iOS.DialogListSearchTableData.Row>
  public enum SectionKind : Swift.Equatable {
    case local
    case users
    case groups
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: Dialog_iOS.DialogListSearchTableData.SectionKind, b: Dialog_iOS.DialogListSearchTableData.SectionKind) -> Swift.Bool
  }
  public var sections: [Dialog_iOS.DialogListSearchTableData.Section]
  public init(sections: [Dialog_iOS.DialogListSearchTableData.Section])
  public static func == (lhs: Dialog_iOS.DialogListSearchTableData, rhs: Dialog_iOS.DialogListSearchTableData) -> Swift.Bool
}
extension DialogListSearchViewModel {
  final public class TableDataBuilder {
    public struct Config : DialogProtocols.BaseStruct, Swift.Equatable {
      public static let `default`: Dialog_iOS.DialogListSearchViewModel.TableDataBuilder.Config
      public var showSpinnerWhileLoadingAvatar: Swift.Bool
      public var contactAccessoryAction: Dialog_iOS.DialogListSearchViewModel.Config.ContactAccessoryAction
      public var sectionsToBuild: Dialog_iOS.DialogListSearchViewModel.Config.SectionsMask
      public static func == (a: Dialog_iOS.DialogListSearchViewModel.TableDataBuilder.Config, b: Dialog_iOS.DialogListSearchViewModel.TableDataBuilder.Config) -> Swift.Bool
    }
    public enum Event {
      case didTapUser(DialogProtocols.DialogUser)
      case didTapGroup(DialogProtocols.DialogGroup)
    }
    final public let filesService: DialogFiles.DialogFileServiceProtocol
    final public let colorService: Dialog_iOS.DialogPeerColorsServiceProtocol
    final public let featureFlagService: DialogProtocols.DialogFeatureFlagsServiceProtocol
    final public let contactsService: DialogMessaging.DialogContactsServiceProtocol
    final public var events: RxSwift.Observable<Dialog_iOS.DialogListSearchViewModel.TableDataBuilder.Event> {
      get
    }
    public init(filesService: DialogFiles.DialogFileServiceProtocol, colorService: Dialog_iOS.DialogPeerColorsServiceProtocol, featureFlagService: DialogProtocols.DialogFeatureFlagsServiceProtocol, contactsService: DialogMessaging.DialogContactsServiceProtocol, loadMoreTrigger: RxSwift.AnyObserver<DialogSearching.CombinedSearchLoadMoreTarget>, imageTintColor: RxSwift.Observable<UIKit.UIColor?> = .just(nil), config: RxSwift.Observable<Dialog_iOS.DialogListSearchViewModel.TableDataBuilder.Config>, myId: DialogProtocols.DialogUserId)
    @objc deinit
  }
}
public struct DialogListSearchStyle : Swift.Equatable {
  public static let `default`: Dialog_iOS.DialogListSearchStyle
  public var headerBackgroundColor: UIKit.UIColor
  public var separatorLeftInset: CoreGraphics.CGFloat
  public var cellCommonFont: UIKit.UIFont
  public var cellSecondaryFont: UIKit.UIFont
  public var cellHeight: CoreGraphics.CGFloat
  public var cellCommonTextColor: UIKit.UIColor
  public var resultCellContentInsets: UIKit.UIEdgeInsets
  public var loadingSpinnerColor: UIKit.UIColor
  public var sectionHeaderHeight: CoreGraphics.CGFloat
  public var sectionHeaderTextFont: UIKit.UIFont
  public var sectionHeaderTextColor: UIKit.UIColor
  public var loadMoreCellBorderRadius: CoreGraphics.CGFloat
  public var loadMoreCellFrameBackground: UIKit.UIColor
  public var loadMoreCellFrameInsets: UIKit.UIEdgeInsets
  public static func == (a: Dialog_iOS.DialogListSearchStyle, b: Dialog_iOS.DialogListSearchStyle) -> Swift.Bool
}
@objc @_hasMissingDesignatedInitializers final public class DialogListSearchViewController : UIKit.UITableViewController, UIKit.UISearchResultsUpdating {
  public init(viewModel: Dialog_iOS.DialogListSearchViewModelProtocol, style: RxSwift.Observable<Dialog_iOS.DialogListSearchStyle> = .just(.default))
  @objc override final public func viewDidLoad()
  @objc override final public func numberOfSections(in tableView: UIKit.UITableView) -> Swift.Int
  @objc override final public func tableView(_ tableView: UIKit.UITableView, numberOfRowsInSection section: Swift.Int) -> Swift.Int
  @objc override final public func tableView(_ tableView: UIKit.UITableView, cellForRowAt indexPath: Foundation.IndexPath) -> UIKit.UITableViewCell
  @objc override final public func tableView(_ tableView: UIKit.UITableView, titleForHeaderInSection section: Swift.Int) -> Swift.String?
  @objc override final public func tableView(_ tableView: UIKit.UITableView, viewForHeaderInSection section: Swift.Int) -> UIKit.UIView?
  @objc override final public func tableView(_ tableView: UIKit.UITableView, heightForHeaderInSection section: Swift.Int) -> CoreGraphics.CGFloat
  @objc override final public func tableView(_ tableView: UIKit.UITableView, heightForRowAt indexPath: Foundation.IndexPath) -> CoreGraphics.CGFloat
  @objc override final public func tableView(_ tableView: UIKit.UITableView, didSelectRowAt indexPath: Foundation.IndexPath)
  @objc final public func updateSearchResults(for searchController: UIKit.UISearchController)
  @objc override dynamic public init(style: UIKit.UITableView.Style)
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc deinit
}
extension DialogListSearchViewModel {
  public class ChildViewModel : Dialog_iOS.DialogListSearchBasicCellViewModelProtocol {
    final public let rowKey: Dialog_iOS.DialogListSearchTableData.RowViewModelKey
    public var onDidTap: RxSwift.AnyObserver<Swift.Void>
    public init(key: Dialog_iOS.DialogListSearchTableData.RowViewModelKey)
    @objc deinit
  }
  @_inheritsConvenienceInitializers final public class LoadMoreViewModel : Dialog_iOS.DialogListSearchViewModel.ChildViewModel, Dialog_iOS.DialogListSearchLoadMoreCellViewModelProtocol {
    final public let title: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Swift.String>
    convenience public init(sectionKind: Dialog_iOS.DialogListSearchViewModel.TableData.Section.Identity)
    override public init(key: Dialog_iOS.DialogListSearchTableData.RowViewModelKey)
    @objc deinit
  }
  @_inheritsConvenienceInitializers final public class LoadingViewModel : Dialog_iOS.DialogListSearchViewModel.ChildViewModel, Dialog_iOS.DialogListSearchLoadingCellViewModelProtocol {
    final public let requestDescription: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Swift.String>
    convenience public init(sectionKind: Dialog_iOS.DialogListSearchViewModel.TableData.Section.Identity)
    override public init(key: Dialog_iOS.DialogListSearchTableData.RowViewModelKey)
    @objc deinit
  }
  @_inheritsConvenienceInitializers final public class NoResultsViewModel : Dialog_iOS.DialogListSearchViewModel.ChildViewModel, Dialog_iOS.DialogListSearchNoResultsCellViewModelProtocol {
    final public var placeholder: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Swift.String>
    convenience public init(sectionKind: Dialog_iOS.DialogListSearchViewModel.TableData.Section.Identity)
    @objc deinit
    override public init(key: Dialog_iOS.DialogListSearchTableData.RowViewModelKey)
  }
  final public class ResultItemViewModel : Dialog_iOS.DialogListSearchViewModel.ChildViewModel, Dialog_iOS.DialogListSearchResultCellViewModelProtocol {
    final public var isForGroup: Swift.Bool
    @_hasMissingDesignatedInitializers public class AvatarViewModel : Dialog_iOS.AvatarViewModelProtocol {
      public var basicColor: UIKit.UIColor
      public var isAvatarLoading: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Swift.Bool>
      public var avatarImage: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, UIKit.UIImage?>
      public var avatarCenterText: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Swift.String?>
      @objc deinit
    }
    final public var avatar: Dialog_iOS.AvatarViewModelProtocol
    final public var title: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Swift.String>
    final public var description: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Swift.String?>
    final public var actionViewModel: Dialog_iOS.DialogListSearchResultActionViewModelProtocol
    final public let isFavorites: Swift.Bool
    public init(sectionKind: Dialog_iOS.DialogListSearchViewModel.TableData.Section.Identity, peer: Dialog_iOS.DialogListSearchViewModel.TableData.RowViewModelKey.Peer, isFavorites: Swift.Bool)
    override public init(key: Dialog_iOS.DialogListSearchTableData.RowViewModelKey)
    @objc deinit
  }
  @_hasMissingDesignatedInitializers final public class ResultItemActionViewModel : Dialog_iOS.DialogListSearchResultActionViewModelProtocol {
    final public var didTapRightAction: RxSwift.AnyObserver<Swift.Void>
    final public var rightActionButtonIcon: RxCocoa.Driver<UIKit.UIImage?>
    final public var rightActionActivityIndicatorIsLoading: RxCocoa.Driver<Swift.Bool>
    final public var enabled: RxCocoa.Driver<Swift.Bool>
    @objc deinit
  }
}
public protocol DialogListSearchBasicCellViewModelProtocol {
  var rowKey: Dialog_iOS.DialogListSearchTableData.RowViewModelKey { get }
  var onDidTap: RxSwift.AnyObserver<Swift.Void> { get }
}
public protocol DialogListSearchResultActionViewModelProtocol {
  var didTapRightAction: RxSwift.AnyObserver<Swift.Void> { get }
  var enabled: RxCocoa.Driver<Swift.Bool> { get }
  var rightActionActivityIndicatorIsLoading: RxCocoa.Driver<Swift.Bool> { get }
  var rightActionButtonIcon: RxCocoa.Driver<UIKit.UIImage?> { get }
}
public protocol DialogListSearchLoadMoreCellViewModelProtocol : Dialog_iOS.DialogListSearchBasicCellViewModelProtocol {
  var title: RxCocoa.Driver<Swift.String> { get }
}
public protocol DialogListSearchResultCellViewModelProtocol : Dialog_iOS.DialogListSearchBasicCellViewModelProtocol {
  var avatar: Dialog_iOS.AvatarViewModelProtocol { get }
  var title: RxCocoa.Driver<Swift.String> { get }
  var description: RxCocoa.Driver<Swift.String?> { get }
  var isForGroup: Swift.Bool { get }
  var actionViewModel: Dialog_iOS.DialogListSearchResultActionViewModelProtocol { get }
}
public protocol DialogListSearchLoadingCellViewModelProtocol : Dialog_iOS.DialogListSearchBasicCellViewModelProtocol {
  var requestDescription: RxCocoa.Driver<Swift.String> { get }
}
public protocol DialogListSearchNoResultsCellViewModelProtocol : Dialog_iOS.DialogListSearchBasicCellViewModelProtocol {
  var placeholder: RxCocoa.Driver<Swift.String> { get }
}
public protocol DialogListSearchViewModelProtocol {
  var search: RxSwift.AnyObserver<Swift.String?> { get }
  var tableData: RxCocoa.Driver<Dialog_iOS.DialogListSearchTableData> { get }
  var themeService: Dialog_iOS.AppThemeService { get }
}
final public class DialogListSearchViewModel : Dialog_iOS.DialogListSearchViewModelProtocol {
  public struct Config : Swift.Equatable {
    public enum UserTapBehavior {
      case openChat
      case openProfile
      public static let `default`: Dialog_iOS.DialogListSearchViewModel.Config.UserTapBehavior
      public static func == (a: Dialog_iOS.DialogListSearchViewModel.Config.UserTapBehavior, b: Dialog_iOS.DialogListSearchViewModel.Config.UserTapBehavior) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
    }
    public struct SectionsMask : Swift.OptionSet, Swift.Hashable {
      public typealias RawValue = Swift.Int
      public var rawValue: Dialog_iOS.DialogListSearchViewModel.Config.SectionsMask.RawValue
      public init(rawValue: Dialog_iOS.DialogListSearchViewModel.Config.SectionsMask.RawValue)
      public static let local: Dialog_iOS.DialogListSearchViewModel.Config.SectionsMask
      public static let users: Dialog_iOS.DialogListSearchViewModel.Config.SectionsMask
      public static let groups: Dialog_iOS.DialogListSearchViewModel.Config.SectionsMask
      public static let all: Dialog_iOS.DialogListSearchViewModel.Config.SectionsMask
      public static let `default`: Dialog_iOS.DialogListSearchViewModel.Config.SectionsMask
      public typealias Element = Dialog_iOS.DialogListSearchViewModel.Config.SectionsMask
      public typealias ArrayLiteralElement = Dialog_iOS.DialogListSearchViewModel.Config.SectionsMask
    }
    public enum ContactAccessoryAction : Swift.Hashable {
      case none
      case addToContacts
      case call
      public static let `default`: Dialog_iOS.DialogListSearchViewModel.Config.ContactAccessoryAction
      public static func == (a: Dialog_iOS.DialogListSearchViewModel.Config.ContactAccessoryAction, b: Dialog_iOS.DialogListSearchViewModel.Config.ContactAccessoryAction) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
    }
    public static let `default`: Dialog_iOS.DialogListSearchViewModel.Config
    public var userTapBehavior: Dialog_iOS.DialogListSearchViewModel.Config.UserTapBehavior
    public var emptyStateDialogsLimit: Swift.Int
    public var contactAccessoryAction: Dialog_iOS.DialogListSearchViewModel.Config.ContactAccessoryAction
    public var sectionsToPresent: Dialog_iOS.DialogListSearchViewModel.Config.SectionsMask
    public static func == (a: Dialog_iOS.DialogListSearchViewModel.Config, b: Dialog_iOS.DialogListSearchViewModel.Config) -> Swift.Bool
  }
  public enum Mode {
    case common
    case contacts
    public static func == (a: Dialog_iOS.DialogListSearchViewModel.Mode, b: Dialog_iOS.DialogListSearchViewModel.Mode) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public typealias TableData = Dialog_iOS.DialogListSearchTableData
  public typealias Sources = (dialogs: RxSwift.Observable<[DialogProtocols.DialogState]>, users: RxSwift.Observable<[DialogProtocols.DialogUserId : DialogProtocols.DialogUser]>, groups: RxSwift.Observable<[DialogProtocols.DialogGroupId : DialogProtocols.DialogGroup]>)
  final public var search: RxSwift.AnyObserver<Swift.String?>
  final public let tableData: RxCocoa.Driver<Dialog_iOS.DialogListSearchTableData>
  final public let themeService: Dialog_iOS.AppThemeService
  public init(eventBusService: DialogProtocols.EventBusServiceProtocol, searchService: DialogSearching.CombinedSearchServiceProtocol, filesService: DialogFiles.DialogFileServiceProtocol, colorService: Dialog_iOS.DialogPeerColorsServiceProtocol, dialogSortingService: Dialog_iOS.DialogSortingServiceProtocol, contactsService: DialogMessaging.DialogContactsServiceProtocol, featureFlagService: DialogProtocols.DialogFeatureFlagsServiceProtocol, appThemeService: Dialog_iOS.AppThemeService, sources: Dialog_iOS.DialogListSearchViewModel.Sources, routerService: Dialog_iOS.RouterServiceProtocol, router: Dialog_iOS.UserSpecifiedRouterProtocol, forwardSource: Dialog_iOS.ForwardTargetsListSource, resultsModifier: DialogSearching.CombinedSearchStateModifierProtocol? = nil, config: RxSwift.Observable<Dialog_iOS.DialogListSearchViewModel.Config>, mode: Dialog_iOS.DialogListSearchViewModel.Mode = .common, myId: DialogProtocols.DialogUserId)
  @objc deinit
}
public protocol DialogListSectionBuilderProtocol {
  func buildSections(dialogs: RxSwift.Observable<[DialogProtocols.DialogState]>, lastMessages: RxSwift.Observable<DialogProtocols.DialogLastMessagesState>, activeGroups: RxSwift.Observable<DialogProtocols.DialogActiveGroupsState>, drafts: RxSwift.Observable<DialogProtocols.DialogMyDraftsState>) -> RxSwift.Observable<[Dialog_iOS.DialogsListSection]>
}
final public class DialogListSectionBuilder : Dialog_iOS.DialogListSectionBuilderProtocol {
  public init(dispatcher: Dialog_iOS.DialogListSectionDispatcherProtocol, cellViewModelBuilder: Dialog_iOS.DialogListSectionCellViewModelBuilderProtocol, design: RxSwift.Observable<Dialog_iOS.DialogsListCellDesignProtocol>)
  final public func buildSections(dialogs: RxSwift.Observable<[DialogProtocols.DialogState]>, lastMessages: RxSwift.Observable<DialogProtocols.DialogLastMessagesState>, activeGroups: RxSwift.Observable<DialogProtocols.DialogActiveGroupsState>, drafts: RxSwift.Observable<DialogProtocols.DialogMyDraftsState>) -> RxSwift.Observable<[Dialog_iOS.DialogsListSection]>
  @objc deinit
}
public protocol DialogListSectionCellViewModelBuilderProtocol {
  func buildCellViewModel(dialog: DialogProtocols.DialogState, drafts: RxSwift.Observable<DialogProtocols.DialogMyDraftsState>, design: RxSwift.Observable<Dialog_iOS.DialogsListCellDesignProtocol>) -> Dialog_iOS.DialogsListCellViewModel
}
open class DialogListSectionCellViewModelBuilder : Dialog_iOS.DialogListSectionCellViewModelBuilderProtocol {
  final public let myId: DialogProtocols.DialogUserId
  public init(swipeActionConfigurator: Dialog_iOS.DialogsListCellSwipeActionConfiguratorProtocol, fileService: DialogFiles.DialogFileServiceProtocol, eventBusService: DialogProtocols.EventBusServiceProtocol, muteService: DialogMuteSettingsService.DialogMuteSettingsServiceProtocol, colorService: Dialog_iOS.DialogPeerColorsServiceProtocol, myId: DialogProtocols.DialogUserId, presenceService: DialogProtocols.UserPresenceStateServiceProtocol, themeService: Dialog_iOS.AppThemeService, featureFlagsService: DialogProtocols.DialogFeatureFlagsServiceProtocol)
  public func buildCellViewModel(dialog: DialogProtocols.DialogState, drafts: RxSwift.Observable<DialogProtocols.DialogMyDraftsState>, design: RxSwift.Observable<Dialog_iOS.DialogsListCellDesignProtocol>) -> Dialog_iOS.DialogsListCellViewModel
  @objc deinit
}
open class ForwardDialogListSectionCellViewModelBuilder : Dialog_iOS.DialogListSectionCellViewModelBuilder {
  public init(swipeActionConfigurator: Dialog_iOS.DialogsListCellSwipeActionConfiguratorProtocol, fileService: DialogFiles.DialogFileServiceProtocol, eventBusService: DialogProtocols.EventBusServiceProtocol, muteService: DialogMuteSettingsService.DialogMuteSettingsServiceProtocol, colorService: Dialog_iOS.DialogPeerColorsServiceProtocol, forwardTargetListAppliableDispatcher: Dialog_iOS.ForwardTargetListAppliableDispatcherProtocol, myId: DialogProtocols.DialogUserId, presenceService: DialogProtocols.UserPresenceStateServiceProtocol, themeService: Dialog_iOS.AppThemeService, featureFlagsService: DialogProtocols.DialogFeatureFlagsServiceProtocol)
  override public func buildCellViewModel(dialog: DialogProtocols.DialogState, drafts: RxSwift.Observable<DialogProtocols.DialogMyDraftsState>, design: RxSwift.Observable<Dialog_iOS.DialogsListCellDesignProtocol>) -> Dialog_iOS.DialogsListCellViewModel
  @objc deinit
  override public init(swipeActionConfigurator: Dialog_iOS.DialogsListCellSwipeActionConfiguratorProtocol, fileService: DialogFiles.DialogFileServiceProtocol, eventBusService: DialogProtocols.EventBusServiceProtocol, muteService: DialogMuteSettingsService.DialogMuteSettingsServiceProtocol, colorService: Dialog_iOS.DialogPeerColorsServiceProtocol, myId: DialogProtocols.DialogUserId, presenceService: DialogProtocols.UserPresenceStateServiceProtocol, themeService: Dialog_iOS.AppThemeService, featureFlagsService: DialogProtocols.DialogFeatureFlagsServiceProtocol)
}
public protocol DialogListSectionDispatcherProtocol {
  func dispatch(dialogs: RxSwift.Observable<[DialogProtocols.DialogState]>, lastMessages: RxSwift.Observable<DialogProtocols.DialogLastMessagesState>, activeGroups: RxSwift.Observable<DialogProtocols.DialogActiveGroupsState>) -> RxSwift.Observable<[Dialog_iOS.DialogsListSection.SectionType : [DialogProtocols.DialogState]]>
  func dispatch(dialogs: RxSwift.Observable<[DialogProtocols.DialogState]>, lastMessages: RxSwift.Observable<DialogProtocols.DialogLastMessagesState>, activeGroups: RxSwift.Observable<DialogProtocols.DialogActiveGroupsState>, time: RxSwift.RxTimeInterval, scheduler: RxSwift.SchedulerType) -> RxSwift.Observable<[Dialog_iOS.DialogsListSection.SectionType : [DialogProtocols.DialogState]]>
}
@_hasMissingDesignatedInitializers final public class DialogListSectionDispatcher : Dialog_iOS.DialogListSectionDispatcherProtocol {
  public static let kdefaultDialogListDebounceTime: Dispatch.DispatchTimeInterval
  public static let kdefaultDispatchScheduler: RxSwift.SerialDispatchQueueScheduler
  final public func dispatch(dialogs: RxSwift.Observable<[DialogProtocols.DialogState]>, lastMessages: RxSwift.Observable<DialogProtocols.DialogLastMessagesState>, activeGroups: RxSwift.Observable<DialogProtocols.DialogActiveGroupsState>) -> RxSwift.Observable<[Dialog_iOS.DialogsListSection.SectionType : [DialogProtocols.DialogState]]>
  final public func dispatch(dialogs: RxSwift.Observable<[DialogProtocols.DialogState]>, lastMessages: RxSwift.Observable<DialogProtocols.DialogLastMessagesState>, activeGroups: RxSwift.Observable<DialogProtocols.DialogActiveGroupsState>, time: RxSwift.RxTimeInterval, scheduler: RxSwift.SchedulerType) -> RxSwift.Observable<[Dialog_iOS.DialogsListSection.SectionType : [DialogProtocols.DialogState]]>
  @objc deinit
}
public protocol DialogListSearchResultsViewModelProtocol {
  var search: RxSwift.AnyObserver<Swift.String?> { get }
  var isSearching: RxSwift.Observable<Swift.Bool> { get }
}
open class DialogListSearchEmbedBaseViewModel : Dialog_iOS.DialogListSearchResultsViewModelProtocol {
  public var search: RxSwift.AnyObserver<Swift.String?>
  public var isSearching: RxSwift.Observable<Swift.Bool>
  public var objectsToRetain: [Any]
  public init()
  @objc deinit
}
public protocol DialogListHeavySearchResultsViewModelProtocol : Dialog_iOS.DialogListSearchResultsViewModelProtocol {
  var state: RxSwift.Observable<DialogSearching.CombinedSearchState> { get }
}
@_inheritsConvenienceInitializers final public class DialogListHeavySearchResultsViewModel : Dialog_iOS.DialogListSearchEmbedBaseViewModel, Dialog_iOS.DialogListHeavySearchResultsViewModelProtocol {
  final public var beginDialog: RxSwift.Observable<DialogProtocols.DialogPeer>!
  final public var state: RxSwift.Observable<DialogSearching.CombinedSearchState>
  convenience public init(searchService: DialogSearching.CombinedSearchServiceProtocol, routerService: Dialog_iOS.RouterServiceProtocol)
  @objc deinit
  override public init()
}
public enum DialogListViewModelSearch {
  case none
  case embed(Dialog_iOS.DialogListSearchResultsViewModelProtocol)
  case heavy((UIKit.UIViewController & UIKit.UISearchResultsUpdating))
  public var supportsSearch: Swift.Bool {
    get
  }
  public var search: RxSwift.AnyObserver<Swift.String?> {
    get
  }
}
public func DialogLocalizedString(_ text: Swift.String, comment: Swift.String = "") -> Swift.String
public func DialogLocalizedString(_ text: Swift.String, comment: Swift.String = "", arguments: Swift.CVarArg...) -> Swift.String
public func DialogLocalizedPluralString(_ text: Swift.String, comment: Swift.String = "", declension: Swift.Int) -> Swift.String
public func DialogLocalizedPluralString(_ text: Swift.String, comment: Swift.String = "", declension: Swift.Int, arguments: Swift.CVarArg...) -> Swift.String
extension BubbleDesignProtocol {
  public var bubbleInsets: UIKit.UIEdgeInsets {
    get
  }
  public var contentInsets: UIKit.UIEdgeInsets {
    get
  }
  public var cornerInsets: UIKit.UIEdgeInsets {
    get
  }
  public var statusCornerRadius: CoreGraphics.CGFloat {
    get
  }
  public var statusInsets: UIKit.UIEdgeInsets {
    get
  }
  public var statusBackgroundColor: UIKit.UIColor {
    get
  }
}
public struct DialogDefaultBubbleStyle : Dialog_iOS.BubbleDesignProtocol {
  public let statusBackgroundColor: UIKit.UIColor
}
public struct DialogPhotoBubbleStyle : Dialog_iOS.BubbleDesignProtocol {
  public let statusBackgroundColor: UIKit.UIColor
  public let contentInsets: UIKit.UIEdgeInsets
}
public struct DialogAudioBubbleStyle : Dialog_iOS.BubbleDesignProtocol {
  public var contentInsets: UIKit.UIEdgeInsets {
    get
  }
  public let statusBackgroundColor: UIKit.UIColor
}
public struct DialogStickerBubbleStyle : Dialog_iOS.BubbleDesignProtocol {
  public var contentInsets: UIKit.UIEdgeInsets {
    get
  }
}
public struct DialogEmojiBubbleStyle : Dialog_iOS.BubbleDesignProtocol {
}
@_hasMissingDesignatedInitializers public class DialogTextMessageBubbleStyle {
  final public let paragraphStyle: UIKit.NSParagraphStyle
  public func messageTextFont(shouldDisplayLargeEmoji: Swift.Bool) -> UIKit.UIFont
  final public let messageTextColor: UIKit.UIColor
  final public let messageTextLabelMaxLinesCount: Swift.UInt
  @objc deinit
}
@_hasMissingDesignatedInitializers public class DialogMyTextMessageBubbleStyle {
  final public let paragraphStyle: UIKit.NSParagraphStyle
  public func messageTextFont(shouldDisplayLargeEmoji: Swift.Bool = false) -> UIKit.UIFont
  final public let messageTextColor: UIKit.UIColor
  final public let messageTextLabelMaxLinesCount: Swift.UInt
  @objc deinit
}
public struct DialogPhotoMessageBubbleStyle : Dialog_iOS.PhotoMessageCellDesignProtocol {
  public let messageMaxPhotoHeight: CoreGraphics.CGFloat
  public let undefinedPhotoSize: CoreGraphics.CGSize
  public let minCellHeight: CoreGraphics.CGFloat
}
@_hasMissingDesignatedInitializers public class DialogVideoMessageBubbleStyle : Dialog_iOS.VideoMessageDesignProtocol {
  final public let messageVideoCornerRadius: DialogSharedComponents.CornerRadiusType
  final public let messageMaxVideoHeight: CoreGraphics.CGFloat
  final public let fileSizeInfoTextAttributes: [Foundation.NSAttributedString.Key : Any]?
  final public let fileSizeInfoInsets: UIKit.UIEdgeInsets
  final public let fileSizeInfoWrapperInsets: UIKit.UIEdgeInsets
  final public let fileSizeInfoBackgroundColor: UIKit.UIColor
  public var fileSizeInfoWrapperCornerType: Dialog_iOS.CornerRadiusType
  @objc deinit
}
@_hasMissingDesignatedInitializers public class DialogMyVideoMessageBubbleStyle : Dialog_iOS.VideoMessageDesignProtocol {
  final public let messageVideoCornerRadius: DialogSharedComponents.CornerRadiusType
  final public let messageMaxVideoHeight: CoreGraphics.CGFloat
  final public let fileSizeInfoTextAttributes: [Foundation.NSAttributedString.Key : Any]?
  final public let fileSizeInfoInsets: UIKit.UIEdgeInsets
  final public let fileSizeInfoWrapperInsets: UIKit.UIEdgeInsets
  final public let fileSizeInfoBackgroundColor: UIKit.UIColor
  public var fileSizeInfoWrapperCornerType: Dialog_iOS.CornerRadiusType
  @objc deinit
}
@_hasMissingDesignatedInitializers public class DialogDocumentMessageBubbleStyle : Dialog_iOS.DocumentMessageCellDesignProtocol {
  public var subtitleTextAttributes: [Foundation.NSAttributedString.Key : Any] {
    get
  }
  public var messageTextLabelAttributes: [Foundation.NSAttributedString.Key : Any] {
    get
  }
  final public let messageTextLabelMaxLinesCount: Swift.UInt
  @objc deinit
}
@_hasMissingDesignatedInitializers public class DialogMyDocumentMessageBubbleStyle : Dialog_iOS.DocumentMessageCellDesignProtocol {
  public var subtitleTextAttributes: [Foundation.NSAttributedString.Key : Any] {
    get
  }
  public var backgroundCornerRadius: DialogSharedComponents.CornerRadiusType
  public var iconCornerRadius: CoreGraphics.CGFloat
  public var messageTextLabelAttributes: [Foundation.NSAttributedString.Key : Any] {
    get
  }
  final public let messageTextLabelMaxLinesCount: Swift.UInt
  @objc deinit
}
extension DialogMessageContentProtocol {
  public func isService() -> Swift.Bool
  public func isCall() -> Swift.Bool
}
extension DialogMessage {
  public func isService() -> Swift.Bool
  public func isForwardedMessage() -> Swift.Bool
}
extension DialogChannelServiceError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
extension DialogMessagingSyncState {
  public func getLocalizedDescription() -> Swift.String?
}
extension DialogMuteSettingsServiceProtocol {
  public func createIsMutedRxValue(target: DialogProtocols.MuteTarget) -> Dialog_iOS.RxValue<Swift.Bool>
  public func createNotificationsEnabledRxValue(target: DialogProtocols.MuteTarget) -> Dialog_iOS.RxValue<Swift.Bool>
  public func createNotificationsEnabledControlProperty(for target: DialogProtocols.MuteTarget) -> RxCocoa.ControlProperty<Swift.Bool>
  public func bind(to relay: RxRelay.BehaviorRelay<Swift.Bool>, for target: DialogProtocols.MuteTarget) -> RxSwift.Disposable
}
extension DialogSeqUpdatesServiceProtocol {
  public func syncStateDescription(eventBus: DialogProtocols.EventBusServiceProtocol) -> RxSwift.Observable<Swift.String?>
}
public typealias DialogPeerColorsServiceProtocol = DialogSharedComponents.DialogPeerColorsServiceProtocol
public typealias DialogPeerColorsService = DialogSharedComponents.DialogPeerColorsService
public typealias Locker = DialogSharedComponents.Locker
extension DialogPhotoMessageContent {
  public func exportImage() -> UIKit.UIImage?
}
public protocol AnyDialogsCoordinatorDelegate {
  func didCreateCoordinator(coordinator: Dialog_iOS.AnyDialogsCoordinator)
}
public struct GroupProfileRouteArgs {
  public let id: DialogProtocols.DialogGroupId
  public var initialGroup: DialogProtocols.DialogGroup?
  public init(id: DialogProtocols.DialogGroupId)
}
public struct UserProfileRouteArgs {
  public let id: DialogProtocols.DialogUserId
  public var initialUser: DialogProtocols.DialogUser?
  public init(id: DialogProtocols.DialogUserId, initialUser: DialogProtocols.DialogUser? = nil)
}
public typealias DialogsRouter = XCoordinator.WeakRouter<Dialog_iOS.DialogsRoute>
public typealias AnyDialogsCoordinator = Dialog_iOS.DialogsListCoordinator.AnyCoordinatorType
public class DialogsListCoordinator : XCoordinator.NavigationCoordinator<Dialog_iOS.DialogsRoute> {
  final public let container: Swinject.Container
  public init(container: Swinject.Container, rootViewController: UIKit.UINavigationController, initialRoute: Dialog_iOS.DialogsRoute? = .dialogs)
  override public func prepareTransition(for route: Dialog_iOS.DialogsRoute) -> XCoordinator.NavigationTransition
  override public init(rootViewController: XCoordinator.NavigationCoordinator<Dialog_iOS.DialogsRoute>.RootViewController = super, initialRoute: Dialog_iOS.DialogsRoute? = super)
  override public init(rootViewController: XCoordinator.NavigationCoordinator<Dialog_iOS.DialogsRoute>.RootViewController = super, root: XCoordinator.Presentable)
  @objc deinit
}
public protocol DialogsListCellProtocol : Dialog_iOS.Identifiable {
  var viewModel: Dialog_iOS.DialogsListCellViewModelProtocol? { get }
  func bind(to viewModel: Dialog_iOS.DialogsListCellViewModelProtocol, with design: Dialog_iOS.DialogsListCellDesignProtocol)
}
@objc @_inheritsConvenienceInitializers final public class DialogsListCell : Dialog_iOS.DisposableTableViewCell, Dialog_iOS.DialogsListCellProtocol {
  final public var viewModel: Dialog_iOS.DialogsListCellViewModelProtocol?
  @objc override final public func layoutSubviews()
  final public func bind(to viewModel: Dialog_iOS.DialogsListCellViewModelProtocol, with design: Dialog_iOS.DialogsListCellDesignProtocol)
  @objc deinit
  @available(iOS 3.0, *)
  @objc override dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public protocol DialogsListCellDesignProtocol {
  var backgroundColor: UIKit.UIColor { get }
  var selectedBackgroundColor: UIKit.UIColor { get }
  var separatorInsets: UIKit.UIEdgeInsets { get }
  var avatarInsets: UIKit.UIEdgeInsets { get }
  var avatarSize: CoreGraphics.CGSize { get }
  var maxAvatarSize: CoreGraphics.CGSize { get }
  var titleInsets: UIKit.UIEdgeInsets { get }
  var titleFont: UIKit.UIFont { get }
  var titleColor: UIKit.UIColor { get }
  var disabledTitleColor: UIKit.UIColor { get }
  var titleMaxLines: Swift.UInt { get }
  var dateInsets: UIKit.UIEdgeInsets { get }
  var dateFont: UIKit.UIFont { get }
  var dateMaxLines: Swift.UInt { get }
  var dateColor: UIKit.UIColor { get }
  var contentInsets: UIKit.UIEdgeInsets { get }
  var authorColor: UIKit.UIColor { get }
  var authorFont: UIKit.UIFont { get }
  var contentFont: UIKit.UIFont { get }
  var contentMaxLines: Swift.UInt { get }
  var contentColor: UIKit.UIColor { get }
  var draftPrefixColor: UIKit.UIColor { get }
  var totalHeight: CoreGraphics.CGFloat { get }
  var favouriteBackgroundColor: UIKit.UIColor { get }
  var favouriteSymbol: Swift.String? { get }
  var favouriteIcon: UIKit.UIImage? { get }
  var messageContentPhotoSymbol: Swift.String { get }
  var messageContentVideoSymbol: Swift.String { get }
  var messageContentVoiceSymbol: Swift.String { get }
  var messageContentDocumentSymbol: Swift.String { get }
  var messageContentStickerSymbol: Swift.String { get }
  var themeService: Dialog_iOS.AppThemeService { get }
  static var messageForwardIcon: UIKit.UIImage { get }
  static var callIncomingIcon: UIKit.UIImage { get }
  static var callOutgoingIcon: UIKit.UIImage { get }
  var mutedUnreadCountBackgroundColor: UIKit.UIColor { get }
  var unmutedUnreadCountBackgroundColor: UIKit.UIColor { get }
  var muteIconImage: UIKit.UIImage? { get }
  var swipeButtonsFont: UIKit.UIFont { get }
  var favouriteSwipeButtonBackgroundColor: UIKit.UIColor { get }
  var favouriteSwipeButtonForegroundColor: UIKit.UIColor { get }
  var favouriteSwipeButtonImage: UIKit.UIImage? { get }
  var notFavouriteSwipeButtonImage: UIKit.UIImage? { get }
  var notificationsSwipeButtonBackgroundColor: UIKit.UIColor { get }
  var notificationsSwipeButtonForegroundColor: UIKit.UIColor { get }
  var notificationsAreOnSwipeButtonImage: UIKit.UIImage? { get }
  var notificationsAreOffSwipeButtonImage: UIKit.UIImage? { get }
  var deleteSwipeButtonBackgroundColor: UIKit.UIColor { get }
  var deleteSwipeButtonForegroundColor: UIKit.UIColor { get }
  var deleteSwipeButtonImage: UIKit.UIImage? { get }
  var headerItemsOrder: [Dialog_iOS.DialogCellHeaderItemType] { get }
}
public protocol CheckmarkableDialogsListCellDesign : Dialog_iOS.DialogsListCellDesignProtocol {
  var checkmarkedAvatarStyle: Dialog_iOS.CheckmarkableAvatarViewStyleProtocol? { get }
}
public struct DialogsListCellDesign : Dialog_iOS.DialogsListCellDesignProtocol {
  public var backgroundColor: UIKit.UIColor {
    get
  }
  public var selectedBackgroundColor: UIKit.UIColor {
    get
  }
  public static var kBackgroundColor: UIKit.UIColor
  public var separatorInsets: UIKit.UIEdgeInsets
  public let avatarInsets: UIKit.UIEdgeInsets
  public let avatarSize: CoreGraphics.CGSize
  public let maxAvatarSize: CoreGraphics.CGSize
  public let titleInsets: UIKit.UIEdgeInsets
  public let titleFont: UIKit.UIFont
  public var titleColor: UIKit.UIColor {
    get
  }
  public var disabledTitleColor: UIKit.UIColor {
    get
  }
  public let titleMaxLines: Swift.UInt
  public let dateInsets: UIKit.UIEdgeInsets
  public let dateFont: UIKit.UIFont
  public let dateMaxLines: Swift.UInt
  public var dateColor: UIKit.UIColor {
    get
  }
  public let contentInsets: UIKit.UIEdgeInsets
  public var authorColor: UIKit.UIColor {
    get
  }
  public let authorFont: UIKit.UIFont
  public let contentFont: UIKit.UIFont
  public let contentMaxLines: Swift.UInt
  public var draftPrefixColor: UIKit.UIColor
  public var contentColor: UIKit.UIColor {
    get
  }
  public let totalHeight: CoreGraphics.CGFloat
  public var favouriteBackgroundColor: UIKit.UIColor {
    get
  }
  public let favouriteSymbol: Swift.String?
  public let favouriteIcon: UIKit.UIImage?
  public let messageContentPhotoSymbol: Swift.String
  public let messageContentVideoSymbol: Swift.String
  public let messageContentVoiceSymbol: Swift.String
  public let messageContentDocumentSymbol: Swift.String
  public let messageContentStickerSymbol: Swift.String
  public static var messageForwardIcon: UIKit.UIImage
  public static let callIncomingIcon: UIKit.UIImage
  public static let callOutgoingIcon: UIKit.UIImage
  public var mutedUnreadCountBackgroundColor: UIKit.UIColor {
    get
  }
  public var unmutedUnreadCountBackgroundColor: UIKit.UIColor {
    get
  }
  public var muteIconImage: UIKit.UIImage?
  public let swipeButtonsFont: UIKit.UIFont
  public let favouriteSwipeButtonBackgroundColor: UIKit.UIColor
  public let favouriteSwipeButtonForegroundColor: UIKit.UIColor
  public let favouriteSwipeButtonImage: UIKit.UIImage?
  public let notFavouriteSwipeButtonImage: UIKit.UIImage?
  public let notificationsSwipeButtonBackgroundColor: UIKit.UIColor
  public let notificationsSwipeButtonForegroundColor: UIKit.UIColor
  public let notificationsAreOnSwipeButtonImage: UIKit.UIImage?
  public let notificationsAreOffSwipeButtonImage: UIKit.UIImage?
  public let deleteSwipeButtonBackgroundColor: UIKit.UIColor
  public let deleteSwipeButtonForegroundColor: UIKit.UIColor
  public let deleteSwipeButtonImage: UIKit.UIImage?
  public var headerItemsOrder: [Dialog_iOS.DialogCellHeaderItemType]
  public let themeService: Dialog_iOS.AppThemeService
}
public protocol DialogsListCellSwipeActionConfiguratorProtocol {
  func createSwipeActionsForDialog(_ dialog: DialogProtocols.DialogState, myId: DialogProtocols.DialogUserId) -> [Dialog_iOS.DialogSwipeButtonConfig]
}
public class DialogsListCellSwipeActionConfigurator : Dialog_iOS.DialogsListCellSwipeActionConfiguratorProtocol {
  public init(design: Dialog_iOS.DialogsListCellDesignProtocol, muteStateObservable: RxSwift.Observable<DialogMuteSettingsService.MuteSettingsState>, dialogActiveGroups: RxSwift.Observable<DialogProtocols.DialogActiveGroupsState>)
  public func createSwipeActionsForDialog(_ dialog: DialogProtocols.DialogState, myId: DialogProtocols.DialogUserId) -> [Dialog_iOS.DialogSwipeButtonConfig]
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DialogsListCellSwipeNoActionConfigurator : Dialog_iOS.DialogsListCellSwipeActionConfiguratorProtocol {
  final public func createSwipeActionsForDialog(_ dialog: DialogProtocols.DialogState, myId: DialogProtocols.DialogUserId) -> [Dialog_iOS.DialogSwipeButtonConfig]
  @objc deinit
}
public protocol DialogsListCellViewModelProtocol : DialogSharedComponents.AvatarViewModelProtocol, Dialog_iOS.ViewModelProtocol {
  var willDisplayOnline: RxSwift.AnyObserver<Swift.Void> { get }
  var titleText: RxCocoa.Driver<Foundation.NSAttributedString> { get }
  var dateText: RxCocoa.Driver<Swift.String> { get }
  var messageStatus: RxSwift.BehaviorSubject<DialogProtocols.DialogMyMessageStatusType?> { get }
  var contentText: RxCocoa.Driver<Foundation.NSAttributedString> { get }
  var unreadCount: RxCocoa.Driver<Swift.String> { get }
  var backgroundColor: RxCocoa.Driver<UIKit.UIColor> { get }
  var isMuted: RxCocoa.Driver<Swift.Bool> { get }
  var muteMarker: RxCocoa.Driver<Dialog_iOS.StateMarker> { get }
  var pinMarker: RxCocoa.Driver<Dialog_iOS.StateMarker> { get }
  var dialog: DialogProtocols.DialogState { get }
  var swipeActions: [Dialog_iOS.DialogSwipeButtonConfig] { get }
  var isEnabled: RxCocoa.Driver<Swift.Bool> { get }
  var isEnabledNow: Swift.Bool { get }
  var isOnline: RxCocoa.Driver<Swift.Bool> { get }
  var lastSeen: RxCocoa.Driver<Swift.String?> { get }
  var isDeleting: RxCocoa.Driver<Swift.Bool> { get }
  var themeGeneralColor: RxCocoa.Driver<UIKit.UIColor> { get }
  var typingViewModel: Dialog_iOS.UserStatusViewModelProtocol { get }
  var isFavorites: Swift.Bool { get }
}
public class DialogsListCellViewModel : Dialog_iOS.DialogsListCellViewModelProtocol, Differentiator.IdentifiableType {
  final public let basicColor: UIKit.UIColor
  public typealias Identity = Swift.Int32
  final public let avatarCenterText: RxCocoa.Driver<Swift.String?>
  final public let avatarImage: RxCocoa.Driver<UIKit.UIImage?>
  final public let isAvatarLoading: RxCocoa.Driver<Swift.Bool>
  public var willDisplayOnline: RxSwift.AnyObserver<Swift.Void>
  final public let titleText: RxCocoa.Driver<Foundation.NSAttributedString>
  final public let dateText: RxCocoa.Driver<Swift.String>
  final public let messageStatus: RxSwift.BehaviorSubject<DialogProtocols.DialogMyMessageStatusType?>
  final public let backgroundColor: RxCocoa.Driver<UIKit.UIColor>
  final public let isMuted: RxCocoa.Driver<Swift.Bool>
  final public let contentText: RxCocoa.Driver<Foundation.NSAttributedString>
  final public let identity: Swift.Int32
  final public let unreadCount: RxCocoa.Driver<Swift.String>
  final public let pinMarker: RxCocoa.Driver<Dialog_iOS.StateMarker>
  final public let muteMarker: RxCocoa.Driver<Dialog_iOS.StateMarker>
  final public let dialog: DialogProtocols.DialogState
  final public let isEnabled: RxCocoa.Driver<Swift.Bool>
  final public let isDeleting: RxCocoa.Driver<Swift.Bool>
  final public let themeGeneralColor: RxCocoa.Driver<UIKit.UIColor>
  final public let typingViewModel: Dialog_iOS.UserStatusViewModelProtocol
  final public let isFavorites: Swift.Bool
  public var isEnabledNow: Swift.Bool {
    get
  }
  final public let isOnline: RxCocoa.Driver<Swift.Bool>
  final public let lastSeen: RxCocoa.Driver<Swift.String?>
  public var setIsEnabledController: RxSwift.AnyObserver<RxSwift.Observable<Swift.Bool>> {
    get
  }
  public var swipeActions: [Dialog_iOS.DialogSwipeButtonConfig] {
    get
  }
  required public init(dialog: DialogProtocols.DialogState, myId: DialogProtocols.DialogUserId, design: RxSwift.Observable<Dialog_iOS.DialogsListCellDesignProtocol>, swipeActionConfigurator: Dialog_iOS.DialogsListCellSwipeActionConfiguratorProtocol, fileService: DialogFiles.DialogFileServiceProtocol, eventsService: DialogProtocols.EventBusServiceProtocol, muteService: DialogMuteSettingsService.DialogMuteSettingsServiceProtocol, colorService: Dialog_iOS.DialogPeerColorsServiceProtocol, presenceService: DialogProtocols.UserPresenceStateServiceProtocol, themeService: Dialog_iOS.AppThemeService, featureFlagsService: DialogProtocols.DialogFeatureFlagsServiceProtocol, drafts: RxSwift.Observable<DialogProtocols.DialogMyDraftsState>)
  @objc deinit
}
extension DialogsListCellViewModel : Swift.Equatable {
  public static func == (lhs: Dialog_iOS.DialogsListCellViewModel, rhs: Dialog_iOS.DialogsListCellViewModel) -> Swift.Bool
}
@_inheritsConvenienceInitializers final public class DialogsListScene : Dialog_iOS.Scene<Swift.Void, UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.DialogsListScene.Builder
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<Swift.Void, UIKit.UIViewController, Dialog_iOS.DialogsListAndLeaveGroupViewModelType> {
    override final public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>) -> Dialog_iOS.DialogsListAndLeaveGroupViewModelType
    override final public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>, viewModel: Dialog_iOS.DialogsListAndLeaveGroupViewModelType) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<Swift.Void, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
public struct SwipeActionsOptionSet : Swift.OptionSet {
  public let rawValue: Swift.Int
  public init(rawValue: Swift.Int)
  public static let favorite: Dialog_iOS.SwipeActionsOptionSet
  public static let mute: Dialog_iOS.SwipeActionsOptionSet
  public static let delete: Dialog_iOS.SwipeActionsOptionSet
  public static let `default`: Dialog_iOS.SwipeActionsOptionSet
  public static let officialChannel: Dialog_iOS.SwipeActionsOptionSet
  public typealias Element = Dialog_iOS.SwipeActionsOptionSet
  public typealias ArrayLiteralElement = Dialog_iOS.SwipeActionsOptionSet
  public typealias RawValue = Swift.Int
}
public struct DialogSwipeButtonConfig {
  public var type: Dialog_iOS.DialogSwipeButtonTypeConfigType
  public var title: Swift.String?
  public var image: UIKit.UIImage?
  public var backgroundColor: UIKit.UIColor
  public static func createDefault(type: Dialog_iOS.DialogSwipeButtonTypeConfigType, with design: Dialog_iOS.DialogsListCellDesignProtocol) -> Dialog_iOS.DialogSwipeButtonConfig
}
public enum DialogSwipeButtonTypeConfigType : Swift.Int {
  case isFavorite
  case isNotFavorite
  case notificationsAreOn
  case notificationsAreOff
  case delete
  case none
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public protocol DialogSearchableInterface {
  func beginSearch()
}
@objc @_inheritsConvenienceInitializers public class CaсhedBottomInsetTableView : UIKit.UITableView {
  @objc override dynamic public var safeAreaInsets: UIKit.UIEdgeInsets {
    @objc get
  }
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect, style: UIKit.UITableView.Style)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public typealias DialogsListAndLeaveGroupViewModelType = Dialog_iOS.DialogsListViewModelProtocol & Dialog_iOS.LeaveGroupProtocol
public protocol DialogsListViewModelProtocol : Dialog_iOS.ViewModelProtocol {
  var titleView: RxCocoa.Driver<UIKit.UIView?> { get }
  var title: RxCocoa.Driver<Swift.String> { get }
  var tabBarItem: RxCocoa.Driver<UIKit.UITabBarItem> { get }
  var tabBarBadgeValue: RxCocoa.Driver<Swift.Int> { get }
  var applicationBadgeValue: RxCocoa.Driver<Swift.Int> { get }
  var footerView: RxCocoa.Driver<UIKit.UIView?> { get }
  var shouldShowLogout: RxCocoa.Driver<Swift.Bool> { get }
  var allowsAddingDialog: RxCocoa.Driver<Swift.Bool> { get }
  var search: Dialog_iOS.DialogListViewModelSearch { get }
  var dialogCellTap: RxSwift.AnyObserver<Dialog_iOS.DialogsListCellViewModel> { get }
  var dialogCellSwipeAction: RxSwift.AnyObserver<(DialogProtocols.DialogState, Dialog_iOS.DialogSwipeButtonTypeConfigType)> { get }
  var didFocusOnSearch: RxSwift.AnyObserver<Swift.Void> { get }
  var sections: RxCocoa.Driver<[Dialog_iOS.DialogsListSection]> { get }
  var sectionsWillChange: RxCocoa.Driver<Swift.Void> { get }
  var logout: RxSwift.AnyObserver<Swift.Void> { get }
  var createDialog: RxSwift.AnyObserver<Swift.Void> { get }
  var themeService: Dialog_iOS.AppThemeService { get }
  var isDialogsListEmpty: RxCocoa.Driver<Swift.Bool> { get }
  var myId: DialogProtocols.DialogUserId { get }
  var isFavoritesEnabled: RxSwift.Observable<Swift.Bool> { get }
  var openFavorites: RxSwift.AnyObserver<Swift.Void> { get }
}
public class DialogsListViewModel : Dialog_iOS.DialogsListAndLeaveGroupViewModelType, Dialog_iOS.DialogGroupingViewModelProtocol {
  final public let dialogCellTap: RxSwift.AnyObserver<Dialog_iOS.DialogsListCellViewModel>
  final public let dialogCellSwipeAction: RxSwift.AnyObserver<(DialogProtocols.DialogState, Dialog_iOS.DialogSwipeButtonTypeConfigType)>
  public var didFocusOnSearch: RxSwift.AnyObserver<Swift.Void>
  final public let sections: RxCocoa.Driver<[Dialog_iOS.DialogsListSection]>
  final public let sectionsWillChange: RxCocoa.Driver<Swift.Void>
  final public let titleView: RxCocoa.Driver<UIKit.UIView?>
  final public let title: RxCocoa.Driver<Swift.String>
  final public let tabBarItem: RxCocoa.Driver<UIKit.UITabBarItem>
  final public let tabBarBadgeValue: RxCocoa.Driver<Swift.Int>
  final public let applicationBadgeValue: RxCocoa.Driver<Swift.Int>
  final public let footerView: RxCocoa.Driver<UIKit.UIView?>
  final public let logout: RxSwift.AnyObserver<Swift.Void>
  final public let createDialog: RxSwift.AnyObserver<Swift.Void>
  public var shouldShowLogout: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Swift.Bool>
  public var allowsAddingDialog: RxCocoa.Driver<Swift.Bool>
  final public let search: Dialog_iOS.DialogListViewModelSearch
  final public let confirmLeave: RxSwift.AnyObserver<Swift.Void>
  final public let requestOwnerLeaveAction: RxCocoa.Driver<DialogProtocols.DialogGroup.GroupType>
  final public let selectNewGroupOwner: RxSwift.AnyObserver<Swift.Void>
  final public let isDialogsListEmpty: RxCocoa.Driver<Swift.Bool>
  final public let isFavoritesEnabled: RxSwift.Observable<Swift.Bool>
  final public let openFavorites: RxSwift.AnyObserver<Swift.Void>
  public var activate: RxSwift.AnyObserver<Dialog_iOS.DialogGroupType>
  public var backgroundColor: RxCocoa.Driver<UIKit.UIColor>
  public var generalThemeColor: RxCocoa.Driver<UIKit.UIColor?>
  public var items: RxRelay.BehaviorRelay<[Dialog_iOS.DialogGroupingItemViewModelProtocol]>
  public var willReload: RxCocoa.Driver<Dialog_iOS.DialogGroupType>
  public var themeService: Dialog_iOS.AppThemeService
  final public let myId: DialogProtocols.DialogUserId
  required public init(routerService: Dialog_iOS.RouterServiceProtocol, router: Dialog_iOS.UserSpecifiedRouterProtocol, listService: DialogMessaging.DialogsListServiceProtocol, groupMembersService: DialogMessaging.DialogGroupMembersServiceProtocol, groupService: DialogProtocols.DialogGroupServiceProtocol, fileService: DialogFiles.DialogFileServiceProtocol, channelService: DialogProtocols.DialogChannelServiceProtocol, seqService: DialogMessaging.DialogSeqUpdatesServiceProtocol, dialogService: DialogMessaging.DialogServiceProtocol, eventBusService: DialogProtocols.EventBusServiceProtocol, muteService: DialogMuteSettingsService.DialogMuteSettingsServiceProtocol, unreadCounterService: Dialog_iOS.UnreadCounterServiceProtocol, searchResultsProvider: Dialog_iOS.SearchResultsViewControllerProviderProtocol, colorService: Dialog_iOS.DialogPeerColorsServiceProtocol, myId: DialogProtocols.DialogUserId, presenceService: DialogProtocols.UserPresenceStateServiceProtocol, passcodeViewBuilder: DialogPasscodeUI.PasscodeCoreBuilderProtocol, themeService: Dialog_iOS.AppThemeService, metricsService: DialogMetrics.DialogMetricsServiceProtocol, featureFlagsService: DialogProtocols.DialogFeatureFlagsServiceProtocol, myUser: RxSwift.Observable<DialogProtocols.DialogUser?>, badgesConfig: Dialog_iOS.DialogBadgesConfig)
  @objc deinit
}
public struct DialogsListSection {
  public let items: [Dialog_iOS.DialogsListCellViewModel]
  public let type: Dialog_iOS.DialogsListSection.SectionType
  public init(items: [Dialog_iOS.DialogsListCellViewModel], type: Dialog_iOS.DialogsListSection.SectionType)
}
extension DialogsListSection : Differentiator.AnimatableSectionModelType {
  public enum SectionType : Swift.Int {
    case official
    case favourites
    case `default`
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
    public init?(rawValue: Swift.Int)
  }
  public typealias Identity = Swift.Int
  public var identity: Swift.Int {
    get
  }
  public typealias Item = Dialog_iOS.DialogsListCellViewModel
  public init(original: Dialog_iOS.DialogsListSection, items: [Dialog_iOS.DialogsListSection.Item])
}
public protocol DialogSortingServiceProtocol {
  func sort(dialogs: [DialogProtocols.DialogState]) -> RxSwift.Single<[DialogProtocols.DialogState]>
}
@_hasMissingDesignatedInitializers final public class DialogSortingService : Dialog_iOS.DialogSortingServiceProtocol {
  final public func sort(dialogs: [DialogProtocols.DialogState]) -> RxSwift.Single<[DialogProtocols.DialogState]>
  @objc deinit
}
public enum DialogsRoute : XCoordinator.Route, DialogMetrics.DialogEventsConvertible {
  case dialogs
  case dialog(DialogProtocols.DialogState, unreadCountState: DialogProtocols.DialogUnreadCountState?, messageId: DialogProtocols.DialogUUID? = nil)
  case searchResultsDialog(DialogProtocols.DialogState, unreadCountState: DialogProtocols.DialogUnreadCountState?, peer: Dialog_iOS.ConversationPeer)
  case userProfile(Dialog_iOS.UserProfileRouteArgs)
  case groupProfile(Dialog_iOS.GroupProfileRouteArgs)
  case leaveGroup
  case doneTransferOwnership
  case groupLink(DialogProtocols.DialogGroupId, Dialog_iOS.GroupLinkType)
  case groupInvite(DialogProtocols.DialogGroupId)
  case selectUserForPermissions(DialogProtocols.DialogGroupId, Dialog_iOS.UserSelectionHandler)
  case selectUserForOwner(DialogProtocols.DialogGroupId, Dialog_iOS.UserSelectionHandler, Dialog_iOS.CancelHandler)
  case changePermissions(DialogProtocols.DialogGroupId, DialogProtocols.DialogUserId)
  case doneInvite
  case createDialog
  case chooseForwardTarget(messages: [DialogProtocols.DialogMessage])
  case webView(goToLink: Foundation.URL)
  case open(previewInfo: Dialog_iOS.PreviewInfo)
  case showAttachments(ofPeer: Dialog_iOS.ConversationPeer)
  case popFromMultiforward
  case pushFromMultiforward(DialogProtocols.DialogState)
  case beginSearch
  case createAvc
  public func convert() -> [DialogMetrics.DialogMetricStoragableEvent]
}
extension DialogUserPresenceState {
  public func getLastSeenText() -> Swift.String?
  public func isOnline() -> Swift.Bool
  public static func isOnline(lastSeen: Swift.String?) -> Swift.Bool
}
extension Date {
  public static func timeAgoSince(date: Foundation.Date, to toDate: Foundation.Date) -> Swift.String
}
infix operator >>> : BitwiseShiftPrecedence
public protocol DialogWhatsNewServiceProtocol {
  var isWhatNewEnabled: Swift.Bool { get }
  var isViewedInCurrentVersion: Swift.Bool { get }
  func skipWhatsNew()
  func markViewed()
}
@_hasMissingDesignatedInitializers public class DialogWhatsNewService : Dialog_iOS.DialogWhatsNewServiceProtocol {
  public var isWhatNewEnabled: Swift.Bool {
    get
  }
  public var isViewedInCurrentVersion: Swift.Bool {
    get
  }
  public func skipWhatsNew()
  public func markViewed()
  @objc deinit
}
public typealias DiscoverRouter = XCoordinator.WeakRouter<Dialog_iOS.DiscoverRoute>
public typealias AnyDiscoverCoordinator = Dialog_iOS.DiscoverCoordinator.AnyCoordinatorType
public enum DiscoverRoute : XCoordinator.Route {
  case main
  public static func == (a: Dialog_iOS.DiscoverRoute, b: Dialog_iOS.DiscoverRoute) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
final public class DiscoverCoordinator : XCoordinator.NavigationCoordinator<Dialog_iOS.DiscoverRoute> {
  public init(container: Swinject.Container, url: Foundation.URL)
  override final public func prepareTransition(for route: Dialog_iOS.DiscoverRoute) -> XCoordinator.NavigationTransition
  override public init(rootViewController: XCoordinator.NavigationCoordinator<Dialog_iOS.DiscoverRoute>.RootViewController = super, initialRoute: Dialog_iOS.DiscoverRoute? = super)
  override public init(rootViewController: XCoordinator.NavigationCoordinator<Dialog_iOS.DiscoverRoute>.RootViewController = super, root: XCoordinator.Presentable)
  @objc deinit
}
@_inheritsConvenienceInitializers final public class DiscoverScene : Dialog_iOS.Scene<Foundation.URL, UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.DiscoverScene.Builder
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<Foundation.URL, UIKit.UIViewController, Dialog_iOS.DUIWebViewToolbarProxyProtocol> {
    override final public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Foundation.URL>) -> Dialog_iOS.DUIWebViewToolbarProxyProtocol
    override final public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Foundation.URL>, viewModel: Dialog_iOS.DUIWebViewToolbarProxyProtocol) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<Foundation.URL, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
public protocol DisposeBagable {
  var disposeBag: RxSwift.DisposeBag { get }
}
@objc @_inheritsConvenienceInitializers public class DisposableCollectionViewCell : UIKit.UICollectionViewCell, Dialog_iOS.DisposeBagable {
  public var disposeBag: RxSwift.DisposeBag
  @objc override dynamic public func prepareForReuse()
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class DisposableTableViewCell : UIKit.UITableViewCell, Dialog_iOS.DisposeBagable {
  public var disposeBag: RxSwift.DisposeBag
  @objc override dynamic public func prepareForReuse()
  @available(iOS 3.0, *)
  @objc override dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public enum DLGAsyncOperationResult<ResultData> {
  case success(ResultData?)
  case failure(Swift.Error?)
  case cancelled
  case undefined(Any?)
}
public enum DLGOperationState {
  case idle
  case executing
  case finished
  public static func == (a: Dialog_iOS.DLGOperationState, b: Dialog_iOS.DLGOperationState) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
@_inheritsConvenienceInitializers open class DLGAsyncOperation<ResultData> : Foundation.Operation {
  public var onDidFinish: ((Dialog_iOS.DLGAsyncOperationResult<ResultData>) -> Swift.Void)?
  @objc override dynamic open var isFinished: Swift.Bool {
    @objc get
  }
  @objc override dynamic open var isExecuting: Swift.Bool {
    @objc get
  }
  @objc override dynamic open var isAsynchronous: Swift.Bool {
    @objc get
  }
  @objc override dynamic open func start()
  public func updateState(_ state: Dialog_iOS.DLGOperationState)
  public func finish(result: Dialog_iOS.DLGAsyncOperationResult<ResultData>)
  public func finishWithFailure(error: Swift.Error?)
  public func finishWithCancel()
  public func finishIfCancelled() -> Swift.Bool
  open func onDidStart()
  @objc override dynamic public init()
  @objc deinit
}
@_hasMissingDesignatedInitializers public class DLGPickerLocalizer : DLGPicker.TelegramPickerResourceProvider, DLGPicker.LocationPickerViewControllerResourceProvider {
  public func localized(buttonType: DLGPicker.LocalizableButtonType) -> Swift.String
  public func localizedAlert(failure: DLGPicker.Failure) -> UIKit.UIAlertController?
  public func localizedAlert(failure: DLGPicker.Failure, cancelCompletion: (() -> Swift.Void)?) -> UIKit.UIAlertController?
  public func resourceProviderForLocationPicker() -> DLGPicker.LocationPickerViewControllerResourceProvider?
  public func imageForLocationButton() -> UIKit.UIImage?
  public func localizedString(for type: DLGPicker.LocationPickerViewControllerResourceStringType) -> Swift.String
  public func localized(item: DLGPicker.LocalizableItem) -> Swift.String
  @objc deinit
}
extension UIApplication {
  public func openAppSettings()
}
public protocol DocumentMessageCellDesignProtocol : Dialog_iOS.MessageContentDesignProtocol {
  var messageTextLabelAttributes: [Foundation.NSAttributedString.Key : Any] { get }
  var messageTextLabelMaxLinesCount: Swift.UInt { get }
  var subtitleTextAttributes: [Foundation.NSAttributedString.Key : Any] { get }
}
public struct DocumentMessageCellPreviewIcon {
  public static func search(for mimeType: Swift.String, with separator: Swift.Character) -> UIKit.UIImage?
  public static func forContent(_ content: DialogMessaging.DialogDocumentMessageContent) -> UIKit.UIImage?
  public static func forName(_ fileName: Swift.String) -> UIKit.UIImage?
  public static func forMimeType(_ mimeType: Swift.String) -> UIKit.UIImage?
}
public enum MediaControlState {
  public typealias LoadProgressInfo = (bytesWritten: Swift.Int64, totalBytes: Swift.Int64)
  case notDownloaded
  case loading(info: Dialog_iOS.MediaControlState.LoadProgressInfo)
  case downloaded
  case downloadFailed(error: Swift.Error)
}
extension MediaControlState : Swift.Equatable {
  public static func == (lhs: Dialog_iOS.MediaControlState, rhs: Dialog_iOS.MediaControlState) -> Swift.Bool
}
@objc @_hasMissingDesignatedInitializers final public class PreviewItem : ObjectiveC.NSObject, QuickLook.QLPreviewItem {
  @objc final public var previewItemURL: Foundation.URL?
  @objc final public var previewItemTitle: Swift.String?
  @objc deinit
  @objc override dynamic public init()
}
public enum ValidationState {
  case valid, invalid
  public static func == (a: Dialog_iOS.ValidationState, b: Dialog_iOS.ValidationState) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public enum TextValidationReasons : Swift.Int, Swift.CaseIterable {
  case minLength
  case maxLength
  case stopSymbols
  case allowedSymbols
  case latinsOnly
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
  public typealias AllCases = [Dialog_iOS.TextValidationReasons]
  public static var allCases: [Dialog_iOS.TextValidationReasons] {
    get
  }
}
public struct DTextValidator : Dialog_iOS.TextValidator {
  public var errorType: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Dialog_iOS.DTextValidator.Output>
  public typealias Input = Swift.String?
  public typealias Output = [Dialog_iOS.TextValidationReasons : Dialog_iOS.ValidationState]
  public init(driver: RxCocoa.Driver<Dialog_iOS.DTextValidator.Input>)
  public init(driver: RxCocoa.Driver<Dialog_iOS.DTextValidator.Input>, withValidationOptions options: [Dialog_iOS.TextValidationReasons : Any?] = [:])
}
public protocol DUIActionWithImageCellViewModelProtocol : Dialog_iOS.DUICellViewModelProtocol {
  var text: RxCocoa.Driver<Swift.String> { get }
  var style: RxCocoa.Driver<Dialog_iOS.DUIActionWithImageCellStyleProtocol> { get }
}
public class DUIActionWithImageCellViewModel : Dialog_iOS.DUICommonCellViewModel, Dialog_iOS.DUIActionWithImageCellViewModelProtocol {
  public var text: RxCocoa.Driver<Swift.String>
  public var style: RxCocoa.Driver<Dialog_iOS.DUIActionWithImageCellStyleProtocol>
  public init(identity: Dialog_iOS.DUICellViewModelIdentity? = nil, text: Swift.String, initialStyle: Dialog_iOS.DUIActionWithImageCellStyleProtocol)
  @objc deinit
  override public init(cellType: Dialog_iOS.DUICellType)
}
public protocol DUIActionWithImageCellStyleProtocol : Dialog_iOS.DUICellStyleProtocol {
  var textColor: UIKit.UIColor { get }
  var textFont: UIKit.UIFont { get }
  var accessoryType: UIKit.UITableViewCell.AccessoryType { get }
  var paddings: UIKit.UIEdgeInsets { get }
  var image: UIKit.UIImage { get }
  var imageTintColor: UIKit.UIColor { get }
  var backgroundColor: UIKit.UIColor { get }
}
public struct DUIActionWithImageCellDefaultStyle : Dialog_iOS.DUIActionWithImageCellStyleProtocol {
  public var image: UIKit.UIImage
  public var imageTintColor: UIKit.UIColor {
    get
  }
  public var paddings: UIKit.UIEdgeInsets
  public var accessoryType: UIKit.UITableViewCell.AccessoryType
  public let textColor: UIKit.UIColor
  public var textFont: UIKit.UIFont {
    get
  }
  public var separatorInsets: UIKit.UIEdgeInsets {
    get
  }
  public let backgroundColor: UIKit.UIColor
  public var selectionStyle: UIKit.UITableViewCell.SelectionStyle
  public init(attrs: Dialog_iOS.BasicAppTheme)
}
@objc @_inheritsConvenienceInitializers public class DUIActionWithImageTableCell : Dialog_iOS.DUITableCell, Dialog_iOS.DUIStylizable, Dialog_iOS.DUIViewProtocol {
  public typealias Style = Dialog_iOS.DUIActionWithImageCellStyleProtocol
  public var viewModel: Dialog_iOS.DUIActionWithImageCellViewModelProtocol?
  public var style: Dialog_iOS.DUIActionWithImageTableCell.Style? {
    get
    set
  }
  public func bind(to viewModel: Dialog_iOS.DUIActionWithImageCellViewModelProtocol)
  @objc deinit
  @available(iOS 3.0, *)
  @objc override dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  public typealias ViewModel = Dialog_iOS.DUIActionWithImageCellViewModelProtocol
}
public class DUIAnyCellConfigurator : Dialog_iOS.DUICellConfiguratorProtocol, Swift.Equatable {
  public init(_ base: Dialog_iOS.DUICellConfiguratorProtocol)
  public func configureCell<T>(in tableView: UIKit.UITableView, viewModel: T, indexPath: Foundation.IndexPath) -> UIKit.UITableViewCell? where T : AnyObject
  public static func == (lhs: Dialog_iOS.DUIAnyCellConfigurator, rhs: Dialog_iOS.DUIAnyCellConfigurator) -> Swift.Bool
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DUIAnyView<ViewModel> : Dialog_iOS.DUIViewProtocol {
  final public var viewModel: ViewModel? {
    get
    set
  }
  final public let source: UIKit.UIView?
  final public func bind(to viewModel: ViewModel)
  final public func set(viewModel: ViewModel?)
  @objc deinit
}
public protocol DUIAnyViewConvertible {
  func asAnyView<T>(_ viewModelType: T.Type) throws -> Dialog_iOS.DUIAnyView<T>
}
public struct DUIAvatarViewBaseStyle : Dialog_iOS.AvatarViewStyleProtocol, DialogProtocols.BaseStruct {
  public var centerTextFont: UIKit.UIFont
  public var centerTextColor: UIKit.UIColor
  public var cornerRadius: DialogSharedComponents.CornerRadiusType
  public var avatarLoaderActivityStyle: UIKit.UIActivityIndicatorView.Style
  public var sideLength: CoreGraphics.CGFloat
  public var gradientStartPoint: CoreGraphics.CGPoint
  public var gradientEndPoint: CoreGraphics.CGPoint
  public var gradientColors: [Any]?
  public init()
  public static let searchResultUser: Dialog_iOS.DUIAvatarViewBaseStyle
  public static let searchResultGroup: Dialog_iOS.DUIAvatarViewBaseStyle
  public static let searchResultChannel: Dialog_iOS.DUIAvatarViewBaseStyle
}
public struct DUIAvatarViewGroupStyle : Dialog_iOS.AvatarViewStyleProtocol {
  public let centerTextFont: UIKit.UIFont
  public let centerTextColor: UIKit.UIColor
  public let cornerRadius: Dialog_iOS.CornerRadiusType
  public let avatarLoaderActivityStyle: UIKit.UIActivityIndicatorView.Style
  public let sideLength: CoreGraphics.CGFloat
  public let gradientStartPoint: CoreGraphics.CGPoint
  public let gradientEndPoint: CoreGraphics.CGPoint
  public var gradientColors: [Any]?
  public init()
}
public struct DUIAvatarViewChannelStyle : Dialog_iOS.AvatarViewStyleProtocol {
  public let centerTextFont: UIKit.UIFont
  public let centerTextColor: UIKit.UIColor
  public let cornerRadius: Dialog_iOS.CornerRadiusType
  public let avatarLoaderActivityStyle: UIKit.UIActivityIndicatorView.Style
  public let sideLength: CoreGraphics.CGFloat
  public let gradientStartPoint: CoreGraphics.CGPoint
  public let gradientEndPoint: CoreGraphics.CGPoint
  public var gradientColors: [Any]?
  public init()
}
public struct DUIAvatarViewEditGroupStyle : Dialog_iOS.AvatarViewStyleProtocol {
  public var centerTextFont: UIKit.UIFont {
    get
  }
  public var centerTextColor: UIKit.UIColor {
    get
  }
  public var cornerRadius: Dialog_iOS.CornerRadiusType {
    get
  }
  public var avatarLoaderActivityStyle: UIKit.UIActivityIndicatorView.Style {
    get
  }
  public var sideLength: CoreGraphics.CGFloat {
    get
  }
  public var gradientStartPoint: CoreGraphics.CGPoint {
    get
  }
  public var gradientEndPoint: CoreGraphics.CGPoint {
    get
  }
  public var gradientColors: [Any]?
  public init()
}
public struct DUIAvatarViewEditChannelStyle : Dialog_iOS.AvatarViewStyleProtocol {
  public var centerTextFont: UIKit.UIFont {
    get
  }
  public var centerTextColor: UIKit.UIColor {
    get
  }
  public var cornerRadius: Dialog_iOS.CornerRadiusType {
    get
  }
  public var avatarLoaderActivityStyle: UIKit.UIActivityIndicatorView.Style {
    get
  }
  public var sideLength: CoreGraphics.CGFloat {
    get
  }
  public var gradientStartPoint: CoreGraphics.CGPoint {
    get
  }
  public var gradientEndPoint: CoreGraphics.CGPoint {
    get
  }
  public var gradientColors: [Any]?
  public init()
}
public struct DUIAvatarViewContactsStyle : Dialog_iOS.AvatarViewStyleProtocol {
  public var centerTextFont: UIKit.UIFont {
    get
  }
  public var centerTextColor: UIKit.UIColor {
    get
  }
  public var cornerRadius: Dialog_iOS.CornerRadiusType {
    get
  }
  public var avatarLoaderActivityStyle: UIKit.UIActivityIndicatorView.Style {
    get
  }
  public let sideLength: CoreGraphics.CGFloat
  public var gradientStartPoint: CoreGraphics.CGPoint {
    get
  }
  public var gradientEndPoint: CoreGraphics.CGPoint {
    get
  }
  public var gradientColors: [Any]? {
    get
  }
}
@objc @_inheritsConvenienceInitializers public class DUIBaseButton : UIKit.UIButton {
  @objc override dynamic public func point(inside point: CoreGraphics.CGPoint, with event: UIKit.UIEvent?) -> Swift.Bool
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public struct DUIButtonStyle : Dialog_iOS.DUIStyle {
  public init(cornerRadius: Dialog_iOS.CornerRadiusType?, generalColor: UIKit.UIColor, titleColor: UIKit.UIColor, height: CoreGraphics.CGFloat = DUIButtonStyle.kDefaultHeight)
  public static let kDefaultHeight: CoreGraphics.CGFloat
}
@objc @_inheritsConvenienceInitializers public class DUIButton : Dialog_iOS.DUIBaseButton, Dialog_iOS.DUIStylizable {
  public var style: Dialog_iOS.DUIButtonStyle? {
    get
    set
  }
  @objc override dynamic public var isHidden: Swift.Bool {
    @objc get
    @objc set
  }
  public var collapseWhenHidden: Swift.Bool {
    get
    set
  }
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc override dynamic public func layoutSubviews()
  @objc override dynamic public var intrinsicContentSize: CoreGraphics.CGSize {
    @objc get
  }
  public typealias Style = Dialog_iOS.DUIButtonStyle
  @objc deinit
}
public protocol DUIButtonCellViewModelProtocol : Dialog_iOS.DUICellViewModelProtocol {
  var observer: RxSwift.AnyObserver<Swift.Void> { get }
  var style: RxCocoa.Driver<Dialog_iOS.DUIButtonCellStyle> { get }
  var title: RxCocoa.Driver<Swift.String> { get }
}
public class DUIButtonCellViewModel : Dialog_iOS.DUICommonCellViewModel, Dialog_iOS.DUIButtonCellViewModelProtocol {
  public var style: RxCocoa.Driver<Dialog_iOS.DUIButtonCellStyle>
  public var title: RxCocoa.Driver<Swift.String>
  public var observer: RxSwift.AnyObserver<Swift.Void>
  public init(identity: Dialog_iOS.DUICellViewModelIdentity? = UUID().uuidString, title: RxCocoa.Driver<Swift.String>, observer: RxSwift.AnyObserver<Swift.Void>, initialStyle: Dialog_iOS.DUIButtonCellStyle)
  convenience public init(identity: Dialog_iOS.DUICellViewModelIdentity? = UUID().uuidString, title: Swift.String, observer: RxSwift.AnyObserver<Swift.Void>, initialStyle: Dialog_iOS.DUIButtonCellStyle)
  override public init(cellType: Dialog_iOS.DUICellType)
  @objc deinit
}
public struct DUIButtonCellStyle : Dialog_iOS.DUICellStyleProtocol {
  public let separatorInsets: UIKit.UIEdgeInsets
  public let selectionStyle: UIKit.UITableViewCell.SelectionStyle
  public let backgroundColor: UIKit.UIColor
  public let paddings: UIKit.NSDirectionalEdgeInsets
  public let buttonStyle: Dialog_iOS.DUIButtonStyle
}
@objc @_inheritsConvenienceInitializers public class DUIButtonTableCell : Dialog_iOS.DUITableCell, Dialog_iOS.DUIStylizable, Dialog_iOS.DUIViewProtocol {
  public typealias Style = Dialog_iOS.DUIButtonCellStyle
  public var viewModel: Dialog_iOS.DUIButtonCellViewModelProtocol?
  public var style: Dialog_iOS.DUIButtonTableCell.Style? {
    get
    set
  }
  public var button: Dialog_iOS.DUIButton!
  @objc override dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  public func bind(to viewModel: Dialog_iOS.DUIButtonCellViewModelProtocol)
  @objc override dynamic public func layoutSubviews()
  @objc override dynamic public var intrinsicContentSize: CoreGraphics.CGSize {
    @objc get
  }
  @objc override dynamic public func sizeThatFits(_ size: CoreGraphics.CGSize) -> CoreGraphics.CGSize
  @objc deinit
  public typealias ViewModel = Dialog_iOS.DUIButtonCellViewModelProtocol
}
public protocol DUICellConfiguratorProtocol : AnyObject {
  func configureCell<T>(in tableView: UIKit.UITableView, viewModel: T, indexPath: Foundation.IndexPath) -> UIKit.UITableViewCell? where T : AnyObject
}
extension DUICellConfiguratorProtocol {
  public func asAnyConfigurator() -> Dialog_iOS.DUIAnyCellConfigurator
}
public enum DUICellConfiguratorAssociationPolicy {
  case weak
  case retain
  public static func == (a: Dialog_iOS.DUICellConfiguratorAssociationPolicy, b: Dialog_iOS.DUICellConfiguratorAssociationPolicy) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol DUICellConfiguratorServiceProtocol {
  func add<T>(configurator: T, policy: Dialog_iOS.DUICellConfiguratorAssociationPolicy) where T : Dialog_iOS.DUICellConfiguratorProtocol
  func remove<T>(configurator: T) where T : Dialog_iOS.DUICellConfiguratorProtocol
  func configureCell<T>(in tableView: UIKit.UITableView, viewModel: T, indexPath: Foundation.IndexPath) -> UIKit.UITableViewCell where T : AnyObject
  var common: Dialog_iOS.DUICellCommonConfigurator { get }
}
extension DUICellConfiguratorServiceProtocol {
  public func add<T>(configurator: T, policy: Dialog_iOS.DUICellConfiguratorAssociationPolicy = .weak) where T : Dialog_iOS.DUICellConfiguratorProtocol
}
@_hasMissingDesignatedInitializers public class DUICellConfiguratorService : Dialog_iOS.DUICellConfiguratorServiceProtocol {
  public var common: Dialog_iOS.DUICellCommonConfigurator
  public func configureCell<T>(in tableView: UIKit.UITableView, viewModel: T, indexPath: Foundation.IndexPath) -> UIKit.UITableViewCell where T : AnyObject
  public func add<T>(configurator: T, policy: Dialog_iOS.DUICellConfiguratorAssociationPolicy) where T : Dialog_iOS.DUICellConfiguratorProtocol
  public func remove<T>(configurator: T) where T : Dialog_iOS.DUICellConfiguratorProtocol
  @objc deinit
}
public protocol DUICellStyleProtocol : Dialog_iOS.DUIStyle {
  var separatorInsets: UIKit.UIEdgeInsets { get }
  var selectionStyle: UIKit.UITableViewCell.SelectionStyle { get }
  var backgroundColor: UIKit.UIColor { get }
}
extension DUICellStyleProtocol {
  public var separatorInsets: UIKit.UIEdgeInsets {
    get
  }
  public var hiddenSeparatorInsets: UIKit.UIEdgeInsets {
    get
  }
  public var selectionStyle: UIKit.UITableViewCell.SelectionStyle {
    get
  }
}
extension UIEdgeInsets {
  public static var hidden: UIKit.UIEdgeInsets {
    get
  }
  public var directional: UIKit.NSDirectionalEdgeInsets {
    get
  }
}
public typealias DUICellViewModelIdentity = Swift.String
public protocol DUICellViewModelProtocol {
  var selectAction: RxSwift.AnyObserver<Swift.Void>? { get }
  var menuAction: RxSwift.AnyObserver<Swift.Void>? { get }
  var isBeta: RxCocoa.Driver<Swift.Bool> { get }
}
public class DUICellViewModel : Differentiator.IdentifiableType, Swift.Hashable, Swift.Equatable, Dialog_iOS.DUICellViewModelProtocol {
  public var selectAction: RxSwift.AnyObserver<Swift.Void>?
  public var menuAction: RxSwift.AnyObserver<Swift.Void>?
  public var supportedContextMenuItems: [Dialog_iOS.DUIContextMenuItemType]
  public var contextMenuData: Swift.CustomStringConvertible?
  public var isBeta: RxCocoa.Driver<Swift.Bool> {
    get
    set
  }
  open var identity: Dialog_iOS.DUICellViewModelIdentity
  public init(identity: Dialog_iOS.DUICellViewModelIdentity)
  public static func == (lhs: Dialog_iOS.DUICellViewModel, rhs: Dialog_iOS.DUICellViewModel) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public func isEqual(to other: Dialog_iOS.DUICellViewModel) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  @objc deinit
  public typealias Identity = Dialog_iOS.DUICellViewModelIdentity
}
public class DUICommonCellViewModel : Dialog_iOS.DUICellViewModel {
  final public let cellType: Dialog_iOS.DUICellType
  public init(cellType: Dialog_iOS.DUICellType)
  override public init(identity: Dialog_iOS.DUICellViewModelIdentity)
  @objc deinit
}
extension DUICellViewModel {
  public func selectActioned(_ action: RxSwift.AnyObserver<Swift.Void>) -> Self
  public func menuActioned(_ action: RxSwift.AnyObserver<Swift.Void>) -> Self
  public func addingBeta() -> Self
  public func supportingContextMenuItems(_ items: [Dialog_iOS.DUIContextMenuItemType]) -> Self
}
public enum DUICellType {
  case custom(Dialog_iOS.DUICellViewModelIdentity)
  case common(Dialog_iOS.DUICommonCellType, Dialog_iOS.DUICellViewModelIdentity)
}
public enum DUICommonCellType : Swift.String {
  case `switch`
  case text
  case button
  case multilineInput
  case singlelineInput
  case pickImageWithInput
  case shortlinkInput
  case user
  case actionWithImage
  case inviteUser
  case contact
  case historyCall
  case tagsView
  case spacing
  case loading
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
extension DUICommonCellType {
  public func identity() -> Dialog_iOS.DUICellViewModelIdentity
}
extension DUICommonCellType {
  public func cellClass<T>() -> T.Type where T : Dialog_iOS.DUITableCell
}
@_hasMissingDesignatedInitializers public class DUICellCommonConfigurator : Dialog_iOS.DUICellConfiguratorProtocol {
  public typealias ConfigureCommonCell = (Dialog_iOS.DUITableCell, Dialog_iOS.DUICommonCellViewModel, UIKit.UITableView, Foundation.IndexPath) -> Swift.Void
  public var configureCommonCell: Dialog_iOS.DUICellCommonConfigurator.ConfigureCommonCell?
  public func configureCell<T>(in tableView: UIKit.UITableView, viewModel: T, indexPath: Foundation.IndexPath) -> UIKit.UITableViewCell? where T : AnyObject
  @objc deinit
}
public class DUIContactCellViewModel : Dialog_iOS.DUICommonCellViewModel, Dialog_iOS.DUIUserCellViewModelProtocol {
  public enum AccessoryKind {
    case toCall
    case selectCall
    public static func == (a: Dialog_iOS.DUIContactCellViewModel.AccessoryKind, b: Dialog_iOS.DUIContactCellViewModel.AccessoryKind) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public var fullname: RxCocoa.Driver<Swift.String>
  public var description: RxCocoa.Driver<Swift.String?>
  public var userID: DialogProtocols.DialogUserId
  public var user: DialogProtocols.DialogUser?
  public var accessoryType: RxCocoa.Driver<Dialog_iOS.DUIUsedCellAccessoryType>
  public var accessoryDidTap: RxSwift.AnyObserver<Swift.Void>
  public var accessoryEnabled: RxCocoa.Driver<Swift.Bool>
  public var basicColor: UIKit.UIColor
  public var isAvatarLoading: RxCocoa.Driver<Swift.Bool>
  public var avatarImage: RxCocoa.Driver<UIKit.UIImage?>
  public var avatarCenterText: RxCocoa.Driver<Swift.String?>
  public var style: RxCocoa.Driver<Dialog_iOS.DUIUserCellStyleProtocol>
  public var inProgress: RxCocoa.Driver<Swift.Bool>
  public var accessoryAction: RxSwift.AnyObserver<DialogProtocols.DialogUserId>?
  public struct Dependencies {
    public init(myId: DialogProtocols.DialogUserId, userId: DialogProtocols.DialogUserId, initialUser: DialogProtocols.DialogUser? = nil, eventBusService: DialogProtocols.EventBusServiceProtocol, fileService: DialogFiles.DialogFileServiceProtocol, colorService: Dialog_iOS.DialogPeerColorsServiceProtocol, featureFlagsService: DialogProtocols.DialogFeatureFlagsServiceProtocol, callsService: DialogCalls.CallsServiceProtocol, themeService: Dialog_iOS.AppThemeService)
  }
  public struct Reactives {
  }
  public init(identity: Dialog_iOS.DUICellViewModelIdentity? = nil, dependencies: Dialog_iOS.DUIContactCellViewModel.Dependencies, reactives: Dialog_iOS.DUIContactCellViewModel.Reactives, accessoryKind: Dialog_iOS.DUIContactCellViewModel.AccessoryKind = .toCall, initialStyle: Dialog_iOS.DUIUserCellStyleProtocol = DUIContactCellDefaultStyle())
  override public init(cellType: Dialog_iOS.DUICellType)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @available(iOS 13.0, *)
public class DUIContextMenuConfiguration : UIKit.UIContextMenuConfiguration {
  @objc deinit
  @objc override dynamic public init()
}
public protocol DUIContextMenuFactory {
  @available(iOS 13.0, *)
  func createMenu(items: [Dialog_iOS.DUIContextMenuItemType], data: Swift.CustomStringConvertible?) -> Dialog_iOS.DUIContextMenuConfiguration?
}
extension DUIContextMenuFactory {
  @available(iOS 13.0, *)
  public func createMenu(fromProvider provider: Dialog_iOS.DUISectionedViewDataSourceType?, at indexPath: Foundation.IndexPath) -> Dialog_iOS.DUIContextMenuConfiguration?
}
public struct DUIContextMenuDefaultFactory : Dialog_iOS.DUIContextMenuFactory {
  @available(iOS 13.0, *)
  public func createMenu(items: [Dialog_iOS.DUIContextMenuItemType], data: Swift.CustomStringConvertible?) -> Dialog_iOS.DUIContextMenuConfiguration?
}
public protocol DUIContextMenuItemHandler {
  func handle(itemType: Dialog_iOS.DUIContextMenuItemType, data: Swift.CustomStringConvertible)
}
public struct DUIContextMenuItemDefaultHandler : Dialog_iOS.DUIContextMenuItemHandler {
  public func handle(itemType: Dialog_iOS.DUIContextMenuItemType, data: Swift.CustomStringConvertible)
}
public struct DUIContextMenuItemType : Swift.RawRepresentable, Swift.Equatable {
  public typealias RawValue = Swift.String
  public let rawValue: Swift.String
  public init(rawValue: Dialog_iOS.DUIContextMenuItemType.RawValue)
  public static let copy: Dialog_iOS.DUIContextMenuItemType
  public static let share: Dialog_iOS.DUIContextMenuItemType
}
public protocol DUIDialogCellViewModelProtocol : AnyObject, Dialog_iOS.DUICellViewModelProtocol {
  var willDisplayOnline: RxSwift.AnyObserver<Swift.Void> { get }
  var titleText: RxCocoa.Driver<Foundation.NSAttributedString> { get }
  var avatarViewModel: Dialog_iOS.CheckmarkableAvatarViewModelProtocol { get }
  var dateText: RxCocoa.Driver<Swift.String> { get }
  var contentText: RxCocoa.Driver<Foundation.NSAttributedString> { get }
  var unreadCount: RxCocoa.Driver<Swift.String> { get }
  var backgroundColor: RxCocoa.Driver<UIKit.UIColor> { get }
  var isMuted: RxCocoa.Driver<Swift.Bool> { get }
  var muteMarker: RxCocoa.Driver<Dialog_iOS.StateMarker> { get }
  var pinMarker: RxCocoa.Driver<Dialog_iOS.StateMarker> { get }
  var dialog: DialogProtocols.DialogState { get }
  var swipeActions: [Dialog_iOS.DialogSwipeButtonConfig] { get }
  var isEnabled: RxCocoa.Driver<Swift.Bool> { get }
  var isEnabledNow: Swift.Bool { get }
  var isOnline: RxCocoa.Driver<Swift.Bool> { get }
  var isDeleting: RxCocoa.Driver<Swift.Bool> { get }
  var isCheckmarked: RxCocoa.Driver<Swift.Bool> { get }
  var themeGeneralColor: RxCocoa.Driver<UIKit.UIColor> { get }
  var setCheckmarked: RxSwift.AnyObserver<Swift.Bool> { get }
}
extension DUIDialogCellViewModelProtocol {
  public var asDUISelectedPeerInfo: Dialog_iOS.DUISelectedPeerInfoProtocol {
    get
  }
}
final public class DUIDialogBlobCellViewModel : Dialog_iOS.DUICellViewModel, Dialog_iOS.DUIDialogCellViewModelProtocol {
  final public var willDisplayOnline: RxSwift.AnyObserver<Swift.Void>
  final public var titleText: RxCocoa.Driver<Foundation.NSAttributedString>
  final public var avatarViewModel: Dialog_iOS.CheckmarkableAvatarViewModelProtocol
  final public var dateText: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Swift.String>
  final public var contentText: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Foundation.NSAttributedString>
  final public var unreadCount: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Swift.String>
  final public var backgroundColor: RxCocoa.Driver<UIKit.UIColor>
  final public var isMuted: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Swift.Bool>
  final public var muteMarker: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Dialog_iOS.StateMarker>
  final public var pinMarker: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Dialog_iOS.StateMarker>
  final public var dialog: DialogProtocols.DialogState
  final public var swipeActions: [Dialog_iOS.DialogSwipeButtonConfig]
  final public var isEnabled: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Swift.Bool>
  final public var isEnabledNow: Swift.Bool
  final public var isOnline: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Swift.Bool>
  final public var isDeleting: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Swift.Bool>
  final public var isCheckmarked: RxCocoa.Driver<Swift.Bool> {
    get
  }
  final public var themeGeneralColor: RxCocoa.Driver<UIKit.UIColor>
  final public var setCheckmarked: RxSwift.AnyObserver<Swift.Bool> {
    get
  }
  public init(identity: Dialog_iOS.DUIDialogBlobCellViewModel.Identity, dialog: DialogProtocols.DialogState, title: RxCocoa.Driver<Foundation.NSAttributedString>, backgroundColor: RxCocoa.Driver<UIKit.UIColor>, eventBus: DialogProtocols.EventBusServiceProtocol, fileService: DialogFiles.DialogFileServiceProtocol, colorService: Dialog_iOS.DialogPeerColorsServiceProtocol, themeGeneralColor: RxCocoa.Driver<UIKit.UIColor>, myId: DialogProtocols.DialogUserId)
  @objc deinit
  override public init(identity: Dialog_iOS.DUICellViewModelIdentity)
}
final public class DUIDialogCellViewModel : Dialog_iOS.DUICellViewModel, Dialog_iOS.DUIDialogCellViewModelProtocol {
  public struct AvatarViewModel : Dialog_iOS.CheckmarkableAvatarViewModelProtocol {
    public var basicColor: UIKit.UIColor
    public var isAvatarLoading: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Swift.Bool>
    public var avatarImage: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, UIKit.UIImage?>
    public var avatarCenterText: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Swift.String?>
    public var isCheckmarked: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Swift.Bool>
  }
  public typealias Identity = Swift.Int32
  final public var willDisplayOnline: RxSwift.AnyObserver<Swift.Void>
  final public let titleText: RxCocoa.Driver<Foundation.NSAttributedString>
  final public let dateText: RxCocoa.Driver<Swift.String>
  final public let backgroundColor: RxCocoa.Driver<UIKit.UIColor>
  final public let isMuted: RxCocoa.Driver<Swift.Bool>
  final public let contentText: RxCocoa.Driver<Foundation.NSAttributedString>
  final public let unreadCount: RxCocoa.Driver<Swift.String>
  final public let pinMarker: RxCocoa.Driver<Dialog_iOS.StateMarker>
  final public let muteMarker: RxCocoa.Driver<Dialog_iOS.StateMarker>
  final public let dialog: DialogProtocols.DialogState
  final public let isEnabled: RxCocoa.Driver<Swift.Bool>
  final public let isDeleting: RxCocoa.Driver<Swift.Bool>
  final public let themeGeneralColor: RxCocoa.Driver<UIKit.UIColor>
  final public var isCheckmarked: RxCocoa.Driver<Swift.Bool> {
    get
    set
  }
  final public var isEnabledNow: Swift.Bool {
    get
  }
  final public let isOnline: RxCocoa.Driver<Swift.Bool>
  final public var setIsEnabledController: RxSwift.AnyObserver<RxSwift.Observable<Swift.Bool>> {
    get
  }
  final public var swipeActions: [Dialog_iOS.DialogSwipeButtonConfig] {
    get
  }
  final public let avatarViewModel: Dialog_iOS.CheckmarkableAvatarViewModelProtocol
  final public var preferredDesign: Dialog_iOS.DialogsListCellDesignProtocol {
    get
  }
  final public let setCheckmarked: RxSwift.AnyObserver<Swift.Bool>
  required public init(dialog: DialogProtocols.DialogState, myId: DialogProtocols.DialogUserId, design: RxSwift.Observable<Dialog_iOS.DialogsListCellDesignProtocol>, swipeActionConfigurator: Dialog_iOS.DialogsListCellSwipeActionConfiguratorProtocol, fileService: DialogFiles.DialogFileServiceProtocol, eventsService: DialogProtocols.EventBusServiceProtocol, muteService: DialogMuteSettingsService.DialogMuteSettingsServiceProtocol, colorService: Dialog_iOS.DialogPeerColorsServiceProtocol, presenceService: DialogProtocols.UserPresenceStateServiceProtocol, featureFlagsService: DialogProtocols.DialogFeatureFlagsServiceProtocol, themeService: Dialog_iOS.AppThemeService, drafts: RxSwift.Observable<DialogProtocols.DialogMyDraftsState>)
  @objc deinit
  override public init(identity: Dialog_iOS.DUICellViewModelIdentity)
}
@objc @_inheritsConvenienceInitializers final public class DUIDialogTableCell : Dialog_iOS.DUITableCell {
  final public var viewModel: Dialog_iOS.DUIDialogCellViewModelProtocol?
  @objc override final public func awakeFromNib()
  final public func bind(to viewModel: Dialog_iOS.DUIDialogCellViewModelProtocol, with design: Dialog_iOS.DUIDialogTableCellDesignProtocol)
  @objc deinit
  @available(iOS 3.0, *)
  @objc override dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public protocol DUIDialogTableCellDesignProtocol {
  var backgroundColor: UIKit.UIColor { get }
  var selectedBackgroundColor: UIKit.UIColor { get }
  var separatorInsets: UIKit.UIEdgeInsets { get }
  var avatarInsets: UIKit.UIEdgeInsets { get }
  var avatarSize: CoreGraphics.CGSize { get }
  var maxAvatarSize: CoreGraphics.CGSize { get }
  var titleInsets: UIKit.UIEdgeInsets { get }
  var titleFont: UIKit.UIFont { get }
  var titleColor: UIKit.UIColor { get }
  var disabledTitleColor: UIKit.UIColor { get }
  var titleMaxLines: Swift.UInt { get }
  var dateInsets: UIKit.UIEdgeInsets { get }
  var dateFont: UIKit.UIFont { get }
  var dateMaxLines: Swift.UInt { get }
  var dateColor: UIKit.UIColor { get }
  var contentInsets: UIKit.UIEdgeInsets { get }
  var authorColor: UIKit.UIColor { get }
  var authorFont: UIKit.UIFont { get }
  var contentFont: UIKit.UIFont { get }
  var contentMaxLines: Swift.UInt { get }
  var contentColor: UIKit.UIColor { get }
  var draftPrefixColor: UIKit.UIColor { get }
  var totalHeight: CoreGraphics.CGFloat { get }
  var favouriteBackgroundColor: UIKit.UIColor { get }
  var favouriteSymbol: Swift.String? { get }
  var favouriteIcon: UIKit.UIImage? { get }
  var messageContentPhotoSymbol: Swift.String { get }
  var messageContentVideoSymbol: Swift.String { get }
  var messageContentVoiceSymbol: Swift.String { get }
  var messageContentDocumentSymbol: Swift.String { get }
  var messageContentStickerSymbol: Swift.String { get }
  static var messageForwardIcon: UIKit.UIImage { get }
  static var callIncomingIcon: UIKit.UIImage { get }
  static var callOutgoingIcon: UIKit.UIImage { get }
  var mutedUnreadCountBackgroundColor: UIKit.UIColor { get }
  var unmutedUnreadCountBackgroundColor: UIKit.UIColor { get }
  var muteIconImage: UIKit.UIImage? { get }
  var swipeButtonsFont: UIKit.UIFont { get }
  var favouriteSwipeButtonBackgroundColor: UIKit.UIColor { get }
  var favouriteSwipeButtonForegroundColor: UIKit.UIColor { get }
  var favouriteSwipeButtonImage: UIKit.UIImage? { get }
  var notFavouriteSwipeButtonImage: UIKit.UIImage? { get }
  var notificationsSwipeButtonBackgroundColor: UIKit.UIColor { get }
  var notificationsSwipeButtonForegroundColor: UIKit.UIColor { get }
  var notificationsAreOnSwipeButtonImage: UIKit.UIImage? { get }
  var notificationsAreOffSwipeButtonImage: UIKit.UIImage? { get }
  var deleteSwipeButtonBackgroundColor: UIKit.UIColor { get }
  var deleteSwipeButtonForegroundColor: UIKit.UIColor { get }
  var deleteSwipeButtonImage: UIKit.UIImage? { get }
  var headerItemsOrder: [Dialog_iOS.DialogCellHeaderItemType] { get }
  var checkmarkedAvatarStyle: Dialog_iOS.CheckmarkableAvatarViewStyleProtocol? { get }
}
public enum DialogCellHeaderItemType : Swift.Int {
  case title
  case favourite
  case mute
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public struct DUIDialogTableCellDesign : Dialog_iOS.DUIDialogTableCellDesignProtocol {
  public static let `default`: Dialog_iOS.DUIDialogTableCellDesign
  public var backgroundColor: UIKit.UIColor {
    get
  }
  public var selectedBackgroundColor: UIKit.UIColor
  public static var kBackgroundColor: UIKit.UIColor
  public var separatorInsets: UIKit.UIEdgeInsets
  public let avatarInsets: UIKit.UIEdgeInsets
  public let avatarSize: CoreGraphics.CGSize
  public let maxAvatarSize: CoreGraphics.CGSize
  public let titleInsets: UIKit.UIEdgeInsets
  public let titleFont: UIKit.UIFont
  public var titleColor: UIKit.UIColor {
    get
  }
  public var disabledTitleColor: UIKit.UIColor {
    get
  }
  public let titleMaxLines: Swift.UInt
  public let dateInsets: UIKit.UIEdgeInsets
  public let dateFont: UIKit.UIFont
  public let dateMaxLines: Swift.UInt
  public var dateColor: UIKit.UIColor {
    get
  }
  public let contentInsets: UIKit.UIEdgeInsets
  public var authorColor: UIKit.UIColor {
    get
  }
  public let authorFont: UIKit.UIFont
  public let contentFont: UIKit.UIFont
  public let contentMaxLines: Swift.UInt
  public var draftPrefixColor: UIKit.UIColor
  public var contentColor: UIKit.UIColor {
    get
  }
  public let totalHeight: CoreGraphics.CGFloat
  public var favouriteBackgroundColor: UIKit.UIColor {
    get
  }
  public let favouriteSymbol: Swift.String?
  public let favouriteIcon: UIKit.UIImage?
  public let messageContentPhotoSymbol: Swift.String
  public let messageContentVideoSymbol: Swift.String
  public let messageContentVoiceSymbol: Swift.String
  public let messageContentDocumentSymbol: Swift.String
  public let messageContentStickerSymbol: Swift.String
  public static var messageForwardIcon: UIKit.UIImage
  public static let callIncomingIcon: UIKit.UIImage
  public static let callOutgoingIcon: UIKit.UIImage
  public var mutedUnreadCountBackgroundColor: UIKit.UIColor {
    get
  }
  public var unmutedUnreadCountBackgroundColor: UIKit.UIColor {
    get
  }
  public var muteIconImage: UIKit.UIImage?
  public let swipeButtonsFont: UIKit.UIFont
  public let favouriteSwipeButtonBackgroundColor: UIKit.UIColor
  public let favouriteSwipeButtonForegroundColor: UIKit.UIColor
  public let favouriteSwipeButtonImage: UIKit.UIImage?
  public let notFavouriteSwipeButtonImage: UIKit.UIImage?
  public let notificationsSwipeButtonBackgroundColor: UIKit.UIColor
  public let notificationsSwipeButtonForegroundColor: UIKit.UIColor
  public let notificationsAreOnSwipeButtonImage: UIKit.UIImage?
  public let notificationsAreOffSwipeButtonImage: UIKit.UIImage?
  public let deleteSwipeButtonBackgroundColor: UIKit.UIColor
  public let deleteSwipeButtonForegroundColor: UIKit.UIColor
  public let deleteSwipeButtonImage: UIKit.UIImage?
  public var headerItemsOrder: [Dialog_iOS.DialogCellHeaderItemType]
  public var checkmarkedAvatarStyle: Dialog_iOS.CheckmarkableAvatarViewStyleProtocol?
}
public struct DUIEmptyStateViewStyle : Dialog_iOS.DUIStyle {
  public var titleFont: UIKit.UIFont
  public var titleColor: UIKit.UIColor
  public var descriptionFont: UIKit.UIFont
  public var descriptionColor: UIKit.UIColor
  public var mainBackgroundColor: UIKit.UIColor
  public var buttonStyle: Dialog_iOS.DUIButtonStyle
}
@objc @_inheritsConvenienceInitializers public class DUIEmptyStateView : UIKit.UIView, Dialog_iOS.DUIStylizable {
  public typealias VM = Dialog_iOS.DUIEmptyStateViewModelProtocol
  public var style: Dialog_iOS.DUIEmptyStateViewStyle? {
    get
    set
  }
  @objc override dynamic public func awakeFromNib()
  public func bind(to viewModel: Dialog_iOS.DUIEmptyStateView.VM)
  public var isOnScroll: Swift.Bool {
    get
    set
  }
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  public typealias Style = Dialog_iOS.DUIEmptyStateViewStyle
}
extension Reactive where Base : Dialog_iOS.DUIEmptyStateView {
  public var style: RxCocoa.Binder<Dialog_iOS.DUIEmptyStateViewStyle> {
    get
  }
}
public protocol DUIEmptyStateViewModelProtocol {
  var buttonDidTapped: RxSwift.AnyObserver<Swift.Void> { get }
  var backgroundImage: RxCocoa.Driver<UIKit.UIImage?> { get }
  var foregroundImage: RxCocoa.Driver<UIKit.UIImage?> { get }
  var gradientImage: RxCocoa.Driver<UIKit.UIImage?> { get }
  var title: RxCocoa.Driver<Swift.String> { get }
  var description: RxCocoa.Driver<Swift.String> { get }
  var buttonTitle: RxCocoa.Driver<Swift.String> { get }
  var isButtonHidden: RxCocoa.Driver<Swift.Bool> { get }
  var style: RxCocoa.Driver<Dialog_iOS.DUIEmptyStateViewStyle> { get }
}
public struct DUIStaticEmptyStateViewModel : Dialog_iOS.DUIEmptyStateViewModelProtocol {
  public enum ButtonVisibility {
    case hidden
    case show(handler: RxSwift.AnyObserver<Swift.Void>)
  }
  public struct Configuration {
  }
  public var buttonDidTapped: RxSwift.AnyObserver<Swift.Void>
  public var backgroundImage: RxCocoa.Driver<UIKit.UIImage?>
  public var foregroundImage: RxCocoa.Driver<UIKit.UIImage?>
  public var gradientImage: RxCocoa.Driver<UIKit.UIImage?>
  public var title: RxCocoa.Driver<Swift.String>
  public var description: RxCocoa.Driver<Swift.String>
  public var buttonTitle: RxCocoa.Driver<Swift.String>
  public var isButtonHidden: RxCocoa.Driver<Swift.Bool>
  public var style: RxCocoa.Driver<Dialog_iOS.DUIEmptyStateViewStyle>
}
public protocol DUIStaticEmptyStateFactory {
  typealias Configuration = Dialog_iOS.DUIStaticEmptyStateViewModel.Configuration
  func make(themeService: Dialog_iOS.AppThemeService) -> Dialog_iOS.DUIStaticEmptyStateViewModel
  var configuration: Self.Configuration { get }
}
extension DUIStaticEmptyStateFactory {
  public func make(themeService: Dialog_iOS.AppThemeService) -> Dialog_iOS.DUIStaticEmptyStateViewModel
}
public struct DUIFooteredSection {
  public let items: [Dialog_iOS.DUICellViewModel]
  public let footerText: Swift.String?
  public init(items: [Dialog_iOS.DUICellViewModel], footerText: Swift.String? = nil)
}
extension DUIFooteredSection : Differentiator.AnimatableSectionModelType {
  public typealias Identity = Swift.Int
  public var identity: Swift.Int {
    get
  }
  public typealias Item = Dialog_iOS.DUICellViewModel
  public init(original: Dialog_iOS.DUIFooteredSection, items: [Dialog_iOS.DUIFooteredSection.Item])
}
@objc @_inheritsConvenienceInitializers public class DUIFooterView : UIKit.UIView {
  public func bind(text: Swift.String)
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public struct DUIForwardTargetCellViewModelStyle {
  public var avatarStyle: Dialog_iOS.CheckmarkableAvatarViewStyleProtocol
  public var backgroundColor: UIKit.UIColor
  public var selectedBackgroundColor: UIKit.UIColor
  public var titleFont: UIKit.UIFont
  public var titleColor: UIKit.UIColor
  public var detailsFont: UIKit.UIFont
  public var separatorLeadingInset: CoreGraphics.CGFloat
  public var detailsColor: UIKit.UIColor
}
public protocol DUISelectedPeerInfoRepresentable {
  var asDUISelectedPeerInfo: Dialog_iOS.DUISelectedPeerInfoProtocol { get }
}
public protocol DUIForwardTargetCellViewModelProtocol : AnyObject, Dialog_iOS.DUICellViewModelProtocol, Dialog_iOS.DUISelectedPeerInfoRepresentable {
  var dialog: DialogProtocols.DialogState { get }
  var avatar: Dialog_iOS.CheckmarkableAvatarViewModelProtocol { get }
  var title: RxCocoa.Driver<Swift.String> { get }
  var details: RxCocoa.Driver<Swift.String?> { get }
  var isCheckmarked: RxCocoa.Driver<Swift.Bool> { get }
  var style: RxCocoa.Driver<Dialog_iOS.DUIForwardTargetCellViewModelStyle> { get }
}
final public class DUIForwardTargetCellViewModel : Dialog_iOS.DUICellViewModel, Dialog_iOS.DUIForwardTargetCellViewModelProtocol {
  public typealias Services = (featureFlags: DialogProtocols.DialogFeatureFlagsServiceProtocol, files: DialogFiles.DialogFileServiceProtocol, eventBus: DialogProtocols.EventBusServiceProtocol, colorService: Dialog_iOS.DialogPeerColorsServiceProtocol)
  @_hasMissingDesignatedInitializers public class AvatarViewModel : Dialog_iOS.CheckmarkableAvatarViewModelProtocol {
    public var basicColor: UIKit.UIColor
    public var isAvatarLoading: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Swift.Bool>
    public var avatarImage: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, UIKit.UIImage?>
    public var avatarCenterText: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Swift.String?>
    public var isCheckmarked: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Swift.Bool>
    @objc deinit
  }
  final public let dialog: DialogProtocols.DialogState
  final public var avatar: Dialog_iOS.CheckmarkableAvatarViewModelProtocol
  final public var title: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Swift.String>
  final public var details: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Swift.String?>
  final public var style: RxCocoa.Driver<Dialog_iOS.DUIForwardTargetCellViewModelStyle>
  final public var isCheckmarked: RxCocoa.Driver<Swift.Bool> {
    get
  }
  final public var setCheckmarked: RxSwift.AnyObserver<Swift.Bool> {
    get
  }
  final public var asDUISelectedPeerInfo: Dialog_iOS.DUISelectedPeerInfoProtocol {
    get
  }
  public init(dialog: DialogProtocols.DialogState, title: RxCocoa.Driver<Swift.String>, myId: DialogProtocols.DialogUserId, services: Dialog_iOS.DUIForwardTargetCellViewModel.Services)
  @objc deinit
  override public init(identity: Dialog_iOS.DUICellViewModelIdentity)
}
@objc @_inheritsConvenienceInitializers final public class DUIForwardTargetTableCell : Dialog_iOS.DUITableCell {
  final public func bind(to viewModel: Dialog_iOS.DUIForwardTargetCellViewModelProtocol)
  @objc deinit
  @available(iOS 3.0, *)
  @objc override dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public enum DUIHistoryCallResult {
  case inbound
  case inboundMissed
  case outbound
  case video
  case videoMissed
  public static func == (a: Dialog_iOS.DUIHistoryCallResult, b: Dialog_iOS.DUIHistoryCallResult) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol DUIHistoryCallCellViewModelProtocol : DialogSharedComponents.AvatarViewModelProtocol, Dialog_iOS.DUICellViewModelProtocol {
  var callsGroup: DialogProtocols.DialogHistoryCallGroup { get }
  var isPessimisticDeleted: Swift.Bool { get }
  var style: RxCocoa.Driver<Dialog_iOS.DUIHistoryCallCellStyleProtocol> { get }
  var callResult: RxCocoa.Driver<Dialog_iOS.DUIHistoryCallResult?> { get }
  var name: RxCocoa.Driver<Swift.String> { get }
  var description: RxCocoa.Driver<Swift.String> { get }
  var tintColor: RxCocoa.Driver<UIKit.UIColor?> { get }
  var tapOnInfo: RxSwift.AnyObserver<Swift.Void> { get }
}
public class DUIHistoryCallCellViewModel : Dialog_iOS.DUICommonCellViewModel, Dialog_iOS.DUIHistoryCallCellViewModelProtocol {
  final public let callsGroup: DialogProtocols.DialogHistoryCallGroup
  public var isPessimisticDeleted: Swift.Bool {
    get
    set
  }
  public var basicColor: UIKit.UIColor
  public var isAvatarLoading: RxCocoa.Driver<Swift.Bool>
  public var avatarImage: RxCocoa.Driver<UIKit.UIImage?>
  public var avatarCenterText: RxCocoa.Driver<Swift.String?>
  public var style: RxCocoa.Driver<Dialog_iOS.DUIHistoryCallCellStyleProtocol>
  public var callResult: RxCocoa.Driver<Dialog_iOS.DUIHistoryCallResult?>
  public var name: RxCocoa.Driver<Swift.String>
  public var description: RxCocoa.Driver<Swift.String>
  public var tintColor: RxCocoa.Driver<UIKit.UIColor?>
  public var tapOnInfo: RxSwift.AnyObserver<Swift.Void>
  public init?(identity: Dialog_iOS.DUICellViewModelIdentity? = nil, callsGroup: DialogProtocols.DialogHistoryCallGroup, userService: DialogProtocols.DialogUserServiceProtocol, colorService: Dialog_iOS.DialogPeerColorsServiceProtocol, fileService: DialogFiles.DialogFileServiceProtocol, appThemeService: Dialog_iOS.AppThemeService, profileInfoTapHandle: RxSwift.AnyObserver<Dialog_iOS.UserProfileRouteArgs>, initialStyle: Dialog_iOS.DUIHistoryCallCellStyleProtocol = DUIHistoryCallCellStyle.default)
  override public func isEqual(to other: Dialog_iOS.DUICellViewModel) -> Swift.Bool
  override public init(cellType: Dialog_iOS.DUICellType)
  @objc deinit
}
extension DialogHistoryCall {
  public var callDateFormatted: Swift.String {
    get
  }
  public var mappedDescription: Swift.String {
    get
  }
}
public protocol DUIHistoryCallCellStyleProtocol : Dialog_iOS.DUICellStyleProtocol {
  var avatarStyle: Dialog_iOS.AvatarViewStyleProtocol { get }
  var paddings: UIKit.UIEdgeInsets { get }
  var titleFont: UIKit.UIFont { get }
  var titleColor: UIKit.UIColor { get }
  var descriptionFont: UIKit.UIFont { get }
  var descriptionColor: UIKit.UIColor { get }
  var avatarAlpha: CoreGraphics.CGFloat { get }
  var editingUnselectedImage: UIKit.UIImage? { get }
  var editingSelectedImage: UIKit.UIImage? { get }
}
public struct DUIHistoryCallCellStyle : Dialog_iOS.DUIHistoryCallCellStyleProtocol {
  public var selectionStyle: UIKit.UITableViewCell.SelectionStyle
  public let backgroundColor: UIKit.UIColor
  public let avatarStyle: Dialog_iOS.AvatarViewStyleProtocol
  public var paddings: UIKit.UIEdgeInsets
  public var titleFont: UIKit.UIFont {
    get
  }
  public var titleColor: UIKit.UIColor
  public var descriptionFont: UIKit.UIFont {
    get
  }
  public var descriptionColor: UIKit.UIColor
  public var avatarAlpha: CoreGraphics.CGFloat
  public var editingUnselectedImage: UIKit.UIImage?
  public var editingSelectedImage: UIKit.UIImage?
  public init(titleColor: UIKit.UIColor = .compatibleBlack, descriptionColor: UIKit.UIColor = .compatibleGrayColor, avatarAlpha: CoreGraphics.CGFloat = 1.0)
  public static let `default`: Dialog_iOS.DUIHistoryCallCellStyle
  public static let pessimisticDeleted: Dialog_iOS.DUIHistoryCallCellStyle
}
@objc @_inheritsConvenienceInitializers public class DUIHistoryCallTableCell : Dialog_iOS.DUITableCell, Dialog_iOS.DUIStylizable, Dialog_iOS.DUIViewProtocol {
  public typealias Style = Dialog_iOS.DUIHistoryCallCellStyleProtocol
  public var viewModel: Dialog_iOS.DUIHistoryCallCellViewModelProtocol?
  public var style: Dialog_iOS.DUIHistoryCallTableCell.Style? {
    get
    set
  }
  public var willEditingTrailingSwipe: Swift.Bool
  public func bind(to viewModel: Dialog_iOS.DUIHistoryCallCellViewModelProtocol)
  @objc override dynamic public func prepareForReuse()
  @objc override dynamic public func setEditing(_ editing: Swift.Bool, animated: Swift.Bool)
  @objc override dynamic public func setSelected(_ selected: Swift.Bool, animated: Swift.Bool)
  @objc override dynamic public var intrinsicContentSize: CoreGraphics.CGSize {
    @objc get
  }
  @objc override dynamic public func systemLayoutSizeFitting(_ targetSize: CoreGraphics.CGSize, withHorizontalFittingPriority horizontalFittingPriority: UIKit.UILayoutPriority, verticalFittingPriority: UIKit.UILayoutPriority) -> CoreGraphics.CGSize
  @objc override dynamic public func sizeThatFits(_ size: CoreGraphics.CGSize) -> CoreGraphics.CGSize
  public class func estimatedRowHeight(with style: Dialog_iOS.DUIHistoryCallCellStyleProtocol) -> CoreGraphics.CGFloat
  public typealias ViewModel = Dialog_iOS.DUIHistoryCallCellViewModelProtocol
  @objc deinit
  @available(iOS 3.0, *)
  @objc override dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public struct DUIHistoryCallAvatarViewDefaultStyle : Dialog_iOS.AvatarViewStyleProtocol {
  public let centerTextFont: UIKit.UIFont
  public let cornerRadius: Dialog_iOS.CornerRadiusType
  public let centerTextColor: UIKit.UIColor
  public let avatarLoaderActivityStyle: UIKit.UIActivityIndicatorView.Style
  public let sideLength: CoreGraphics.CGFloat
  public let gradientStartPoint: CoreGraphics.CGPoint
  public let gradientEndPoint: CoreGraphics.CGPoint
  public var gradientColors: [Any]?
}
public enum DUIInviteUserState : Swift.Int {
  case none
  case loading
  case success
  case failure
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public protocol DUIInviteUserCellViewModelProtocol : DialogSharedComponents.AvatarViewModelProtocol, Dialog_iOS.DUICellViewModelProtocol {
  var inviteState: Dialog_iOS.DUIInviteUserState { get }
  var reinviteObserver: RxSwift.AnyObserver<Swift.Void> { get }
  var title: RxCocoa.Driver<Swift.String> { get }
  var description: RxCocoa.Driver<Swift.String> { get }
  var isSelected: RxCocoa.Driver<Swift.Bool> { get }
  var isDisabled: RxCocoa.Driver<Swift.Bool> { get }
  var style: RxCocoa.Driver<Dialog_iOS.DUIInviteUserCellStyleProtocol> { get }
}
public class DUIInviteUserCellViewModel : Dialog_iOS.DUICommonCellViewModel, Dialog_iOS.DUIInviteUserCellViewModelProtocol {
  public var reinviteObserver: RxSwift.AnyObserver<Swift.Void>
  public var isSelected: RxCocoa.Driver<Swift.Bool>
  public var isDisabled: RxCocoa.Driver<Swift.Bool>
  public var inviteState: Dialog_iOS.DUIInviteUserState
  public var title: RxCocoa.Driver<Swift.String>
  public var description: RxCocoa.Driver<Swift.String>
  public var basicColor: UIKit.UIColor
  public var isAvatarLoading: RxCocoa.Driver<Swift.Bool>
  public var avatarImage: RxCocoa.Driver<UIKit.UIImage?>
  public var avatarCenterText: RxCocoa.Driver<Swift.String?>
  public var style: RxCocoa.Driver<Dialog_iOS.DUIInviteUserCellStyleProtocol>
  final public let user: DialogProtocols.DialogUser
  final public let isSelectedRelay: RxRelay.BehaviorRelay<Swift.Bool>
  final public let isDisabledRelay: RxRelay.BehaviorRelay<Swift.Bool>
  public init?(identity: Dialog_iOS.DUICellViewModelIdentity? = nil, myId: DialogProtocols.DialogUserId, user: DialogProtocols.DialogUser, isSelected: Swift.Bool = false, isDisabled: Swift.Bool = false, inviteState: Dialog_iOS.DUIInviteUserState = .none, reinviteObserver: RxSwift.AnyObserver<DialogProtocols.DialogUser> = AnyObserver.empty(), fileService: DialogFiles.DialogFileServiceProtocol, eventBusService: DialogProtocols.EventBusServiceProtocol, colorService: Dialog_iOS.DialogPeerColorsServiceProtocol, initialStyle: Dialog_iOS.DUIInviteUserCellStyleProtocol)
  override public func isEqual(to other: Dialog_iOS.DUICellViewModel) -> Swift.Bool
  @objc deinit
  override public init(cellType: Dialog_iOS.DUICellType)
}
public protocol DUIInviteUserCellStyleProtocol : Dialog_iOS.DUICellStyleProtocol {
  var paddings: UIKit.NSDirectionalEdgeInsets { get }
  var avatarStyle: Dialog_iOS.AvatarViewStyleProtocol { get }
  var backgroundColor: UIKit.UIColor { get }
  var selectionColor: UIKit.UIColor { get }
  var titleFont: UIKit.UIFont { get }
  var titleColor: UIKit.UIColor { get }
  var accessoryFont: UIKit.UIFont { get }
  var accessoryColor: UIKit.UIColor { get }
  var descriptionFont: UIKit.UIFont { get }
  var descriptionColor: UIKit.UIColor { get }
  var hSpacingBetweenItems: CoreGraphics.CGFloat { get }
  var vSpacingBetweenItems: CoreGraphics.CGFloat { get }
  var statusImageSideLength: CoreGraphics.CGFloat { get }
  var statusImageTintColor: UIKit.UIColor { get }
  func tintColor(for state: Dialog_iOS.DUIInviteUserState) -> UIKit.UIColor?
}
public struct DUIInviteUserCellDefaultStyle : Dialog_iOS.DUIInviteUserCellStyleProtocol {
  public var paddings: UIKit.NSDirectionalEdgeInsets
  public var avatarStyle: Dialog_iOS.AvatarViewStyleProtocol
  public var backgroundColor: UIKit.UIColor
  public var selectionColor: UIKit.UIColor
  public var titleFont: UIKit.UIFont {
    get
  }
  public var titleColor: UIKit.UIColor
  public var descriptionFont: UIKit.UIFont {
    get
  }
  public var descriptionColor: UIKit.UIColor
  public var separatorInsets: UIKit.UIEdgeInsets {
    get
  }
  public var selectionStyle: UIKit.UITableViewCell.SelectionStyle {
    get
  }
  public var hSpacingBetweenItems: CoreGraphics.CGFloat
  public var vSpacingBetweenItems: CoreGraphics.CGFloat
  public var statusImageSideLength: CoreGraphics.CGFloat
  public var statusImageTintColor: UIKit.UIColor
  public func tintColor(for state: Dialog_iOS.DUIInviteUserState) -> UIKit.UIColor?
  public var accessoryFont: UIKit.UIFont {
    get
  }
  public var accessoryColor: UIKit.UIColor
  public init(attrs: Dialog_iOS.BasicAppTheme)
}
@objc @_inheritsConvenienceInitializers public class DUIInviteUserTableCell : Dialog_iOS.DUITableCell, Dialog_iOS.DUIStylizable, Dialog_iOS.DUIViewProtocol {
  public typealias Style = Dialog_iOS.DUIInviteUserCellStyleProtocol
  public var viewModel: Dialog_iOS.DUIInviteUserCellViewModelProtocol?
  public var style: Dialog_iOS.DUIInviteUserTableCell.Style? {
    get
    set
  }
  public var isDisabled: Swift.Bool {
    get
    set
  }
  @objc override dynamic public var isHighlighted: Swift.Bool {
    @objc get
    @objc set
  }
  public func bind(to viewModel: Dialog_iOS.DUIInviteUserCellViewModelProtocol)
  public typealias ViewModel = Dialog_iOS.DUIInviteUserCellViewModelProtocol
  @objc deinit
  @available(iOS 3.0, *)
  @objc override dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public struct DUIInviteUserAvatarViewDefaultStyle : Dialog_iOS.AvatarViewStyleProtocol {
  public let centerTextFont: UIKit.UIFont
  public let cornerRadius: Dialog_iOS.CornerRadiusType
  public let centerTextColor: UIKit.UIColor
  public let avatarLoaderActivityStyle: UIKit.UIActivityIndicatorView.Style
  public let sideLength: CoreGraphics.CGFloat
  public let gradientStartPoint: CoreGraphics.CGPoint
  public let gradientEndPoint: CoreGraphics.CGPoint
  public var gradientColors: [Any]?
}
@objc @_inheritsConvenienceInitializers open class DUILabelTableHeaderView : UIKit.UITableViewHeaderFooterView {
  public struct Constants : Swift.Equatable {
    public static let `default`: Dialog_iOS.DUILabelTableHeaderView.Constants
    public var insets: UIKit.UIEdgeInsets
    public static func == (a: Dialog_iOS.DUILabelTableHeaderView.Constants, b: Dialog_iOS.DUILabelTableHeaderView.Constants) -> Swift.Bool
  }
  public var label: UIKit.UILabel
  @objc override dynamic public init(reuseIdentifier: Swift.String?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  public var constants: Dialog_iOS.DUILabelTableHeaderView.Constants {
    get
    set
  }
  @objc override dynamic open func layoutSubviews()
  @objc deinit
}
public protocol DUILoadingCellViewModelProtocol : Dialog_iOS.DUICellViewModelProtocol {
  var style: RxCocoa.Driver<Dialog_iOS.DUILoadingCellStyle> { get }
  var isAnimating: RxCocoa.Driver<Swift.Bool> { get }
}
public class DUILoadingCellViewModel : Dialog_iOS.DUICommonCellViewModel, Dialog_iOS.DUILoadingCellViewModelProtocol {
  public var style: RxCocoa.Driver<Dialog_iOS.DUILoadingCellStyle>
  final public let isAnimating: RxCocoa.Driver<Swift.Bool>
  public init(identity: Dialog_iOS.DUICellViewModelIdentity? = UUID().uuidString, isAnimating: RxCocoa.Driver<Swift.Bool> = .just(true), initialStyle: Dialog_iOS.DUILoadingCellStyle = .default)
  override public init(cellType: Dialog_iOS.DUICellType)
  @objc deinit
}
public struct DUILoadingCellStyle : Dialog_iOS.DUICellStyleProtocol {
  public let separatorInsets: UIKit.UIEdgeInsets
  public let selectionStyle: UIKit.UITableViewCell.SelectionStyle
  public let backgroundColor: UIKit.UIColor
  public let height: CoreGraphics.CGFloat
  public var color: UIKit.UIColor?
  public static let kDefaultLoadingHeight: CoreGraphics.CGFloat
  public static let `default`: Dialog_iOS.DUILoadingCellStyle
}
@objc @_inheritsConvenienceInitializers public class DUILoadingTableCell : Dialog_iOS.DUITableCell, Dialog_iOS.DUIStylizable, Dialog_iOS.DUIViewProtocol {
  public typealias Style = Dialog_iOS.DUILoadingCellStyle
  public var viewModel: Dialog_iOS.DUILoadingCellViewModelProtocol?
  public var style: Dialog_iOS.DUILoadingTableCell.Style? {
    get
    set
  }
  public var spinnerView: UIKit.UIActivityIndicatorView!
  @objc override dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  public func bind(to viewModel: Dialog_iOS.DUILoadingCellViewModelProtocol)
  @objc override dynamic public func layoutSubviews()
  @objc override dynamic public var intrinsicContentSize: CoreGraphics.CGSize {
    @objc get
  }
  @objc override dynamic public func sizeThatFits(_ size: CoreGraphics.CGSize) -> CoreGraphics.CGSize
  public typealias ViewModel = Dialog_iOS.DUILoadingCellViewModelProtocol
  @objc deinit
}
@available(iOS, introduced: 9.0, deprecated: 13.0, message: "Use `UIContextMenu` instead.")
public class DUIMenuControllerAdapter {
  public init(provider: Dialog_iOS.DUISectionedViewDataSourceType?)
  @objc deinit
}
public protocol DUIMultilineInputCellViewModelProtocol : Dialog_iOS.DUICellViewModelProtocol {
  var text: RxRelay.BehaviorRelay<Swift.String?> { get }
  var title: RxCocoa.Driver<Swift.String> { get }
  var errorText: RxCocoa.Driver<Swift.String?> { get }
  var style: RxCocoa.Driver<Dialog_iOS.DUIMultilineInputCellStyleProtocol> { get }
  var editable: RxCocoa.Driver<Swift.Bool> { get }
  var validationViewTextAndHighlightStatus: RxCocoa.Driver<(Swift.String?, Swift.Bool)> { get }
}
public protocol DUIMultilineInputCellStyleProtocol : Dialog_iOS.DUICellStyleProtocol {
  var textInputStyle: Dialog_iOS.FloatingTextInputStyleProtocol { get }
  var paddings: UIKit.UIEdgeInsets { get }
}
public struct DUIMultilineInputCellDefaultStyle : Dialog_iOS.DUIMultilineInputCellStyleProtocol {
  public var textInputStyle: Dialog_iOS.FloatingTextInputStyleProtocol
  public var paddings: UIKit.UIEdgeInsets
  public let backgroundColor: UIKit.UIColor
}
@objc @_inheritsConvenienceInitializers public class DUINavigationController : UIKit.UINavigationController {
  @objc override dynamic public func viewDidLoad()
  @available(iOS 5.0, *)
  @objc override dynamic public init(navigationBarClass: Swift.AnyClass?, toolbarClass: Swift.AnyClass?)
  @objc override dynamic public init(rootViewController: UIKit.UIViewController)
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
extension Reactive where Base : Dialog_iOS.DUINavigationTitleView {
  public var title: RxCocoa.Binder<Swift.String?> {
    get
  }
  public var model: RxCocoa.Binder<Dialog_iOS.DUINavigationTitleModel> {
    get
  }
}
public protocol DUINavigationLoaderViewStyleProtocol : Dialog_iOS.DUIStyle {
  var indicatorStyle: UIKit.UIActivityIndicatorView.Style { get }
  var paddings: UIKit.UIEdgeInsets { get }
  var spacing: CoreGraphics.CGFloat { get }
  var backgroundColor: UIKit.UIColor { get }
  var titleColor: UIKit.UIColor { get }
  var titleFont: UIKit.UIFont { get }
}
public struct DUINavigationTitleModel : DialogProtocols.BaseStruct {
  public var isAnimating: Swift.Bool
  public var title: Swift.String?
  public static var none: Dialog_iOS.DUINavigationTitleModel
  public static func animated(_ title: Swift.String) -> Dialog_iOS.DUINavigationTitleModel
  public static func titled(_ title: Swift.String) -> Dialog_iOS.DUINavigationTitleModel
  public init(title: Swift.String?, isAnimating: Swift.Bool)
  public init(tuple: (Swift.String?, Swift.Bool))
}
extension DUINavigationTitleModel : Swift.Equatable {
  public static func == (a: Dialog_iOS.DUINavigationTitleModel, b: Dialog_iOS.DUINavigationTitleModel) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers public class DUINavigationTitleView : UIKit.UIView, Dialog_iOS.DUIStylizable, Dialog_iOS.AnimatingViewProtocol {
  public var model: Dialog_iOS.DUINavigationTitleModel? {
    get
    set
  }
  public var title: Swift.String? {
    get
    set
  }
  public typealias Style = Dialog_iOS.DUINavigationLoaderViewStyleProtocol
  public var style: Dialog_iOS.DUINavigationTitleView.Style? {
    get
    set
  }
  public var isAnimating: Swift.Bool {
    get
    set
  }
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public protocol DUIPickImageWithInputCellViewModelProtocol : Dialog_iOS.DUICellViewModelProtocol {
  var avatarViewModel: Dialog_iOS.BaseGroupProfileAvatarViewModelProtocol { get }
  var text: RxRelay.BehaviorRelay<Swift.String?> { get }
  var placeholder: RxCocoa.Driver<Swift.String> { get }
  var validationDidFail: RxCocoa.Driver<Swift.Void> { get }
  var errorText: RxCocoa.Driver<Swift.String?> { get }
  var style: RxRelay.BehaviorRelay<Dialog_iOS.DUIPickImageWithInputCellStyleProtocol> { get }
}
public class DUIPickImageWithInputCellViewModel : Dialog_iOS.DUICommonCellViewModel, Dialog_iOS.DUIPickImageWithInputCellViewModelProtocol {
  final public let text: RxRelay.BehaviorRelay<Swift.String?>
  public var placeholder: RxCocoa.Driver<Swift.String>
  public var validationDidFail: RxCocoa.Driver<Swift.Void>
  public var errorText: RxCocoa.Driver<Swift.String?>
  final public let avatarViewModel: Dialog_iOS.BaseGroupProfileAvatarViewModelProtocol
  final public let style: RxRelay.BehaviorRelay<Dialog_iOS.DUIPickImageWithInputCellStyleProtocol>
  public init(identity: Dialog_iOS.DUICellViewModelIdentity? = nil, placeholder: RxCocoa.Driver<Swift.String>, failEmitter: RxCocoa.Driver<Swift.Void>, errorText: RxCocoa.Driver<Swift.String?>, initialStyle: Dialog_iOS.DUIPickImageWithInputCellStyleProtocol, avatarViewModel: Dialog_iOS.BaseGroupProfileAvatarViewModelProtocol)
  override public init(cellType: Dialog_iOS.DUICellType)
  @objc deinit
}
public protocol DUIPickImageWithInputCellStyleProtocol : Dialog_iOS.DUICellStyleProtocol {
  var textInputStyle: Dialog_iOS.FloatingTextInputStyleProtocol { get }
  var avatarViewStyle: Dialog_iOS.AvatarViewStyleProtocol { get }
}
public struct DUIPickImageWithInputCellDefaultStyle : Dialog_iOS.DUIPickImageWithInputCellStyleProtocol {
  public var avatarViewStyle: Dialog_iOS.AvatarViewStyleProtocol
  public var textInputStyle: Dialog_iOS.FloatingTextInputStyleProtocol
  public var separatorInsets: UIKit.UIEdgeInsets {
    get
  }
  public init(avatarViewStyle: Dialog_iOS.AvatarViewStyleProtocol)
  public static let sideLength: CoreGraphics.CGFloat
  public let backgroundColor: UIKit.UIColor
}
@objc @_inheritsConvenienceInitializers public class DUIPickImageWithInputTableCell : Dialog_iOS.DUITableCell, Dialog_iOS.DUIStylizable, Dialog_iOS.DUIViewProtocol {
  public typealias Style = Dialog_iOS.DUIPickImageWithInputCellStyleProtocol
  public typealias VM = Dialog_iOS.DUIPickImageWithInputCellViewModelProtocol
  public var viewModel: Dialog_iOS.DUIPickImageWithInputTableCell.VM?
  public var style: Dialog_iOS.DUIPickImageWithInputTableCell.Style? {
    get
    set
  }
  public var avatarViewDidTap: RxCocoa.Driver<UIKit.UITapGestureRecognizer>?
  @objc override dynamic public func updateConstraints()
  public func bind(to viewModel: Dialog_iOS.DUIPickImageWithInputTableCell.VM)
  public typealias ViewModel = Dialog_iOS.DUIPickImageWithInputCellViewModelProtocol
  @objc deinit
  @available(iOS 3.0, *)
  @objc override dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public typealias Item = Dialog_iOS.PreviewItem
public protocol DUIPreviewControllerModelProtocol : AnyObject, QuickLook.QLPreviewControllerDataSource {
  var reloadDataAndGoToIndex: RxCocoa.Driver<Swift.Int> { get }
  var isLoading: RxCocoa.Driver<Swift.Bool> { get }
}
public struct PreviewInfo : DialogProtocols.BaseStruct {
}
@_inheritsConvenienceInitializers final public class DUIPreviewScene : Dialog_iOS.Scene<Dialog_iOS.PreviewInfo, UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.DUIPreviewScene.Builder
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<Dialog_iOS.PreviewInfo, UIKit.UIViewController, Dialog_iOS.DUIPreviewControllerModelProtocol> {
    override final public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Dialog_iOS.PreviewInfo>) -> Dialog_iOS.DUIPreviewControllerModelProtocol
    override final public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Dialog_iOS.PreviewInfo>, viewModel: Dialog_iOS.DUIPreviewControllerModelProtocol) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<Dialog_iOS.PreviewInfo, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
public struct DUIRadialGradientLayerStyle {
  public var colors: [UIKit.UIColor]
  public var locations: [CoreGraphics.CGFloat]
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class DUIRadialGradientLayer : QuartzCore.CALayer {
  public var design: Dialog_iOS.DUIRadialGradientLayerStyle? {
    get
    set
  }
  public var center: CoreGraphics.CGPoint? {
    get
    set
  }
  public var radius: CoreGraphics.CGFloat? {
    get
    set
  }
  public var colors: [UIKit.UIColor] {
    get
    set
  }
  public var locations: [CoreGraphics.CGFloat] {
    get
    set
  }
  @objc override dynamic public init()
  @objc override dynamic public init(layer: Any)
  @objc override dynamic public func draw(in ctx: CoreGraphics.CGContext)
  @objc deinit
}
public protocol DUISectionedViewDataSourceType {
  func model(at indexPath: Foundation.IndexPath) -> Dialog_iOS.DUICellViewModel?
}
extension SectionedViewDataSourceType where Self : Dialog_iOS.DUISectionedViewDataSourceType {
  public func model(at indexPath: Foundation.IndexPath) -> Dialog_iOS.DUICellViewModel?
}
extension TableViewSectionedDataSource : Dialog_iOS.DUISectionedViewDataSourceType {
}
@objc @_inheritsConvenienceInitializers public class DUISegmentControl : UIKit.UISegmentedControl {
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc override dynamic public init(items: [Any]?)
  @objc deinit
}
public protocol DUISelectedDialogsItemCollectionCellDesignProtocol {
  var avatarStyle: Dialog_iOS.AvatarViewStyleProtocol { get }
  var backgroundColor: UIKit.UIColor { get }
  var textColor: UIKit.UIColor { get }
}
public struct DUISelectedDialogsItemCollectionCellDesign : Dialog_iOS.DUISelectedDialogsItemCollectionCellDesignProtocol {
  public static let `default`: Dialog_iOS.DUISelectedDialogsItemCollectionCellDesign
  public var avatarStyle: Dialog_iOS.AvatarViewStyleProtocol
  public var backgroundColor: UIKit.UIColor
  public var textColor: UIKit.UIColor
}
@objc @_inheritsConvenienceInitializers final public class DUISelectedDialogsItemCollectionCell : UIKit.UICollectionViewCell, Dialog_iOS.Identifiable {
  public static var identifier: Swift.String {
    get
  }
  @objc override final public func prepareForReuse()
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public protocol DUISelectedDialogsItemCollectionCellViewModelProtocol : AnyObject {
  var avatar: Dialog_iOS.AvatarViewModelProtocol { get }
  var title: RxCocoa.Driver<Swift.String> { get }
  var peer: DialogProtocols.DialogPeer { get }
  var didTapCloseButton: RxSwift.AnyObserver<Swift.Void> { get }
}
final public class DUISelectedDialogsItemCollectionCellViewModel : Dialog_iOS.DUISelectedDialogsItemCollectionCellViewModelProtocol {
  final public let avatar: Dialog_iOS.AvatarViewModelProtocol
  final public let title: RxCocoa.Driver<Swift.String>
  final public let peer: DialogProtocols.DialogPeer
  final public var didTapCloseButton: RxSwift.AnyObserver<Swift.Void> {
    get
  }
  final public var onDidTapCloseButton: RxSwift.AnyObserver<Swift.Void>
  public init(peer: DialogProtocols.DialogPeer, avatar: Dialog_iOS.AvatarViewModelProtocol, title: RxCocoa.Driver<Swift.String>)
  @objc deinit
}
public protocol DUISelectedDialogsTableCellDesignProtocol {
  var itemsDesign: Dialog_iOS.DUISelectedDialogsItemCollectionCellDesignProtocol { get }
}
public struct DUISelectedDialogsTableCellDesign : Dialog_iOS.DUISelectedDialogsTableCellDesignProtocol {
  public static let `default`: Dialog_iOS.DUISelectedDialogsTableCellDesign
  public let itemsDesign: Dialog_iOS.DUISelectedDialogsItemCollectionCellDesignProtocol
}
@objc @_inheritsConvenienceInitializers final public class DUISelectedDialogsTableCell : Dialog_iOS.DUITableCell {
  public static var identifier: Swift.String {
    get
  }
  @objc deinit
  @available(iOS 3.0, *)
  @objc override dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public protocol DUISelectedDialogsTableCellViewModelProtocol {
  var viewModels: RxCocoa.Driver<[Dialog_iOS.DUISelectedDialogsItemCollectionCellViewModelProtocol]> { get }
}
public protocol DUISelectedPeerInfoProtocol {
  var peer: DialogProtocols.DialogPeer { get }
  var avatar: Dialog_iOS.AvatarViewModelProtocol { get }
  var title: RxCocoa.Driver<Swift.String> { get }
}
final public class DUISelectedPeerInfo : Dialog_iOS.DUISelectedPeerInfoProtocol {
  final public let peer: DialogProtocols.DialogPeer
  final public let avatar: Dialog_iOS.AvatarViewModelProtocol
  final public let title: RxCocoa.Driver<Swift.String>
  public init(peer: DialogProtocols.DialogPeer, avatar: Dialog_iOS.AvatarViewModelProtocol, title: RxCocoa.Driver<Swift.String>)
  @objc deinit
}
final public class DUISelectedDialogsTableCellViewModel : Dialog_iOS.DUICellViewModel, Dialog_iOS.DUISelectedDialogsTableCellViewModelProtocol {
  final public let viewModels: RxCocoa.Driver<[Dialog_iOS.DUISelectedDialogsItemCollectionCellViewModelProtocol]>
  final public let peersToDeselect: RxCocoa.Driver<DialogProtocols.DialogPeer>
  public init(selectedPeerInfos: RxCocoa.Driver<[Dialog_iOS.DUISelectedPeerInfoProtocol]>)
  @objc deinit
  override public init(identity: Dialog_iOS.DUICellViewModelIdentity)
}
public protocol DUIShortlinkInputCellViewModelProtocol : Dialog_iOS.DUICellViewModelProtocol {
  var text: RxRelay.BehaviorRelay<Swift.String?> { get }
  var placeholder: RxCocoa.Driver<Swift.String> { get }
  var shortlinkEndpoint: RxCocoa.Driver<Swift.String> { get }
  var errorText: RxCocoa.Driver<Swift.String?> { get }
  var style: RxCocoa.Driver<Dialog_iOS.DUIShortlinkInputCellStyleProtocol> { get }
  var enabled: RxCocoa.Driver<Swift.Bool> { get }
}
public protocol DUIShortlinkInputCellStyleProtocol : Dialog_iOS.DUICellStyleProtocol {
  var textInputStyle: Dialog_iOS.FloatingTextInputStyleProtocol { get }
  var paddings: UIKit.UIEdgeInsets { get }
  var keyboardStyle: UIKit.UIKeyboardType { get }
  var autocorrectionType: UIKit.UITextAutocorrectionType { get }
}
public struct DUIShortlinkInputCellDefaultStyle : Dialog_iOS.DUIShortlinkInputCellStyleProtocol {
  public var paddings: UIKit.UIEdgeInsets
  public var textInputStyle: Dialog_iOS.FloatingTextInputStyleProtocol
  public var selectionStyle: UIKit.UITableViewCell.SelectionStyle {
    get
  }
  public var separatorInsets: UIKit.UIEdgeInsets {
    get
  }
  public var keyboardStyle: UIKit.UIKeyboardType
  public var autocorrectionType: UIKit.UITextAutocorrectionType
  public let backgroundColor: UIKit.UIColor
  public init(inputStyle: Dialog_iOS.FloatingTextInputStyleProtocol)
}
public struct DUISimpleSection {
  public let items: [Dialog_iOS.DUICellViewModel]
  public init(items: [Dialog_iOS.DUICellViewModel])
}
extension DUISimpleSection : Differentiator.AnimatableSectionModelType {
  public typealias Identity = Swift.Int
  public var identity: Swift.Int {
    get
  }
  public typealias Item = Dialog_iOS.DUICellViewModel
  public init(original: Dialog_iOS.DUISimpleSection, items: [Dialog_iOS.DUISimpleSection.Item])
}
extension DUISimpleSection : Swift.Equatable {
  public static func == (a: Dialog_iOS.DUISimpleSection, b: Dialog_iOS.DUISimpleSection) -> Swift.Bool
}
public struct DUISimpleUniqueSection<Identifier> : Differentiator.IdentifiableType, Swift.Equatable, Swift.CustomDebugStringConvertible where Identifier : Swift.Hashable {
  public typealias Identity = Identifier
  public let items: [Dialog_iOS.DUICellViewModel]
  public let identity: Identifier
  public var preferredTitle: Swift.String?
  public init(identity: Identifier, items: [Dialog_iOS.DUICellViewModel])
  public static func == (lhs: Dialog_iOS.DUISimpleUniqueSection<Identifier>, rhs: Dialog_iOS.DUISimpleUniqueSection<Identifier>) -> Swift.Bool
  public var debugDescription: Swift.String {
    get
  }
}
extension DUISimpleUniqueSection : Differentiator.AnimatableSectionModelType {
  public init(original: Dialog_iOS.DUISimpleUniqueSection<Identifier>, items: [Dialog_iOS.DUICellViewModel])
  public typealias Item = Dialog_iOS.DUICellViewModel
}
public protocol DUISinglelineInputCellViewModelProtocol : Dialog_iOS.DUICellViewModelProtocol {
  var text: RxRelay.BehaviorRelay<Swift.String?> { get }
  var title: RxCocoa.Driver<Swift.String> { get }
  var errorText: RxCocoa.Driver<Swift.String?> { get }
  var style: RxCocoa.Driver<Dialog_iOS.DUISinglelineInputCellStyleProtocol> { get }
  var editable: RxCocoa.Driver<Swift.Bool> { get }
}
public protocol DUISinglelineInputCellStyleProtocol : Dialog_iOS.DUICellStyleProtocol {
  var textInputStyle: Dialog_iOS.FloatingTextInputStyleProtocol { get }
  var paddings: UIKit.UIEdgeInsets { get }
}
public struct DUISinglelineInputCellDefaultStyle : Dialog_iOS.DUISinglelineInputCellStyleProtocol {
  public var textInputStyle: Dialog_iOS.FloatingTextInputStyleProtocol
  public var separatorInsets: UIKit.UIEdgeInsets
  public var paddings: UIKit.UIEdgeInsets
  public let backgroundColor: UIKit.UIColor
  public static let kDefaultPaddings: UIKit.UIEdgeInsets
  public init(paddings: UIKit.UIEdgeInsets = kDefaultPaddings, separatorInsets: UIKit.UIEdgeInsets = .hidden, textInputStyle: Dialog_iOS.FloatingTextInputStyleProtocol = FloatingTextInputDefaultStyle())
}
public protocol DUISpacingCellViewModelProtocol : Dialog_iOS.DUICellViewModelProtocol {
  var style: RxCocoa.Driver<Dialog_iOS.DUISpacingCellStyleProtocol> { get }
}
public class DUISpacingCellViewModel : Dialog_iOS.DUICommonCellViewModel, Dialog_iOS.DUISpacingCellViewModelProtocol {
  public var style: RxCocoa.Driver<Dialog_iOS.DUISpacingCellStyleProtocol>
  public init(identity: Dialog_iOS.DUICellViewModelIdentity? = UUID().uuidString, initialStyle: Dialog_iOS.DUISpacingCellStyleProtocol = DUISpacingCellDefaultStyle())
  @objc deinit
  override public init(cellType: Dialog_iOS.DUICellType)
}
public protocol DUISpacingCellStyleProtocol : Dialog_iOS.DUICellStyleProtocol {
  var height: CoreGraphics.CGFloat { get }
}
public struct DUISpacingCellDefaultStyle : Dialog_iOS.DUISpacingCellStyleProtocol {
  public var height: CoreGraphics.CGFloat
  public init(height: CoreGraphics.CGFloat = DUISpacingCellDefaultStyle.kDefaultSpacingHeight)
  public var separatorInsets: UIKit.UIEdgeInsets {
    get
  }
  public var selectionStyle: UIKit.UITableViewCell.SelectionStyle
  public static let kDefaultSpacingHeight: CoreGraphics.CGFloat
  public let backgroundColor: UIKit.UIColor
}
@objc @_inheritsConvenienceInitializers public class DUISpacingTableCell : Dialog_iOS.DUITableCell, Dialog_iOS.DUIStylizable, Dialog_iOS.DUIViewProtocol {
  public typealias Style = Dialog_iOS.DUISpacingCellStyleProtocol
  public var viewModel: Dialog_iOS.DUISpacingCellViewModelProtocol?
  public var style: Dialog_iOS.DUISpacingTableCell.Style? {
    get
    set
  }
  public func bind(to viewModel: Dialog_iOS.DUISpacingCellViewModelProtocol)
  @objc override dynamic public var intrinsicContentSize: CoreGraphics.CGSize {
    @objc get
  }
  @objc override dynamic public func sizeThatFits(_ size: CoreGraphics.CGSize) -> CoreGraphics.CGSize
  public typealias ViewModel = Dialog_iOS.DUISpacingCellViewModelProtocol
  @objc deinit
  @available(iOS 3.0, *)
  @objc override dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public struct SearchEmptyStateFactory : Dialog_iOS.DUIStaticEmptyStateFactory {
  public var configuration: Dialog_iOS.SearchEmptyStateFactory.Configuration {
    get
  }
}
public struct CallsHistoryEmptyStateFactory : Dialog_iOS.DUIStaticEmptyStateFactory {
  public init(buttonCallback: RxSwift.AnyObserver<Swift.Void>)
  public var configuration: Dialog_iOS.CallsHistoryEmptyStateFactory.Configuration {
    get
  }
}
public struct NoInternetConnectionStateFactory : Dialog_iOS.DUIStaticEmptyStateFactory {
  public var configuration: Dialog_iOS.NoInternetConnectionStateFactory.Configuration {
    get
  }
}
public struct DialogsListEmptyStateFactory : Dialog_iOS.DUIStaticEmptyStateFactory {
  public init(buttonCallback: RxSwift.AnyObserver<Swift.Void>)
  public var configuration: Dialog_iOS.DialogsListEmptyStateFactory.Configuration {
    get
  }
}
public struct ContactsListEmptyStateFactory : Dialog_iOS.DUIStaticEmptyStateFactory {
  public init(buttonCallback: RxSwift.AnyObserver<Swift.Void>)
  public var configuration: Dialog_iOS.ContactsListEmptyStateFactory.Configuration {
    get
  }
}
public protocol DUIStyle {
}
public protocol DUIStylizable : AnyObject {
  associatedtype Style = Dialog_iOS.DUIStyle
  var style: Self.Style? { get set }
}
extension DUIStylizable {
  public func applied(style: Self.Style) -> Self
}
extension Reactive where Base : UIKit.UIView, Base : Dialog_iOS.DUIStylizable {
  public var style: RxCocoa.Binder<Base.Style> {
    get
  }
}
public protocol DUISwitchCellViewModelProtocol : Dialog_iOS.DUICellViewModelProtocol {
  var selected: RxRelay.BehaviorRelay<Swift.Bool> { get }
  var title: RxCocoa.Driver<Swift.String> { get }
  var style: RxCocoa.Driver<Dialog_iOS.DUISwitchCellStyleProtocol> { get }
  var enabled: RxCocoa.Driver<Swift.Bool> { get }
}
public class DUISwitchCellViewModel : Dialog_iOS.DUICommonCellViewModel, Dialog_iOS.DUISwitchCellViewModelProtocol {
  final public let selected: RxRelay.BehaviorRelay<Swift.Bool>
  public var title: RxCocoa.Driver<Swift.String>
  public var style: RxCocoa.Driver<Dialog_iOS.DUISwitchCellStyleProtocol>
  public var enabled: RxCocoa.Driver<Swift.Bool>
  public init(identity: Dialog_iOS.DUICellViewModelIdentity? = nil, titleText: Swift.String, enabled: RxCocoa.Driver<Swift.Bool> = Driver.just(true), selected: RxRelay.BehaviorRelay<Swift.Bool> = BehaviorRelay<Bool>(value: false), initialStyle: Dialog_iOS.DUISwitchCellStyleProtocol)
  override public init(cellType: Dialog_iOS.DUICellType)
  @objc deinit
}
public protocol DUISwitchCellStyleProtocol : Dialog_iOS.DUICellStyleProtocol {
  var textColor: UIKit.UIColor { get }
  var textFont: UIKit.UIFont { get }
  var tintColor: UIKit.UIColor { get }
}
public struct DUISwitchCellDefaultStyle : Dialog_iOS.DUISwitchCellStyleProtocol {
  public let textColor: UIKit.UIColor
  public var textFont: UIKit.UIFont {
    get
  }
  public var selectionStyle: UIKit.UITableViewCell.SelectionStyle {
    get
  }
  public let tintColor: UIKit.UIColor
  public let backgroundColor: UIKit.UIColor
  public init(attrs: Dialog_iOS.BasicAppTheme)
}
@objc @_inheritsConvenienceInitializers public class DUISwitchTableCell : Dialog_iOS.DUITableCell, Dialog_iOS.DUIStylizable, Dialog_iOS.DUIViewProtocol {
  public typealias Style = Dialog_iOS.DUISwitchCellStyleProtocol
  public var viewModel: Dialog_iOS.DUISwitchCellViewModelProtocol?
  public var style: Dialog_iOS.DUISwitchTableCell.Style? {
    get
    set
  }
  public func bind(to viewModel: Dialog_iOS.DUISwitchCellViewModelProtocol)
  public typealias ViewModel = Dialog_iOS.DUISwitchCellViewModelProtocol
  @objc deinit
  @available(iOS 3.0, *)
  @objc override dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
@objc @_inheritsConvenienceInitializers public class DUITableCell : Dialog_iOS.DisposableTableViewCell, Dialog_iOS.Identifiable, Dialog_iOS.DUIAnyViewConvertible {
  public func asAnyView<T>(_ viewModelType: T.Type) throws -> Dialog_iOS.DUIAnyView<T>
  weak public var menuAdapter: Dialog_iOS.DUIMenuControllerAdapter?
  @objc override dynamic public var canBecomeFirstResponder: Swift.Bool {
    @objc get
  }
  @objc override dynamic public func canPerformAction(_ action: ObjectiveC.Selector, withSender sender: Any?) -> Swift.Bool
  @objc override dynamic public func copy(_ sender: Any?)
  @available(iOS 3.0, *)
  @objc override dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public typealias DUIAnyTableCell = Dialog_iOS.DUITableCell & Dialog_iOS.DUIAnyViewConvertible
public protocol DUITagsCellViewModelProtocol : Dialog_iOS.DUICellViewModelProtocol {
  var tagsViewModels: RxCocoa.Driver<[Dialog_iOS.DUITagViewModelProtocol]> { get }
  var attrs: RxCocoa.Driver<Dialog_iOS.BasicAppTheme> { get }
}
public class DUITagsCellViewModel : Dialog_iOS.DUICommonCellViewModel, Dialog_iOS.DUITagsCellViewModelProtocol {
  public var tagsViewModels: RxCocoa.Driver<[Dialog_iOS.DUITagViewModelProtocol]>
  public var attrs: RxCocoa.Driver<Dialog_iOS.BasicAppTheme>
  public init(identity: Dialog_iOS.DUICellViewModelIdentity? = nil, tags: [Dialog_iOS.DUITagViewModelProtocol], attrs: RxCocoa.Driver<Dialog_iOS.BasicAppTheme>)
  @objc deinit
  override public init(cellType: Dialog_iOS.DUICellType)
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class DUITagsTableCell : Dialog_iOS.DUITableCell, Dialog_iOS.DUIViewProtocol {
  public typealias ViewModel = Dialog_iOS.DUITagsCellViewModelProtocol
  public var tagsView: Dialog_iOS.DUITagsView
  public var viewModel: Dialog_iOS.DUITagsTableCell.ViewModel?
  public func bind(to viewModel: Dialog_iOS.DUITagsCellViewModelProtocol)
  @objc override dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String?)
  @objc override dynamic public var intrinsicContentSize: CoreGraphics.CGSize {
    @objc get
  }
  @objc override dynamic public func systemLayoutSizeFitting(_ targetSize: CoreGraphics.CGSize, withHorizontalFittingPriority horizontalFittingPriority: UIKit.UILayoutPriority, verticalFittingPriority: UIKit.UILayoutPriority) -> CoreGraphics.CGSize
  @objc override dynamic public func layoutSubviews()
  @objc deinit
}
public struct DUITagsViewStyle {
  public let tagStyle: Dialog_iOS.DUITagViewStyle
  public let paddings: UIKit.UIEdgeInsets
  public let sectionInset: UIKit.UIEdgeInsets
  public var height: CoreGraphics.CGFloat {
    get
  }
}
@objc @_inheritsConvenienceInitializers public class DUITagsView : UIKit.UIView {
  public var viewModels: [Dialog_iOS.DUITagViewModelProtocol] {
    get
    set
  }
  public var style: Dialog_iOS.DUITagsViewStyle? {
    get
    set
  }
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc override dynamic public func layoutSubviews()
  @objc deinit
}
extension DUITagsView : UIKit.UICollectionViewDataSource {
  @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, numberOfItemsInSection section: Swift.Int) -> Swift.Int
  @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, cellForItemAt indexPath: Foundation.IndexPath) -> UIKit.UICollectionViewCell
}
extension DUITagsView : UIKit.UICollectionViewDelegate {
}
public struct DUITagViewStyle {
  public struct Props {
    public let font: UIKit.UIFont
    public let textColor: UIKit.UIColor
    public let backgroundColor: UIKit.UIColor
    public let cornerRadiusType: Dialog_iOS.CornerRadiusType
    public let labelInsets: UIKit.UIEdgeInsets
    public var height: CoreGraphics.CGFloat {
      get
    }
    public init(font: UIKit.UIFont, textColor: UIKit.UIColor, backgroundColor: UIKit.UIColor, cornerRadiusType: Dialog_iOS.CornerRadiusType, labelInsets: UIKit.UIEdgeInsets)
  }
  public var normal: Dialog_iOS.DUITagViewStyle.Props
  public var selected: Dialog_iOS.DUITagViewStyle.Props
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class DUITagView : UIKit.UIView {
  public typealias VM = Dialog_iOS.DUITagViewModelProtocol
  public func bind(viewModel: Dialog_iOS.DUITagView.VM)
  public var isSelected: Swift.Bool {
    get
    set
  }
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc override dynamic public var intrinsicContentSize: CoreGraphics.CGSize {
    @objc get
  }
  @objc override dynamic public func layoutSubviews()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class DUITagCollectionCell : UIKit.UICollectionViewCell, Dialog_iOS.Identifiable {
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  public func bind(viewModel: Dialog_iOS.DUITagViewModelProtocol)
  @objc override dynamic public var intrinsicContentSize: CoreGraphics.CGSize {
    @objc get
  }
  @objc override dynamic public func systemLayoutSizeFitting(_ targetSize: CoreGraphics.CGSize, withHorizontalFittingPriority horizontalFittingPriority: UIKit.UILayoutPriority, verticalFittingPriority: UIKit.UILayoutPriority) -> CoreGraphics.CGSize
  @objc override dynamic public func prepareForReuse()
  @objc override dynamic public var isSelected: Swift.Bool {
    @objc get
    @objc set
  }
  @objc deinit
}
public protocol DUITagViewModelProtocol {
  var title: RxCocoa.Driver<Swift.String> { get }
  var isSelected: RxCocoa.Driver<Swift.Bool> { get }
  var attrs: RxCocoa.Driver<Dialog_iOS.BasicAppTheme> { get }
}
public struct DUITagDebugVM : Dialog_iOS.DUITagViewModelProtocol, Differentiator.IdentifiableType {
  public typealias Identity = Swift.String
  public var identity: Dialog_iOS.DUITagDebugVM.Identity
  public var title: RxCocoa.Driver<Swift.String>
  public var isSelected: RxCocoa.Driver<Swift.Bool>
  public var attrs: RxCocoa.Driver<Dialog_iOS.BasicAppTheme>
  public init(text: Swift.String, identity: Swift.String, isSelected: Swift.Bool = false, attrs: RxCocoa.Driver<Dialog_iOS.BasicAppTheme>)
}
public protocol DUITextCellViewModelProtocol : Dialog_iOS.DUICellViewModelProtocol {
  var text: RxCocoa.Driver<Swift.String> { get }
  var style: RxCocoa.Driver<Dialog_iOS.DUITextCellStyleProtocol> { get }
}
public class DUITextCellViewModel : Dialog_iOS.DUICommonCellViewModel, Dialog_iOS.DUITextCellViewModelProtocol {
  public var text: RxCocoa.Driver<Swift.String>
  public var style: RxCocoa.Driver<Dialog_iOS.DUITextCellStyleProtocol>
  convenience public init(identity: Dialog_iOS.DUICellViewModelIdentity? = nil, text: Swift.String, initialStyle: Dialog_iOS.DUITextCellStyleProtocol = DUITextCellMultilineStyle())
  public init(identity: Dialog_iOS.DUICellViewModelIdentity? = nil, text: RxCocoa.Driver<Swift.String>, initialStyle: Dialog_iOS.DUITextCellStyleProtocol = DUITextCellMultilineStyle())
  override public func isEqual(to other: Dialog_iOS.DUICellViewModel) -> Swift.Bool
  override public init(cellType: Dialog_iOS.DUICellType)
  @objc deinit
}
public protocol DUITextCellStyleProtocol : Dialog_iOS.DUICellStyleProtocol {
  var textColor: UIKit.UIColor { get }
  var textFont: UIKit.UIFont { get }
  var numberOfLines: Swift.Int { get }
  var accessoryType: UIKit.UITableViewCell.AccessoryType { get }
  var paddings: UIKit.UIEdgeInsets { get }
  var alpha: CoreGraphics.CGFloat { get }
}
@objc @_inheritsConvenienceInitializers public class DUITextTableCell : Dialog_iOS.DUITableCell, Dialog_iOS.DUIStylizable, Dialog_iOS.DUIViewProtocol {
  public typealias Style = Dialog_iOS.DUITextCellStyleProtocol
  public var viewModel: Dialog_iOS.DUITextCellViewModelProtocol?
  public var style: Dialog_iOS.DUITextTableCell.Style? {
    get
    set
  }
  public func bind(to viewModel: Dialog_iOS.DUITextCellViewModelProtocol)
  public typealias ViewModel = Dialog_iOS.DUITextCellViewModelProtocol
  @objc deinit
  @available(iOS 3.0, *)
  @objc override dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public struct DUITextCellSinglelineStyle : Dialog_iOS.DUITextCellStyleProtocol {
  public enum DUITextCellSinglelineSeparatorType {
    case `default`
    case none
    case fit
    public static func == (a: Dialog_iOS.DUITextCellSinglelineStyle.DUITextCellSinglelineSeparatorType, b: Dialog_iOS.DUITextCellSinglelineStyle.DUITextCellSinglelineSeparatorType) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public var accessoryType: UIKit.UITableViewCell.AccessoryType
  public var textFont: UIKit.UIFont {
    get
  }
  public var separatorInsets: UIKit.UIEdgeInsets
  public let textColor: UIKit.UIColor
  public var paddings: UIKit.UIEdgeInsets
  public let numberOfLines: Swift.Int
  public var selectionStyle: UIKit.UITableViewCell.SelectionStyle {
    get
  }
  public let backgroundColor: UIKit.UIColor
  public var alpha: CoreGraphics.CGFloat
  public init(paddings: UIKit.UIEdgeInsets = UIEdgeInsets(top: 16, left: 16, bottom: 8, right: 16), accessory: UIKit.UITableViewCell.AccessoryType = .none, font: UIKit.UIFont = UIFont.systemFont(ofSize: 16, weight: .regular), textColor: UIKit.UIColor = UIColor.compatibleBlack, separatorType: Dialog_iOS.DUITextCellSinglelineStyle.DUITextCellSinglelineSeparatorType = .default, backgroundColor: UIKit.UIColor = UIColor.Default.commonTableViewCellBackgroundColor, alpha: CoreGraphics.CGFloat = 1.0)
}
public struct DUITextCellMultilineStyle : Dialog_iOS.DUITextCellStyleProtocol {
  public var alpha: CoreGraphics.CGFloat
  public var paddings: UIKit.UIEdgeInsets
  public var accessoryType: UIKit.UITableViewCell.AccessoryType
  public let textColor: UIKit.UIColor
  public var textFont: UIKit.UIFont {
    get
  }
  public var separatorInsets: UIKit.UIEdgeInsets
  public let numberOfLines: Swift.Int
  public var selectionStyle: UIKit.UITableViewCell.SelectionStyle
  public let backgroundColor: UIKit.UIColor
  public init(paddings: UIKit.UIEdgeInsets = UIEdgeInsets(top: 6, left: 16, bottom: 24, right: 16), accessory: UIKit.UITableViewCell.AccessoryType = .none, font: UIKit.UIFont = UIFont.systemFont(ofSize: 13, weight: .regular), textColor: UIKit.UIColor = UIColor.compatibleLightGray, separatorInsets: UIKit.UIEdgeInsets? = nil, backgroundColor: UIKit.UIColor = UIColor.Default.commonTableViewCellBackgroundColor, alpha: CoreGraphics.CGFloat = 1.0)
}
extension DUITextCellSinglelineStyle {
  public static var arrowed: Dialog_iOS.DUITextCellSinglelineStyle {
    get
  }
  public static var header: Dialog_iOS.DUITextCellSinglelineStyle {
    get
  }
  public static var disabledHeader: Dialog_iOS.DUITextCellSinglelineStyle {
    get
  }
  public static var secondaryInfo: Dialog_iOS.DUITextCellSinglelineStyle {
    get
  }
  public static var destructive: Dialog_iOS.DUITextCellSinglelineStyle {
    get
  }
  public static func action(attrs: Dialog_iOS.BasicAppTheme) -> Dialog_iOS.DUITextCellSinglelineStyle
  public static var secondaryShortInfo: Dialog_iOS.DUITextCellSinglelineStyle {
    get
  }
  public static func active(attrs: Dialog_iOS.BasicAppTheme) -> Dialog_iOS.DUITextCellSinglelineStyle
}
extension DUITextCellMultilineStyle {
  public static var header: Dialog_iOS.DUITextCellMultilineStyle {
    get
  }
  public static var disabledFooter: Dialog_iOS.DUITextCellMultilineStyle {
    get
  }
}
public enum DUIToolBarItem : Swift.Int {
  case back
  case forward
  case share
  case safari
  case reload
  public func createButton(target: Any?, action: ObjectiveC.Selector?, viewModel: Dialog_iOS.DUIToolBarViewModelProtocol, disposeBag: RxSwift.DisposeBag) -> UIKit.UIBarButtonItem
  public var getImage: UIKit.UIImage? {
    get
  }
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public protocol DUIToolBarViewModelProtocol : AnyObject {
  var forwardButtonEnabled: RxCocoa.Driver<Swift.Bool> { get }
  var backButtonEnabled: RxCocoa.Driver<Swift.Bool> { get }
  var shareButtonEnabled: RxCocoa.Driver<Swift.Bool> { get }
  var openInSafariButtonEnabled: RxCocoa.Driver<Swift.Bool> { get }
  var reloadButtonEnabled: RxCocoa.Driver<Swift.Bool> { get }
  var toolBarButtonPressed: RxSwift.AnyObserver<Dialog_iOS.DUIToolBarItem> { get }
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class DUIToolbar : UIKit.UIToolbar {
  @objc deinit
}
public enum DUIUsedCellAccessoryType {
  case none
  case normal(text: Swift.String)
  case active(text: Swift.String)
  case destructive(text: Swift.String)
  case image(image: UIKit.UIImage)
}
public protocol DUIUserCellViewModelProtocol : DialogSharedComponents.AvatarViewModelProtocol, Dialog_iOS.DUICellViewModelProtocol {
  var accessoryDidTap: RxSwift.AnyObserver<Swift.Void> { get }
  var fullname: RxCocoa.Driver<Swift.String> { get }
  var description: RxCocoa.Driver<Swift.String?> { get }
  var userID: DialogProtocols.DialogUserId { get }
  var accessoryType: RxCocoa.Driver<Dialog_iOS.DUIUsedCellAccessoryType> { get }
  var accessoryEnabled: RxCocoa.Driver<Swift.Bool> { get }
  var style: RxCocoa.Driver<Dialog_iOS.DUIUserCellStyleProtocol> { get }
  var inProgress: RxCocoa.Driver<Swift.Bool> { get }
}
public class DUIUserCellViewModel : Dialog_iOS.DUICommonCellViewModel, Dialog_iOS.DUIUserCellViewModelProtocol {
  public var fullname: RxCocoa.Driver<Swift.String>
  public var userID: DialogProtocols.DialogUserId
  public var description: RxCocoa.Driver<Swift.String?>
  public var accessoryType: RxCocoa.Driver<Dialog_iOS.DUIUsedCellAccessoryType>
  public var accessoryDidTap: RxSwift.AnyObserver<Swift.Void>
  public var accessoryEnabled: RxCocoa.Driver<Swift.Bool>
  public var basicColor: UIKit.UIColor
  public var isAvatarLoading: RxCocoa.Driver<Swift.Bool>
  public var avatarImage: RxCocoa.Driver<UIKit.UIImage?>
  public var avatarCenterText: RxCocoa.Driver<Swift.String?>
  public var style: RxCocoa.Driver<Dialog_iOS.DUIUserCellStyleProtocol>
  public var inProgress: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Swift.Bool>
  public var accessoryAction: RxSwift.AnyObserver<DialogProtocols.DialogUser>?
  public init(identity: Dialog_iOS.DUICellViewModelIdentity? = nil, myId: DialogProtocols.DialogUserId, member: DialogProtocols.DialogGroupMember, eventBusService: DialogProtocols.EventBusServiceProtocol, fileService: DialogFiles.DialogFileServiceProtocol, canEdit: RxSwift.Observable<Swift.Bool> = Observable.just(false), initialStyle: Dialog_iOS.DUIUserCellStyleProtocol = DUIUserCellDefaultStyle(), colorService: Dialog_iOS.DialogPeerColorsServiceProtocol)
  @objc deinit
  override public init(cellType: Dialog_iOS.DUICellType)
}
public protocol DUIUserCellStyleProtocol : Dialog_iOS.DUICellStyleProtocol {
  var paddings: UIKit.UIEdgeInsets { get }
  var avatarStyle: Dialog_iOS.AvatarViewStyleProtocol { get }
  var titleFont: UIKit.UIFont { get }
  var titleColor: UIKit.UIColor { get }
  var descriptionFont: UIKit.UIFont { get }
  var descriptionColor: UIKit.UIColor { get }
  var accessoryFont: UIKit.UIFont { get }
  var accessoryNormalColor: UIKit.UIColor { get }
  var accessoryActiveColor: UIKit.UIColor { get }
  var accessoryDestructiveColor: UIKit.UIColor { get }
}
public struct DUIUserCellDefaultStyle : Dialog_iOS.DUIUserCellStyleProtocol {
  public var titleFont: UIKit.UIFont {
    get
  }
  public var titleColor: UIKit.UIColor
  public var descriptionFont: UIKit.UIFont {
    get
  }
  public var descriptionColor: UIKit.UIColor
  public var avatarStyle: Dialog_iOS.AvatarViewStyleProtocol
  public var paddings: UIKit.UIEdgeInsets
  public var separatorInsets: UIKit.UIEdgeInsets {
    get
  }
  public var selectionStyle: UIKit.UITableViewCell.SelectionStyle {
    get
  }
  public var accessoryFont: UIKit.UIFont {
    get
  }
  public var accessoryNormalColor: UIKit.UIColor
  public var accessoryActiveColor: UIKit.UIColor
  public var accessoryDestructiveColor: UIKit.UIColor
  public let backgroundColor: UIKit.UIColor
  public init()
}
public struct DUIContactCellDefaultStyle : Dialog_iOS.DUIUserCellStyleProtocol {
  public var titleFont: UIKit.UIFont {
    get
  }
  public var titleColor: UIKit.UIColor
  public var descriptionFont: UIKit.UIFont {
    get
  }
  public var descriptionColor: UIKit.UIColor
  public var avatarStyle: Dialog_iOS.AvatarViewStyleProtocol
  public var paddings: UIKit.UIEdgeInsets
  public var separatorInsets: UIKit.UIEdgeInsets
  public var selectionStyle: UIKit.UITableViewCell.SelectionStyle {
    get
  }
  public var accessoryFont: UIKit.UIFont {
    get
  }
  public var accessoryNormalColor: UIKit.UIColor
  public var accessoryActiveColor: UIKit.UIColor
  public var accessoryDestructiveColor: UIKit.UIColor
  public let backgroundColor: UIKit.UIColor
  public init()
}
@objc @_inheritsConvenienceInitializers public class DUIUserTableCell : Dialog_iOS.DUITableCell, Dialog_iOS.DUIStylizable, Dialog_iOS.DUIViewProtocol {
  public typealias Style = Dialog_iOS.DUIUserCellStyleProtocol
  public var viewModel: Dialog_iOS.DUIUserCellViewModelProtocol?
  public var style: Dialog_iOS.DUIUserTableCell.Style? {
    get
    set
  }
  public func bind(to viewModel: Dialog_iOS.DUIUserCellViewModelProtocol)
  @objc override dynamic public var intrinsicContentSize: CoreGraphics.CGSize {
    @objc get
  }
  @objc override dynamic public func systemLayoutSizeFitting(_ targetSize: CoreGraphics.CGSize, withHorizontalFittingPriority horizontalFittingPriority: UIKit.UILayoutPriority, verticalFittingPriority: UIKit.UILayoutPriority) -> CoreGraphics.CGSize
  @objc override dynamic public func sizeThatFits(_ size: CoreGraphics.CGSize) -> CoreGraphics.CGSize
  @objc override dynamic public func updateConstraints()
  public typealias ViewModel = Dialog_iOS.DUIUserCellViewModelProtocol
  @objc deinit
  @available(iOS 3.0, *)
  @objc override dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public struct DUIUserAvatarViewDefaultStyle : Dialog_iOS.AvatarViewStyleProtocol {
  public let centerTextFont: UIKit.UIFont
  public let cornerRadius: Dialog_iOS.CornerRadiusType
  public let centerTextColor: UIKit.UIColor
  public let avatarLoaderActivityStyle: UIKit.UIActivityIndicatorView.Style
  public let sideLength: CoreGraphics.CGFloat
  public let gradientStartPoint: CoreGraphics.CGPoint
  public let gradientEndPoint: CoreGraphics.CGPoint
  public var gradientColors: [Any]?
}
public protocol DUIViewProtocol : AnyObject {
  associatedtype ViewModel
  var viewModel: Self.ViewModel? { get set }
  func bind(to viewModel: Self.ViewModel)
}
extension DUIViewProtocol {
  public var asAnyView: Dialog_iOS.DUIAnyView<Self.ViewModel> {
    get
  }
}
public protocol BasicAppThemeMappable {
  static func fromAttrs(_ attrs: Dialog_iOS.BasicAppTheme) -> Self
}
extension DUIButtonStyle : Dialog_iOS.BasicAppThemeMappable {
  public static func fromAttrs(_ attrs: Dialog_iOS.BasicAppTheme) -> Dialog_iOS.DUIButtonStyle
}
extension DUIButtonCellStyle : Dialog_iOS.BasicAppThemeMappable {
  public static func fromAttrs(_ attrs: Dialog_iOS.BasicAppTheme) -> Dialog_iOS.DUIButtonCellStyle
}
extension DUITagViewStyle : Dialog_iOS.BasicAppThemeMappable {
  public static func fromAttrs(_ attrs: Dialog_iOS.BasicAppTheme) -> Dialog_iOS.DUITagViewStyle
}
extension DUITagsViewStyle : Dialog_iOS.BasicAppThemeMappable {
  public static func fromAttrs(_ attrs: Dialog_iOS.BasicAppTheme) -> Dialog_iOS.DUITagsViewStyle
}
public protocol DUIWebViewModelProtocol : AnyObject, WebKit.WKNavigationDelegate, WebKit.WKScriptMessageHandler, WebKit.WKUIDelegate {
  var url: RxCocoa.Driver<Foundation.URL> { get }
  var historyObserver: RxSwift.AnyObserver<Foundation.URL> { get }
  var webViewLoading: RxSwift.AnyObserver<Swift.Double> { get }
  var pageTitle: RxSwift.AnyObserver<Swift.String?> { get }
  var forwardButtonCanBeEnabled: RxSwift.AnyObserver<Swift.Bool> { get }
  var backButtonCanBeEnabled: RxSwift.AnyObserver<Swift.Bool> { get }
  var webConfiguration: RxCocoa.Driver<WebKit.WKWebViewConfiguration> { get }
  var backButtonPressed: RxSwift.Observable<Swift.Void> { get }
  var forwardButtonPressed: RxSwift.Observable<Swift.Void> { get }
  var reloadButtonPressed: RxSwift.Observable<Swift.Void> { get }
  var shareButtonPressed: RxSwift.Observable<Foundation.URL> { get }
  var estimatedProgress: RxCocoa.Driver<Swift.Double> { get }
  var titleForStatus: RxCocoa.Driver<Swift.String?> { get }
  var shouldDismiss: RxCocoa.Driver<Swift.Void> { get }
  var evaluateJavaScript: RxCocoa.Driver<Swift.String> { get }
  var didReceiveMessage: RxCocoa.Driver<Dialog_iOS.MiniAppMessage> { get }
}
public enum MiniAppMessage : Swift.Equatable {
  case openMiniApp(_: Swift.String = "")
  case openDiscoverUrl(_: Foundation.URL = URL(fileURLWithPath: ""), _: Dialog_iOS.MiniAppOpenDiscoverUrlType = .main)
  public static func from(message: WebKit.WKScriptMessage) -> Dialog_iOS.MiniAppMessage?
  public static func == (lhs: Dialog_iOS.MiniAppMessage, rhs: Dialog_iOS.MiniAppMessage) -> Swift.Bool
}
public enum MiniAppOpenDiscoverUrlType : Swift.Equatable {
  case main
  case sidebar
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Dialog_iOS.MiniAppOpenDiscoverUrlType, b: Dialog_iOS.MiniAppOpenDiscoverUrlType) -> Swift.Bool
}
extension MiniAppMessage : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public protocol DUIWebViewToolbarProxyProtocol : Dialog_iOS.DUIToolBarViewModelProtocol, Dialog_iOS.DUIWebViewModelProtocol {
}
@_inheritsConvenienceInitializers final public class EntryScene : Dialog_iOS.Scene<Swift.Void, UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.EntryScene.Builder
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<Swift.Void, UIKit.UIViewController, Dialog_iOS.EntryViewModelProtocol> {
    override final public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>) -> Dialog_iOS.EntryViewModelProtocol
    override final public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>, viewModel: Dialog_iOS.EntryViewModelProtocol) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<Swift.Void, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
public protocol EntryViewModelProtocol {
  var config: Dialog_iOS.DialogEntryViewConfig? { get }
}
public class EntryViewModel : Dialog_iOS.EntryViewModelProtocol {
  final public let config: Dialog_iOS.DialogEntryViewConfig?
  public init(config: Dialog_iOS.DialogEntryViewConfig?)
  @objc deinit
}
extension Error {
  public var dialogLocalizedDescription: Swift.String {
    get
  }
}
public protocol ErrorTextEmitter {
  var errorText: RxCocoa.Driver<Swift.String?> { get }
}
public protocol TextValidator {
  associatedtype Input
  associatedtype Output
  var errorType: RxCocoa.Driver<Self.Output> { get }
  init(driver: RxCocoa.Driver<Self.Input>)
}
public struct StubErrorTextEmitter : Dialog_iOS.ErrorTextEmitter {
  public var errorText: RxCocoa.Driver<Swift.String?>
  public init()
}
@objc @_hasMissingDesignatedInitializers final public class FeaturePlaceholderViewController : UIKit.UIViewController {
  @objc override final public func viewDidLoad()
  @objc override final public var supportedInterfaceOrientations: UIKit.UIInterfaceOrientationMask {
    @objc get
  }
  @objc deinit
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
}
@objc @_inheritsConvenienceInitializers final public class FeaturePlaceholderViewControllerContentView : UIKit.UIView {
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
@_inheritsConvenienceInitializers final public class FeedbackScene : Dialog_iOS.Scene<Swift.Void, UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.FeedbackScene.Builder
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<Swift.Void, UIKit.UIViewController, Dialog_iOS.FeedbackViewModelProtocol> {
    override public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>) -> Dialog_iOS.FeedbackViewModelProtocol
    override public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>, viewModel: Dialog_iOS.FeedbackViewModelProtocol) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<Swift.Void, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
public struct FeedbackFloatingTextInputStyle : Dialog_iOS.FloatingTextInputStyleProtocol {
  public var textColor: UIKit.UIColor
  public var textFont: UIKit.UIFont
  public var placeholderColor: UIKit.UIColor
  public var placeholderFont: UIKit.UIFont
  public var placeholderTitleFont: UIKit.UIFont
  public var underlineColor: UIKit.UIColor {
    get
  }
  public var underlineHeight: CoreGraphics.CGFloat {
    get
  }
  public var spacingBetweenUnderlineAndText: CoreGraphics.CGFloat {
    get
  }
  public var spacingBetweenPlacholderAndText: CoreGraphics.CGFloat {
    get
  }
  public var errorTextColor: UIKit.UIColor {
    get
  }
  public var errorUnderlineColor: UIKit.UIColor {
    get
  }
  public var fadeInDuration: Foundation.TimeInterval {
    get
  }
  public var fadeOutDuration: Foundation.TimeInterval {
    get
  }
  public var isUnderlineHidden: Swift.Bool
}
public protocol FeedbackViewModelProtocol {
  var generalColor: RxCocoa.Driver<UIKit.UIColor> { get }
  var title: RxCocoa.Driver<Swift.String> { get }
  var logoViewImage: RxCocoa.Driver<UIKit.UIImage?> { get }
  var emailTextFieldPlaceholder: RxCocoa.Driver<Swift.String> { get }
  var emailTextFieldError: RxCocoa.Driver<Swift.String?> { get }
  var feedbackTextViewPlaceholder: RxCocoa.Driver<Swift.String> { get }
  var feedbackTextViewError: RxCocoa.Driver<Swift.String?> { get }
  var logSendingCheckboxImage: RxCocoa.Driver<UIKit.UIImage?> { get }
  var logSendingLabelText: RxCocoa.Driver<Swift.String> { get }
  var logSendingDescriptionText: RxCocoa.Driver<Swift.String> { get }
  var feedbackDescriptionText: RxCocoa.Driver<Swift.String> { get }
  var proceedButtonTitle: RxCocoa.Driver<Swift.String> { get }
  var proceedButtonIsEnabled: RxCocoa.Driver<Swift.Bool> { get }
  var callSupportButtonTitle: RxCocoa.Driver<Swift.String> { get }
  var suggestSupportPhoneCall: RxCocoa.Driver<Swift.String> { get }
  var showEmail: RxCocoa.Driver<Swift.Bool> { get }
  var showCallSupport: RxCocoa.Driver<Swift.Bool> { get }
  var closeButtonTap: RxSwift.AnyObserver<Swift.Void> { get }
  var emailTextFieldText: RxSwift.AnyObserver<Swift.String> { get }
  var feedbackTextViewText: RxSwift.AnyObserver<Swift.String> { get }
  var logSendingCheckboxTap: RxSwift.AnyObserver<Swift.Void> { get }
  var proceedButtonTap: RxSwift.AnyObserver<Swift.Void> { get }
  var callSupportButtonTap: RxSwift.AnyObserver<Swift.Void> { get }
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class FloatingTextField : UIKit.UITextField, Dialog_iOS.FloatingTextInputProtocol {
  @objc override dynamic public var placeholder: Swift.String? {
    @objc get
    @objc set
  }
  public var style: Dialog_iOS.FloatingTextInputStyleProtocol {
    get
    set
  }
  final public let underlineView: UIKit.UIView
  final public let titleLabel: UIKit.UILabel
  public var textHeight: CoreGraphics.CGFloat {
    get
  }
  public var titleHeight: CoreGraphics.CGFloat {
    get
  }
  @objc override dynamic public var text: Swift.String? {
    @objc get
    @objc set
  }
  @objc override dynamic public var attributedText: Foundation.NSAttributedString? {
    @objc get
    @objc set
  }
  public func titleActiveRect(forBounds bounds: CoreGraphics.CGRect) -> CoreGraphics.CGRect
  public func titleInactiveRect(forBounds bounds: CoreGraphics.CGRect) -> CoreGraphics.CGRect
  @objc override dynamic open func textRect(forBounds bounds: CoreGraphics.CGRect) -> CoreGraphics.CGRect
  @objc override dynamic public func placeholderRect(forBounds bounds: CoreGraphics.CGRect) -> CoreGraphics.CGRect
  @objc override dynamic public func editingRect(forBounds bounds: CoreGraphics.CGRect) -> CoreGraphics.CGRect
  @objc override dynamic open var intrinsicContentSize: CoreGraphics.CGSize {
    @objc get
  }
  @objc override dynamic public func layoutSubviews()
  @objc deinit
}
extension Reactive where Base : UIKit.UIView, Base : Dialog_iOS.FloatingTextInputProtocol {
  public var placeholder: RxCocoa.Binder<Swift.String?> {
    get
  }
  public var errorText: RxCocoa.Binder<Swift.String?> {
    get
  }
}
public protocol FloatingTextInputStyleProtocol {
  var textColor: UIKit.UIColor { get }
  var textFont: UIKit.UIFont { get }
  var placeholderColor: UIKit.UIColor { get }
  var placeholderFont: UIKit.UIFont { get }
  var placeholderTitleFont: UIKit.UIFont { get }
  var underlineColor: UIKit.UIColor { get }
  var underlineHeight: CoreGraphics.CGFloat { get }
  var spacingBetweenUnderlineAndText: CoreGraphics.CGFloat { get }
  var spacingBetweenPlacholderAndText: CoreGraphics.CGFloat { get }
  var errorTextColor: UIKit.UIColor { get }
  var errorUnderlineColor: UIKit.UIColor { get }
  var fadeInDuration: Foundation.TimeInterval { get }
  var fadeOutDuration: Foundation.TimeInterval { get }
  var isUnderlineHidden: Swift.Bool { get }
}
public struct FloatingTextInputDefaultStyle : Dialog_iOS.FloatingTextInputStyleProtocol {
  public var textColor: UIKit.UIColor
  public var textFont: UIKit.UIFont {
    get
  }
  public var placeholderColor: UIKit.UIColor
  public var placeholderFont: UIKit.UIFont {
    get
  }
  public var placeholderTitleFont: UIKit.UIFont {
    get
  }
  public var underlineColor: UIKit.UIColor
  public var underlineHeight: CoreGraphics.CGFloat
  public var spacingBetweenUnderlineAndText: CoreGraphics.CGFloat
  public var spacingBetweenPlacholderAndText: CoreGraphics.CGFloat
  public var errorTextColor: UIKit.UIColor
  public var errorUnderlineColor: UIKit.UIColor {
    get
  }
  public var fadeInDuration: Foundation.TimeInterval {
    get
  }
  public var fadeOutDuration: Foundation.TimeInterval {
    get
  }
  public var isUnderlineHidden: Swift.Bool
  public init(isUnderlineHidden: Swift.Bool = false)
}
public protocol FloatingTextInputProtocol : AnyObject {
  var sourceText: Swift.String { get set }
  var errorText: Swift.String? { get set }
  var placeholder: Swift.String? { get set }
  var style: Dialog_iOS.FloatingTextInputStyleProtocol { get set }
  var hasText: Swift.Bool { get }
  var hasErrorMessage: Swift.Bool { get }
  var titleHeight: CoreGraphics.CGFloat { get }
  var textHeight: CoreGraphics.CGFloat { get }
  var underlineView: UIKit.UIView { get }
  var titleLabel: UIKit.UILabel { get }
  func titleActiveRect(forBounds bounds: CoreGraphics.CGRect) -> CoreGraphics.CGRect
  func titleInactiveRect(forBounds bounds: CoreGraphics.CGRect) -> CoreGraphics.CGRect
  func underlineRect(forBounds bounds: CoreGraphics.CGRect) -> CoreGraphics.CGRect
  func updateTitleVisibilityIfNeeded(animated: Swift.Bool)
}
extension FloatingTextInputProtocol {
  public var hasErrorMessage: Swift.Bool {
    get
  }
  public var errorText: Swift.String? {
    get
    set
  }
  public func underlineRect(forBounds bounds: CoreGraphics.CGRect) -> CoreGraphics.CGRect
}
extension FloatingTextInputProtocol where Self : UIKit.UITextView {
  public var sourceText: Swift.String {
    get
    set
  }
  public func updateTitleVisibilityIfNeeded(animated: Swift.Bool = false)
}
extension FloatingTextInputProtocol where Self : UIKit.UITextField {
  public var sourceText: Swift.String {
    get
    set
  }
  public func updateTitleVisibilityIfNeeded(animated: Swift.Bool = false)
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class FloatingTextView : UIKit.UITextView, Dialog_iOS.FloatingTextInputProtocol {
  public var placeholder: Swift.String? {
    get
    set
  }
  public var style: Dialog_iOS.FloatingTextInputStyleProtocol {
    get
    set
  }
  final public let underlineView: UIKit.UIView
  final public let titleLabel: UIKit.UILabel
  public var textHeight: CoreGraphics.CGFloat {
    get
    set
  }
  public var titleHeight: CoreGraphics.CGFloat {
    get
  }
  @available(*, unavailable)
  @objc override dynamic public var isScrollEnabled: Swift.Bool {
    @objc get
    @objc set
  }
  @objc deinit
  @objc override dynamic public func caretRect(for position: UIKit.UITextPosition) -> CoreGraphics.CGRect
  public func titleActiveRect(forBounds bounds: CoreGraphics.CGRect) -> CoreGraphics.CGRect
  public func titleInactiveRect(forBounds bounds: CoreGraphics.CGRect) -> CoreGraphics.CGRect
  @objc override dynamic open var intrinsicContentSize: CoreGraphics.CGSize {
    @objc get
  }
  @objc override dynamic public func layoutSubviews()
}
extension FloatingTextView : UIKit.UITextPasteDelegate {
  @objc dynamic public func textPasteConfigurationSupporting(_ textPasteConfigurationSupporting: UIKit.UITextPasteConfigurationSupporting, shouldAnimatePasteOf attributedString: Foundation.NSAttributedString, to textRange: UIKit.UITextRange) -> Swift.Bool
}
public protocol ForwardableDialogsFilterProtocol {
  func filterDialogs(from dialogs: RxSwift.Observable<[DialogProtocols.DialogState]>) -> RxSwift.Observable<[DialogProtocols.DialogState]>
}
final public class ForwardableDialogsFilter : Dialog_iOS.ForwardableDialogsFilterProtocol {
  public init(forwardableDispatcher: Dialog_iOS.ForwardTargetListAppliableDispatcherProtocol)
  final public func filterDialogs(from dialogs: RxSwift.Observable<[DialogProtocols.DialogState]>) -> RxSwift.Observable<[DialogProtocols.DialogState]>
  @objc deinit
}
public protocol ForwardTargetListAppliableDispatcherProtocol {
  func messagesCanBeForwaredTo(dialog: DialogProtocols.DialogState) -> RxSwift.Observable<Swift.Bool>
}
final public class ForwardTargetListAppliableDispatcher : Dialog_iOS.ForwardTargetListAppliableDispatcherProtocol {
  public init(sendabilityService: Dialog_iOS.SendabilityServiceProtocol)
  final public func messagesCanBeForwaredTo(dialog: DialogProtocols.DialogState) -> RxSwift.Observable<Swift.Bool>
  @objc deinit
}
public enum ForwardTargetListInapplicableItemPolicy {
  case present
  case disable
  public static func == (a: Dialog_iOS.ForwardTargetListInapplicableItemPolicy, b: Dialog_iOS.ForwardTargetListInapplicableItemPolicy) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
@_hasMissingDesignatedInitializers open class ForwardTargetListViewModel : Dialog_iOS.DialogsListViewModelProtocol {
  final public let titleView: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, UIKit.UIView?>
  final public let title: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Swift.String>
  public var tabBarItem: RxCocoa.Driver<UIKit.UITabBarItem>
  public var tabBarBadgeValue: RxCocoa.Driver<Swift.Int>
  public var applicationBadgeValue: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Swift.Int>
  public var shouldShowLogout: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Swift.Bool>
  public var allowsAddingDialog: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Swift.Bool>
  public var footerView: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, UIKit.UIView?>
  public var dialogCellTap: RxSwift.AnyObserver<Dialog_iOS.DialogsListCellViewModel> {
    get
  }
  public var dialogCellSwipeAction: RxSwift.AnyObserver<(DialogProtocols.DialogState, Dialog_iOS.DialogSwipeButtonTypeConfigType)>
  public var didFocusOnSearch: RxSwift.AnyObserver<Swift.Void>
  public var createDialog: RxSwift.AnyObserver<Swift.Void>
  public var openContacts: RxSwift.AnyObserver<Swift.Void>
  final public let search: Dialog_iOS.DialogListViewModelSearch
  final public let supportsSearching: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Swift.Bool>
  public var sections: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, [Dialog_iOS.DialogsListSection]>
  public var sectionsWillChange: RxCocoa.Driver<Swift.Void>
  public var logout: RxSwift.AnyObserver<Swift.Void>
  final public let inapplicableItemsPolicy: RxRelay.BehaviorRelay<Dialog_iOS.ForwardTargetListInapplicableItemPolicy>
  final public let themeService: Dialog_iOS.AppThemeService
  public var isDialogsListEmpty: RxCocoa.Driver<Swift.Bool> {
    get
    set
  }
  final public let isFavoritesEnabled: RxSwift.Observable<Swift.Bool>
  final public let openFavorites: RxSwift.AnyObserver<RxSwift.PublishSubject<Swift.Void>.Element>
  final public let myId: DialogProtocols.DialogUserId
  @objc deinit
}
public struct ForwardTargetsListSource {
  public let messages: [DialogProtocols.DialogMessage]
  public init(messages: [DialogProtocols.DialogMessage])
}
@_inheritsConvenienceInitializers final public class ForwardTargetsListScene : Dialog_iOS.Scene<Dialog_iOS.ForwardTargetsListSource, UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.ForwardTargetsListScene.Builder
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<Dialog_iOS.ForwardTargetsListSource, UIKit.UIViewController, Dialog_iOS.DialogsListViewModelProtocol> {
    override final public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Dialog_iOS.ForwardTargetsListSource>) -> Dialog_iOS.DialogsListViewModelProtocol
    override final public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Dialog_iOS.ForwardTargetsListSource>, viewModel: Dialog_iOS.DialogsListViewModelProtocol) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<Dialog_iOS.ForwardTargetsListSource, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
@_inheritsConvenienceInitializers final public class ForwardTargetsSearchResultsScene : Dialog_iOS.Scene<Dialog_iOS.ForwardTargetsListSource, Dialog_iOS.DialogListSearchResultsSceneViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.AnySceneBuilder<Dialog_iOS.DialogListSearchResultsSceneViewController, Dialog_iOS.ForwardTargetsListSource>
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<Dialog_iOS.ForwardTargetsListSource, Dialog_iOS.DialogListSearchResultsSceneViewController, Dialog_iOS.DialogListSearchViewModelProtocol> {
    override final public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Dialog_iOS.ForwardTargetsListSource>) -> Dialog_iOS.DialogListSearchViewModelProtocol
    override final public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Dialog_iOS.ForwardTargetsListSource>, viewModel: Dialog_iOS.DialogListSearchViewModelProtocol) -> Dialog_iOS.DialogListSearchResultsSceneViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<Dialog_iOS.ForwardTargetsListSource, Dialog_iOS.DialogListSearchResultsSceneViewController>.Builder = super, resolver: Swinject.Resolver)
}
@_inheritsConvenienceInitializers final public class GeneralAppearanceScene : Dialog_iOS.Scene<Swift.Void, UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.GeneralAppearanceScene.Builder
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<Swift.Void, UIKit.UIViewController, Dialog_iOS.GeneralAppearanceViewModelProtocol> {
    override final public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>) -> Dialog_iOS.GeneralAppearanceViewModelProtocol
    override final public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>, viewModel: Dialog_iOS.GeneralAppearanceViewModelProtocol) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<Swift.Void, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
@objc @_hasMissingDesignatedInitializers final public class GeneralAppearanceViewController : UIKit.UIViewController, Dialog_iOS.DUIViewProtocol {
  final public var viewModel: Dialog_iOS.GeneralAppearanceViewModelProtocol?
  public init(viewModel vm: Dialog_iOS.GeneralAppearanceViewModelProtocol?)
  @objc override final public func viewDidLoad()
  final public func bind(to viewModel: Dialog_iOS.GeneralAppearanceViewModelProtocol)
  @objc override final public func viewDidLayoutSubviews()
  @objc deinit
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  public typealias ViewModel = Dialog_iOS.GeneralAppearanceViewModelProtocol
}
public protocol GeneralAppearanceViewModelProtocol : AnyObject {
  var title: RxSwift.Observable<Swift.String> { get }
  var switchToggledObserver: RxSwift.AnyObserver<Swift.Bool> { get }
  var state: RxSwift.Observable<Swift.Bool> { get }
  var sections: RxSwift.Observable<[Dialog_iOS.AppearanceSection]> { get }
}
final public class GeneralAppearanceViewModel : Dialog_iOS.GeneralAppearanceViewModelProtocol {
  final public var title: RxSwift.Observable<Swift.String>
  final public var sections: RxSwift.Observable<[Dialog_iOS.AppearanceSection]>
  final public var state: RxSwift.Observable<Swift.Bool>
  final public var switchToggledObserver: RxSwift.AnyObserver<Swift.Bool>
  public init(settingsConfigService: DialogProtocols.SettingsConfigServiceProtocol, eventBusService: DialogProtocols.EventBusServiceProtocol)
  @objc deinit
}
public struct AppearanceSection {
  public var items: [Dialog_iOS.AppearanceSection.Item]
}
extension AppearanceSection : Differentiator.SectionModelType {
  public typealias Item = Dialog_iOS.AppearanceCellViewModelProtocol
  public init(original: Dialog_iOS.AppearanceSection, items: [Dialog_iOS.AppearanceCellViewModelProtocol])
}
public enum GeneralSettingsRoute : XCoordinator.Route {
  case initial
  case editProfile
  case notifications
  case passcode
  case privacy
  case onboarding
  case whatsNew
  case favorites(peer: DialogProtocols.DialogPeer)
  case feedback
  case appearance
  case logout
  case miniApp(withUrl: Foundation.URL)
  case none
}
public typealias GeneralSettingsRouter = XCoordinator.WeakRouter<Dialog_iOS.GeneralSettingsRoute>
public typealias AnyGeneralSettingsCoordinator = Dialog_iOS.GeneralSettingsCoordinator.AnyCoordinatorType
final public class GeneralSettingsCoordinator : XCoordinator.NavigationCoordinator<Dialog_iOS.GeneralSettingsRoute> {
  public init(container: Swinject.Container, rootViewController: UIKit.UINavigationController)
  override final public func prepareTransition(for route: Dialog_iOS.GeneralSettingsRoute) -> XCoordinator.NavigationTransition
  override public init(rootViewController: XCoordinator.NavigationCoordinator<Dialog_iOS.GeneralSettingsRoute>.RootViewController = super, initialRoute: Dialog_iOS.GeneralSettingsRoute? = super)
  override public init(rootViewController: XCoordinator.NavigationCoordinator<Dialog_iOS.GeneralSettingsRoute>.RootViewController = super, root: XCoordinator.Presentable)
  @objc deinit
}
@_inheritsConvenienceInitializers final public class GeneralSettingsScene : Dialog_iOS.Scene<Swift.Void, UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.GeneralSettingsScene.Builder
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<Swift.Void, UIKit.UIViewController, Dialog_iOS.GeneralSettingsViewModelProtocol> {
    override final public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>) -> Dialog_iOS.GeneralSettingsViewModelProtocol
    override final public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>, viewModel: Dialog_iOS.GeneralSettingsViewModelProtocol) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<Swift.Void, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
public struct GeneralSettingsSection : Differentiator.SectionModelType {
  public let items: [Dialog_iOS.GeneralSettingsCellViewModelProtocol]
  public init(original: Dialog_iOS.GeneralSettingsSection, items: [Dialog_iOS.GeneralSettingsCellViewModelProtocol])
  public init(items: [Dialog_iOS.GeneralSettingsCellViewModelProtocol])
  public typealias Item = Dialog_iOS.GeneralSettingsCellViewModelProtocol
}
public protocol GeneralSettingsCellViewModelProtocol {
  var route: Dialog_iOS.GeneralSettingsRoute { get }
}
public protocol GeneralSettingsViewModelProtocol {
  var eventBus: DialogProtocols.EventBusServiceProtocol { get }
  var sections: RxCocoa.Driver<[Dialog_iOS.GeneralSettingsSection]> { get }
  var anyCellTap: RxSwift.AnyObserver<Dialog_iOS.GeneralSettingsCellViewModelProtocol> { get }
  var profileLinkCopyAction: RxSwift.AnyObserver<Swift.Void> { get }
  var requestLogoutConfirmationWithActiveCall: RxCocoa.Driver<Swift.Void> { get }
  var confirmLogout: RxSwift.AnyObserver<Swift.Void> { get }
}
public class GeneralSettingsViewModel : Dialog_iOS.GeneralSettingsViewModelProtocol {
  final public let eventBus: DialogProtocols.EventBusServiceProtocol
  final public let sections: RxCocoa.Driver<[Dialog_iOS.GeneralSettingsSection]>
  public var anyCellTap: RxSwift.AnyObserver<Dialog_iOS.GeneralSettingsCellViewModelProtocol> {
    get
  }
  final public let profileLinkCopyAction: RxSwift.AnyObserver<Swift.Void>
  final public let requestLogoutConfirmationWithActiveCall: RxCocoa.Driver<Swift.Void>
  final public let confirmLogout: RxSwift.AnyObserver<Swift.Void>
  public init(myUserResolver: Dialog_iOS.MyUserResolverProtocol, routerService: Dialog_iOS.RouterServiceProtocol, authService: DialogAuth.AuthenticationTaskPerformer, eventBusService: DialogProtocols.EventBusServiceProtocol, fileService: DialogFiles.DialogFileServiceProtocol, userPresenceStateService: DialogProtocols.UserPresenceStateServiceProtocol, colorService: Dialog_iOS.DialogPeerColorsServiceProtocol, themeService: Dialog_iOS.AppThemeService, callsService: DialogCalls.CallsServiceProtocol?, voipNotificationsService: Dialog_iOS.UserVOIPNotificationsServiceProtocol?, featureFlagService: DialogProtocols.DialogFeatureFlagsServiceProtocol)
  @objc deinit
}
extension Theme.Domain {
  public static let general: Dialog_iOS.Theme.Domain
}
extension Theme.Keys.General {
  public static let controlActiveColor: Dialog_iOS.Theme.Keys.General
  public static let controlForegroundColor: Dialog_iOS.Theme.Keys.General
  public static let disabledImageColor: Dialog_iOS.Theme.Keys.General
  public static let buttonCornerRadius: Dialog_iOS.Theme.Keys.General
}
extension Theme.Keys.General {
  public struct Tags {
  }
}
extension Theme.Defaults {
  public static let general: DialogSharedComponents.Subtheme<Dialog_iOS.Theme.Keys.General>
}
extension Theme.Keys {
  public struct General : Dialog_iOS.DomainSpecificKey, Swift.RawRepresentable {
    public static let domain: Dialog_iOS.Theme.Domain
    public var domainInternalId: Swift.String {
      get
    }
    public let rawValue: Swift.String
    public init(rawValue: Swift.String)
    public typealias RawValue = Swift.String
  }
}
public enum NotificationInfo {
  public struct AnonymousInfo {
    public typealias Handler = (UIKit.UIBackgroundFetchResult) -> Swift.Void
    public typealias Payload = [Swift.AnyHashable : Any]
    public let payload: Dialog_iOS.NotificationInfo.AnonymousInfo.Payload
    public let completionHandler: Dialog_iOS.NotificationInfo.AnonymousInfo.Handler
    public init(payload: Dialog_iOS.NotificationInfo.AnonymousInfo.Payload, completionHandler: @escaping Dialog_iOS.NotificationInfo.AnonymousInfo.Handler)
  }
  public struct ResponseInfo {
    public let response: UserNotifications.UNNotificationResponse
    public let completionHandler: () -> Swift.Void
    public init(response: UserNotifications.UNNotificationResponse, completionHandler: @escaping () -> Swift.Void)
  }
  public struct UserNotificationInfo {
    public let notification: UserNotifications.UNNotification
    public let completionHandler: (UserNotifications.UNNotificationPresentationOptions) -> Swift.Void
    public init(notification: UserNotifications.UNNotification, completionHandler: @escaping (UserNotifications.UNNotificationPresentationOptions) -> Swift.Void)
  }
  case anonymous(Dialog_iOS.NotificationInfo.AnonymousInfo)
  case notification(Dialog_iOS.NotificationInfo.UserNotificationInfo)
  case response(Dialog_iOS.NotificationInfo.ResponseInfo)
  public var payload: [Swift.AnyHashable : Any] {
    get
  }
}
public enum NotificationEvent {
  case notification(Dialog_iOS.NotificationInfo, user: DialogProtocols.AuthUserEntry)
  case didRegisterForRemoteNotifications(token: Foundation.Data)
  case didFailToRegisterForRemoteNotifications(Swift.Error)
}
public protocol GlobalNotificationUserProxyServiceProtocol {
  func handleNotification(_ info: Dialog_iOS.NotificationInfo)
}
public enum GlobalNotificationError : Swift.Error {
  case noUserToActivate
  case failToActivateUser
  case userActivationTooLong
  case noNotificationServiceResolved
  public static func == (a: Dialog_iOS.GlobalNotificationError, b: Dialog_iOS.GlobalNotificationError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
final public class GlobalNotificationUserProxyService : Dialog_iOS.GlobalNotificationUserProxyServiceProtocol {
  public typealias NotificationServiceResolver = ((DialogProtocols.AuthUserEntry) -> Dialog_iOS.PushNotificationsServiceProtocol?)
  public typealias UserActivator = ((DialogProtocols.AuthUserEntry) -> RxSwift.Single<Swift.Bool>)
  public init(activeUsersService: Dialog_iOS.ActiveUsersServiceProtocol, authService: DialogProtocols.AuthServiceProtocol, notificationServiceResolver: @escaping Dialog_iOS.GlobalNotificationUserProxyService.NotificationServiceResolver, appAuthStateService: Dialog_iOS.AppAuthStateServiceProtocol, userActivator: @escaping Dialog_iOS.GlobalNotificationUserProxyService.UserActivator)
  final public func handleNotification(_ info: Dialog_iOS.NotificationInfo)
  @objc deinit
}
@_inheritsConvenienceInitializers final public class GroupLinkScene : Dialog_iOS.Scene<(DialogProtocols.DialogGroupId, Dialog_iOS.GroupLinkType), UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.GroupLinkScene.Builder
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<(DialogProtocols.DialogGroupId, Dialog_iOS.GroupLinkType), UIKit.UIViewController, Dialog_iOS.GroupLinkViewModelProtocol> {
    override final public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<(DialogProtocols.DialogGroupId, Dialog_iOS.GroupLinkType)>) -> Dialog_iOS.GroupLinkViewModelProtocol
    override final public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<(DialogProtocols.DialogGroupId, Dialog_iOS.GroupLinkType)>, viewModel: Dialog_iOS.GroupLinkViewModelProtocol) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<(DialogProtocols.DialogGroupId, Dialog_iOS.GroupLinkType), UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
public protocol GroupLinkViewControllerStyleProtocol {
  var infoTextAttributes: [Foundation.NSAttributedString.Key : Any] { get }
  var linkTextAttributes: [Foundation.NSAttributedString.Key : Any] { get }
  var revokeButtonIcon: UIKit.UIImage? { get }
  var revokeButtonTitleAttributes: [Foundation.NSAttributedString.Key : Any] { get }
  var copyIcon: UIKit.UIImage? { get }
  var copyButtonCornerRadius: Dialog_iOS.CornerRadiusType { get }
  var copyButtonTitleAttributes: [Foundation.NSAttributedString.Key : Any] { get }
  var copyButtonBackgroundColor: UIKit.UIColor { get }
  var backgroundColor: UIKit.UIColor { get }
}
public struct GroupLinkViewControllerDefaultStyle : Dialog_iOS.GroupLinkViewControllerStyleProtocol {
  public let infoTextAttributes: [Foundation.NSAttributedString.Key : Any]
  public let linkTextAttributes: [Foundation.NSAttributedString.Key : Any]
  public let revokeButtonIcon: UIKit.UIImage?
  public let revokeButtonTitleAttributes: [Foundation.NSAttributedString.Key : Any]
  public let copyIcon: UIKit.UIImage?
  public let copyButtonCornerRadius: DialogSharedComponents.CornerRadiusType
  public let copyButtonTitleAttributes: [Foundation.NSAttributedString.Key : Any]
  public let copyButtonBackgroundColor: UIKit.UIColor
  public let backgroundColor: UIKit.UIColor
}
@objc @_inheritsConvenienceInitializers public class GroupLinkCopyButton : UIKit.UIButton {
  @objc override dynamic public var isEnabled: Swift.Bool {
    @objc get
    @objc set
  }
  @objc override dynamic public var isHighlighted: Swift.Bool {
    @objc get
    @objc set
  }
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public enum GroupLinkType : Swift.Int {
  case invite
  case integration
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public protocol GroupLinkViewModelProtocol : Dialog_iOS.ViewModelProtocol {
  var title: RxCocoa.Driver<Swift.String> { get }
  var revokeButtonTitle: RxCocoa.Driver<Swift.String> { get }
  var copyButtonTitle: RxCocoa.Driver<Swift.String> { get }
  var link: RxCocoa.Driver<Swift.String?> { get }
  var info: RxCocoa.Driver<Swift.String?> { get }
  var isLoading: RxCocoa.Driver<Swift.Bool> { get }
  var isRevokeAllowed: RxCocoa.Driver<Swift.Bool> { get }
  var revokeAction: RxSwift.AnyObserver<Swift.Void> { get }
  var copyAction: RxSwift.AnyObserver<Swift.String> { get }
  var copyConfirmation: RxCocoa.Driver<Swift.String> { get }
}
public class GroupLinkViewModel : Dialog_iOS.GroupLinkViewModelProtocol {
  final public let title: RxCocoa.Driver<Swift.String>
  final public let revokeButtonTitle: RxCocoa.Driver<Swift.String>
  final public let copyButtonTitle: RxCocoa.Driver<Swift.String>
  final public let link: RxCocoa.Driver<Swift.String?>
  final public let info: RxCocoa.Driver<Swift.String?>
  final public let isLoading: RxCocoa.Driver<Swift.Bool>
  final public let isRevokeAllowed: RxCocoa.Driver<Swift.Bool>
  final public let revokeAction: RxSwift.AnyObserver<Swift.Void>
  final public let copyAction: RxSwift.AnyObserver<Swift.String>
  final public let copyConfirmation: RxCocoa.Driver<Swift.String>
  public init(groupId: DialogProtocols.DialogGroupId, activeUserId: DialogProtocols.DialogUserId, linkType: Dialog_iOS.GroupLinkType, groupService: DialogProtocols.DialogGroupServiceProtocol, eventBusService: DialogProtocols.EventBusServiceProtocol, colorService: Dialog_iOS.DialogPeerColorsServiceProtocol)
  @objc deinit
}
public struct GroupPermissionSection : Differentiator.SectionModelType {
  public let items: [Dialog_iOS.BaseGroupPermissionCellViewModelProtocol]
  public init(original: Dialog_iOS.GroupPermissionSection, items: [Dialog_iOS.BaseGroupPermissionCellViewModelProtocol])
  public init(items: [Dialog_iOS.BaseGroupPermissionCellViewModelProtocol])
  public typealias Item = Dialog_iOS.BaseGroupPermissionCellViewModelProtocol
}
public protocol BaseGroupPermissionCellViewModelProtocol {
}
public protocol GroupPermissionCellViewModelProtocol : Dialog_iOS.BaseGroupPermissionCellViewModelProtocol {
  var changePermission: RxSwift.AnyObserver<(DialogProtocols.DialogGroupMember.Permissions, Swift.Bool)> { get }
  var permission: DialogProtocols.DialogGroupMember.Permissions { get }
  var isEnabled: RxCocoa.Driver<Swift.Bool> { get }
  var canChanged: RxCocoa.Driver<Swift.Bool> { get }
  var title: RxCocoa.Driver<Swift.String> { get }
}
public class GroupPermissionCellViewModel : Dialog_iOS.GroupPermissionCellViewModelProtocol {
  final public let changePermission: RxSwift.AnyObserver<(DialogProtocols.DialogGroupMember.Permissions, Swift.Bool)>
  final public let permission: DialogProtocols.DialogGroupMember.Permissions
  final public let isEnabled: RxCocoa.Driver<Swift.Bool>
  final public let canChanged: RxCocoa.Driver<Swift.Bool>
  final public let title: RxCocoa.Driver<Swift.String>
  public init(groupType: DialogProtocols.DialogGroup.GroupType, permission: DialogProtocols.DialogGroupMember.Permissions, canChanged: Swift.Bool, changePermission: RxSwift.AnyObserver<(DialogProtocols.DialogGroupMember.Permissions, Swift.Bool)>, isEnabled: Swift.Bool)
  @objc deinit
}
extension DialogGroupMember.Permissions {
  public func localizedName(with groupType: DialogProtocols.DialogGroup.GroupType) -> Swift.String
}
public typealias GroupAndUser = (groupId: DialogProtocols.DialogGroupId, userId: DialogProtocols.DialogUserId)
@_inheritsConvenienceInitializers public class GroupPermissionsScene : Dialog_iOS.Scene<Dialog_iOS.GroupAndUser, UIKit.UIViewController> {
  override public class func defaultSceneBuilder() -> Dialog_iOS.GroupPermissionsScene.Builder
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<Dialog_iOS.GroupAndUser, UIKit.UIViewController, Dialog_iOS.GroupPermissionsViewModelProtocol> {
    override final public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Dialog_iOS.GroupAndUser>) -> Dialog_iOS.GroupPermissionsViewModelProtocol
    override final public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Dialog_iOS.GroupAndUser>, viewModel: Dialog_iOS.GroupPermissionsViewModelProtocol) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<Dialog_iOS.GroupAndUser, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
public protocol GroupPermissionsViewModelProtocol : Dialog_iOS.ViewModelProtocol {
  var title: RxCocoa.Driver<Swift.String> { get }
  var isLoading: RxCocoa.Driver<Swift.Bool> { get }
  var sections: RxCocoa.Driver<[Dialog_iOS.GroupPermissionSection]> { get }
  var transferOwnership: RxSwift.AnyObserver<Swift.Void> { get }
}
public class GroupPermissionsViewModel : Dialog_iOS.GroupPermissionsViewModelProtocol {
  final public let title: RxCocoa.Driver<Swift.String>
  final public let isLoading: RxCocoa.Driver<Swift.Bool>
  final public let sections: RxCocoa.Driver<[Dialog_iOS.GroupPermissionSection]>
  final public let transferOwnership: RxSwift.AnyObserver<Swift.Void>
  public init(myId: DialogProtocols.DialogUserId, groupId: DialogProtocols.DialogGroupId, userId: DialogProtocols.DialogUserId, groupService: DialogProtocols.DialogGroupServiceProtocol, eventBusService: DialogProtocols.EventBusServiceProtocol)
  @objc deinit
}
public enum GroupProfileCellType : Swift.Int {
  case header
  case callAndMessage
  case headerSpace
  case shortname
  case about
  case infoSpace
  case notifications
  case inviteLink
  case integrationLink
  case permissions
  case files
  case settingsSpace
  case addToFavourites
  case favouritesSpace
  case membersCount
  case memberInvite
  case membersShowAll
  case leave
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public class GroupProfileHeaderCellViewModel : Dialog_iOS.ProfileCellViewModel, Dialog_iOS.ProfileHeaderCellViewModelProtocol {
  public var userAvatarBasicColor: RxCocoa.Driver<UIKit.UIColor>
  final public let avatarCenterText: RxSwift.Observable<Swift.String?>
  final public let avatarImage: RxSwift.Observable<UIKit.UIImage?>
  public var avatarNodeDidTapped: RxRelay.PublishRelay<Swift.Void>
  public var title: RxCocoa.Driver<Swift.String>
  required public init(type: Swift.Int, group: DialogProtocols.DialogGroup, eventBusService: DialogProtocols.EventBusServiceProtocol, fileService: DialogFiles.DialogFileServiceProtocol, colorService: Dialog_iOS.DialogPeerColorsServiceProtocol, themeService: Dialog_iOS.AppThemeService)
  @objc deinit
  override public init(type: Swift.Int, themeService: Dialog_iOS.AppThemeService)
}
public protocol GroupProfileMemberCellDesignProtocol : Dialog_iOS.AvatarNodeStyleProtocol, Dialog_iOS.ProfileCellStyleProtocol {
  var backgroundColor: UIKit.UIColor { get }
  var nameAttributes: [Foundation.NSAttributedString.Key : Any] { get }
  var statusAttributes: [Foundation.NSAttributedString.Key : Any] { get }
  var adminAttributes: [Foundation.NSAttributedString.Key : Any] { get }
  var kickAttributes: [Foundation.NSAttributedString.Key : Any] { get }
  var avatarSize: CoreGraphics.CGSize { get }
  var contentInsets: UIKit.UIEdgeInsets { get }
  var spacing: CoreGraphics.CGFloat { get }
}
public struct GroupProfileMemberCellDefaultDesign : Dialog_iOS.GroupProfileMemberCellDesignProtocol {
  public let backgroundColor: UIKit.UIColor
  public let nameAttributes: [Foundation.NSAttributedString.Key : Any]
  public let statusAttributes: [Foundation.NSAttributedString.Key : Any]
  public let adminAttributes: [Foundation.NSAttributedString.Key : Any]
  public let kickAttributes: [Foundation.NSAttributedString.Key : Any]
  public let avatarSize: CoreGraphics.CGSize
  public let contentInsets: UIKit.UIEdgeInsets
  public let spacing: CoreGraphics.CGFloat
  public var separatorInsets: UIKit.UIEdgeInsets {
    get
  }
}
@objc public class GroupProfileMemberCell : AsyncDisplayKit.ASCellNode {
  final public let viewModel: Dialog_iOS.GroupProfileMemberCellViewModelProtocol
  final public let cellStyle: Dialog_iOS.GroupProfileMemberCellDesignProtocol
  final public let avatarNode: Dialog_iOS.AvatarNode
  final public let nameNode: AsyncDisplayKit.ASTextNode
  final public let statusNode: AsyncDisplayKit.ASTextNode
  final public let adminNode: AsyncDisplayKit.ASTextNode
  final public let kickNode: AsyncDisplayKit.ASButtonNode
  public init(viewModel: Dialog_iOS.GroupProfileMemberCellViewModelProtocol, style: Dialog_iOS.GroupProfileMemberCellDesignProtocol)
  @objc override dynamic public func didLoad()
  @objc override dynamic public func layoutSpecThatFits(_ constrainedSize: AsyncDisplayKit.ASSizeRange) -> AsyncDisplayKit.ASLayoutSpec
  @objc deinit
  @objc override dynamic public init(viewControllerBlock: @escaping AsyncDisplayKit.ASDisplayNodeViewControllerBlock, didLoad didLoadBlock: AsyncDisplayKit.ASDisplayNodeDidLoadBlock? = nil)
  @objc override dynamic public init()
}
public protocol GroupProfileMemberCellViewModelProtocol : Dialog_iOS.AvatarNodeModelProtocol, Dialog_iOS.ProfileCellViewModelProtocol, Dialog_iOS.ViewModelProtocol {
  var name: RxCocoa.Driver<Swift.String> { get }
  var isAdmin: RxCocoa.Driver<Swift.Bool> { get }
  var showKickButton: RxCocoa.Driver<Swift.Bool> { get }
  var kickButtonTitle: RxCocoa.Driver<Swift.String> { get }
  var kickButtonAction: RxSwift.AnyObserver<Swift.Void> { get }
}
public class GroupProfileMemberCellViewModel : Dialog_iOS.ProfileCellViewModel, Dialog_iOS.GroupProfileMemberCellViewModelProtocol {
  public var userAvatarBasicColor: RxCocoa.Driver<UIKit.UIColor>
  final public let avatarCenterText: RxSwift.Observable<Swift.String?>
  final public let avatarImage: RxSwift.Observable<UIKit.UIImage?>
  public var avatarNodeDidTapped: RxRelay.PublishRelay<Swift.Void>
  final public let name: RxCocoa.Driver<Swift.String>
  final public let isAdmin: RxCocoa.Driver<Swift.Bool>
  final public let showKickButton: RxCocoa.Driver<Swift.Bool>
  final public let kickButtonTitle: RxCocoa.Driver<Swift.String>
  final public let kickButtonAction: RxSwift.AnyObserver<Swift.Void>
  required public init(myId: DialogProtocols.DialogUserId, member: DialogProtocols.DialogGroupMember, allowEditing: RxCocoa.Driver<Swift.Bool>, kickAction: RxSwift.AnyObserver<DialogProtocols.DialogUser>, eventBusService: DialogProtocols.EventBusServiceProtocol, fileService: DialogFiles.DialogFileServiceProtocol, userPresenceStateService: DialogProtocols.UserPresenceStateServiceProtocol, colorService: Dialog_iOS.DialogPeerColorsServiceProtocol, themeService: Dialog_iOS.AppThemeService)
  @objc deinit
  override public init(type: Swift.Int, themeService: Dialog_iOS.AppThemeService)
}
public struct GroupProfileMemberInviteCellDefaultStyle : Dialog_iOS.ProfileActionCellStyleProtocol {
  public let insets: UIKit.UIEdgeInsets
  public var titleAttributesText: [Foundation.NSAttributedString.Key : Any]?
  public let spacing: CoreGraphics.CGFloat
  public let iconSize: CoreGraphics.CGSize
  public var separatorInsets: UIKit.UIEdgeInsets {
    get
  }
}
public protocol GroupProfileMemberInviteCellViewModelProtocol : Dialog_iOS.ProfileActionCellViewModelProtocol {
}
public struct GroupProfileMembersAllCellDefaultStyle : Dialog_iOS.ProfileActionCellStyleProtocol {
  public let insets: UIKit.UIEdgeInsets
  public var titleAttributesText: [Foundation.NSAttributedString.Key : Any]?
  public var separatorInsets: UIKit.UIEdgeInsets {
    get
  }
}
public protocol GroupProfileMembersAllCellViewModelProtocol : Dialog_iOS.ProfileActionCellViewModelProtocol {
}
public struct GroupProfileSceneArgument {
  public let id: DialogProtocols.DialogGroupId
  public var initialGroup: DialogProtocols.DialogGroup?
  public init(id: DialogProtocols.DialogGroupId)
  public init(group: DialogProtocols.DialogGroup)
}
@_inheritsConvenienceInitializers final public class GroupProfileScene : Dialog_iOS.Scene<Dialog_iOS.GroupProfileSceneArgument, UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.GroupProfileScene.Builder
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<Dialog_iOS.GroupProfileScene.Argument.MainArgument, UIKit.UIViewController, Dialog_iOS.BaseGroupProfileViewModelProtocol> {
    override final public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Dialog_iOS.GroupProfileScene.DefaultBuilder.Arg.MainArgument>) -> Dialog_iOS.BaseGroupProfileViewModelProtocol
    override final public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Dialog_iOS.GroupProfileScene.Argument.MainArgument>, viewModel: Dialog_iOS.BaseGroupProfileViewModelProtocol) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<Dialog_iOS.GroupProfileSceneArgument, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
public protocol GroupProfileTitleCellStyleProtocol : Dialog_iOS.DUICellStyleProtocol {
}
public struct GroupProfileTitleDefaultCellStyle : Dialog_iOS.GroupProfileTitleCellStyleProtocol {
  public var separatorInsets: UIKit.UIEdgeInsets {
    get
  }
  public let backgroundColor: UIKit.UIColor
}
public protocol GroupProfileTitleCellViewModelProtocol : Dialog_iOS.DUICellViewModelProtocol {
  var groupName: RxCocoa.Driver<Swift.String> { get }
  var creatorText: RxCocoa.Driver<Swift.String> { get }
}
public class GroupProfileTitleCellViewModel : Dialog_iOS.DUICellViewModel, Dialog_iOS.GroupProfileTitleCellViewModelProtocol {
  final public let groupName: RxCocoa.Driver<Swift.String>
  final public let creatorText: RxCocoa.Driver<Swift.String>
  public init()
  @objc deinit
  override public init(identity: Dialog_iOS.DUICellViewModelIdentity)
}
public protocol GroupRepresentableViewController {
}
public enum GroupsOfNotificationSetting : Swift.CaseIterable, Swift.Equatable {
  case notifications
  case groupNotifications
  case privacy
  case badge
  public var settings: [DialogProtocols.DialogNotificationSetting] {
    get
  }
  public var title: Swift.String {
    get
  }
  public var footer: Swift.String? {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [Dialog_iOS.GroupsOfNotificationSetting]
  public static var allCases: [Dialog_iOS.GroupsOfNotificationSetting] {
    get
  }
  public static func == (a: Dialog_iOS.GroupsOfNotificationSetting, b: Dialog_iOS.GroupsOfNotificationSetting) -> Swift.Bool
}
extension DialogNotificationSetting : Swift.Comparable {
  public static func < (lhs: DialogProtocols.DialogNotificationSetting, rhs: DialogProtocols.DialogNotificationSetting) -> Swift.Bool
}
public typealias HomeRouter = XCoordinator.WeakRouter<Dialog_iOS.HomeRoute>
public typealias AnyHomeCoordinator = Dialog_iOS.HomeCoordinator.AnyCoordinatorType
public enum HomeRoute : XCoordinator.Route {
  case dialogs
  case discover
  case settings
  case logout
  case onboarding
  case cancelOnboarding
  case dismiss
  case contacts
  case passcode
  case errorAlert(title: Swift.String?, message: Swift.String?)
  case openChat(dialog: DialogProtocols.DialogState, unreadState: DialogProtocols.DialogUnreadCountState?, messageId: DialogProtocols.DialogUUID?)
  case whatsNew
  case openUserProfile(DialogProtocols.DialogUser)
  case avatarPreview(Dialog_iOS.AvatarPreviewItem)
  case miniApp(Foundation.URL)
  case newType(Dialog_iOS.GlobalAppRoute.AuthedUser.Route)
}
open class HomeCoordinator : XCoordinator.TabBarCoordinator<Dialog_iOS.HomeRoute> {
  final public let container: Swinject.Container
  final public let dialogsCoordinator: Dialog_iOS.AnyDialogsCoordinator
  public var discoverCoordinator: Dialog_iOS.AnyDiscoverCoordinator?
  final public let generalSettingsCoordinator: Dialog_iOS.AnyGeneralSettingsCoordinator
  public var contactsCoordinator: Dialog_iOS.AnyContactsCoordinator?
  public var callsHistoryCoordinator: Dialog_iOS.AnyCallsHistoryCoordinator?
  public init(rootViewController: UIKit.UITabBarController, container: Swinject.Container)
  override open func prepareTransition(for route: Dialog_iOS.HomeRoute) -> XCoordinator.TabBarTransition
  override public init(rootViewController: XCoordinator.TabBarCoordinator<Dialog_iOS.HomeRoute>.RootViewController = super, initialRoute: Dialog_iOS.HomeRoute?)
  override public init(rootViewController: XCoordinator.TabBarCoordinator<Dialog_iOS.HomeRoute>.RootViewController = super, tabs: [XCoordinator.Presentable])
  override public init(rootViewController: XCoordinator.TabBarCoordinator<Dialog_iOS.HomeRoute>.RootViewController = super, tabs: [XCoordinator.Presentable], select: XCoordinator.Presentable)
  override public init(rootViewController: XCoordinator.TabBarCoordinator<Dialog_iOS.HomeRoute>.RootViewController = super, tabs: [XCoordinator.Presentable], select: Swift.Int)
  @objc deinit
}
public enum HomeEmbeddingRoute : XCoordinator.Route {
  case initial
  case presentActiveCall
  case dismissActiveCall(animated: Swift.Bool)
  case general(Dialog_iOS.GlobalAppRoute.AuthedUser.Route)
}
public typealias HomeEmbeddingTransition = XCoordinator.Transition<Dialog_iOS.HomeEmbeddingViewController>
public typealias HomeEmbeddingRouter = XCoordinator.WeakRouter<Dialog_iOS.HomeEmbeddingRoute>
public typealias AnyHomeEmbeddingCoordinator = Dialog_iOS.HomeEmbeddingCoordinator.AnyCoordinatorType
final public class HomeEmbeddingCoordinator : XCoordinator.BaseCoordinator<Dialog_iOS.HomeEmbeddingRoute, Dialog_iOS.HomeEmbeddingTransition> {
  final public let container: Swinject.Container
  final public let homeCoordinator: Dialog_iOS.AnyHomeCoordinator
  public static let dismissActiveCallNotificationName: Foundation.Notification.Name
  public static let presentActiveCallNotificationName: Foundation.Notification.Name
  public static let instantDismissActiveCallNotificationName: Foundation.Notification.Name
  public static let userDidDismissActiveCallNotificationName: Foundation.Notification.Name
  public init(container: Swinject.Container)
  override final public func prepareTransition(for route: Dialog_iOS.HomeEmbeddingRoute) -> Dialog_iOS.HomeEmbeddingTransition
  override public init(rootViewController: XCoordinator.BaseCoordinator<Dialog_iOS.HomeEmbeddingRoute, Dialog_iOS.HomeEmbeddingTransition>.RootViewController, initialRoute: Dialog_iOS.HomeEmbeddingRoute?)
  override public init(rootViewController: XCoordinator.BaseCoordinator<Dialog_iOS.HomeEmbeddingRoute, Dialog_iOS.HomeEmbeddingTransition>.RootViewController, initialTransition: Dialog_iOS.HomeEmbeddingTransition?)
  @objc deinit
}
public protocol HomeEmbeddingViewControllerDesignProtocol {
  var topContainerSafeAreaIgnorantHeight: CoreGraphics.CGFloat { get }
  var showOrHideAnimationDuration: Foundation.TimeInterval { get }
  var backgroundColor: UIKit.UIColor { get }
}
public struct HomeEmbeddingViewControllerDefaultStyle : Dialog_iOS.HomeEmbeddingViewControllerDesignProtocol {
  public let topContainerSafeAreaIgnorantHeight: CoreGraphics.CGFloat
  public let showOrHideAnimationDuration: Swift.Double
  public let backgroundColor: UIKit.UIColor
}
public protocol HomeEmbeddingViewControllerProtocol : AnyObject {
  var topContainer: UIKit.UIViewController { get }
  var bottomContainer: UIKit.UIViewController { get }
  var setTopContainerHidden: RxSwift.AnyObserver<Swift.Bool> { get }
  var isTopContainerHidden: RxSwift.Observable<Swift.Bool> { get }
}
@objc public class HomeEmbeddingViewController : UIKit.UIViewController, Dialog_iOS.HomeEmbeddingViewControllerProtocol {
  final public let topContainer: UIKit.UIViewController
  final public let bottomContainer: UIKit.UIViewController
  public var setTopContainerHidden: RxSwift.AnyObserver<Swift.Bool> {
    get
  }
  public var isTopContainerHidden: RxSwift.Observable<Swift.Bool> {
    get
    set
  }
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  public init(design: Dialog_iOS.HomeEmbeddingViewControllerDesignProtocol, isTopContainerHidden: Swift.Bool)
  @objc override dynamic public var preferredStatusBarStyle: UIKit.UIStatusBarStyle {
    @objc get
  }
  @objc override dynamic public func viewDidLoad()
  @objc override dynamic public func viewWillTransition(to size: CoreGraphics.CGSize, with coordinator: UIKit.UIViewControllerTransitionCoordinator)
  @objc override dynamic public func viewDidLayoutSubviews()
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc deinit
}
extension Reactive where Base : Dialog_iOS.HomeEmbeddingViewController {
  public var topContainerHidden: RxCocoa.Binder<Swift.Bool> {
    get
  }
}
public protocol Identifiable {
  static var identifier: Swift.String { get }
}
extension Identifiable {
  public static var identifier: Swift.String {
    get
  }
}
extension UITableViewHeaderFooterView : Dialog_iOS.Identifiable {
}
public struct IGScreen {
}
public struct IGTheme {
}
public enum IGError : Swift.Error, Swift.CustomStringConvertible {
  case invalidImageURL
  case downloadError
  public var description: Swift.String {
    get
  }
  public static func == (a: Dialog_iOS.IGError, b: Dialog_iOS.IGError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol IGHomeViewModelProtocol {
  var previewViewModel: Dialog_iOS.IGStoryPreviewModel { get }
  var themeColor: RxRelay.BehaviorRelay<UIKit.UIColor> { get }
  func getStories() -> Dialog_iOS.IGStories?
  func numberOfItemsInSection(_ section: Swift.Int) -> Swift.Int
  func cellForItemAt(indexPath: Foundation.IndexPath) -> Dialog_iOS.IGStory?
}
public typealias ImageResponse = (Dialog_iOS.IGResult<UIKit.UIImage, Swift.Error>) -> Swift.Void
public enum IGResult<V, E> {
  case success(V)
  case failure(E)
}
@objc @_inheritsConvenienceInitializers public class IGRetryLoaderButton : UIKit.UIButton {
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public enum MimeType : Swift.String {
  case image
  case video
  case unknown
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public class IGSnap : Swift.Codable {
  final public let internalIdentifier: Swift.String
  final public let mimeType: Swift.String
  final public let lastUpdated: Swift.String
  final public let url: Swift.String
  public var kind: Dialog_iOS.MimeType {
    get
  }
  @objc deinit
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@_hasMissingDesignatedInitializers public class IGStories : Swift.Codable {
  final public let count: Swift.Int
  final public let stories: [Dialog_iOS.IGStory]
  public static let zero: Dialog_iOS.IGStories
  required public init(from decoder: Swift.Decoder) throws
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
}
public class IGStory : Swift.Codable {
  public var snapsCount: Swift.Int
  public var snaps: [Dialog_iOS.IGSnap]
  public var internalIdentifier: Swift.String
  public var lastUpdated: Swift.Int
  public var user: Dialog_iOS.IGUser
  @objc deinit
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension IGStory : Swift.Equatable {
  public static func == (lhs: Dialog_iOS.IGStory, rhs: Dialog_iOS.IGStory) -> Swift.Bool
}
public let progressIndicatorViewTag: Swift.Int
public let progressViewTag: Swift.Int
@objc @_hasMissingDesignatedInitializers public class IGStoryPreviewModel : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
}
public enum IGLayoutType {
  case cubic
  public static func == (a: Dialog_iOS.IGLayoutType, b: Dialog_iOS.IGLayoutType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public class IGUser : Swift.Codable {
  final public let internalIdentifier: Swift.String
  final public let name: Swift.String
  final public let picture: Swift.String
  @objc deinit
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public protocol ImageAndTitleCellViewModelProtocol : Dialog_iOS.GeneralSettingsCellViewModelProtocol {
  var title: Swift.String { get }
  var titleColor: UIKit.UIColor { get }
  var image: UIKit.UIImage? { get }
  var textAlignment: UIKit.NSTextAlignment { get }
  var accessoryType: UIKit.UITableViewCell.AccessoryType { get }
  var titleFont: UIKit.UIFont { get }
}
public class ImageAndTitleCellViewModel : Dialog_iOS.ImageAndTitleCellViewModelProtocol {
  final public let title: Swift.String
  public var textAlignment: UIKit.NSTextAlignment
  final public let titleColor: UIKit.UIColor
  final public let image: UIKit.UIImage?
  final public let accessoryType: UIKit.UITableViewCell.AccessoryType
  final public let route: Dialog_iOS.GeneralSettingsRoute
  public var titleFont: UIKit.UIFont {
    get
  }
  required public init(title: Swift.String, textAlignment: UIKit.NSTextAlignment = .left, titleColor: UIKit.UIColor = UIColor.compatibleDarkTextColor, image: UIKit.UIImage? = nil, tintColor: UIKit.UIColor? = nil, accessoryType: UIKit.UITableViewCell.AccessoryType = .disclosureIndicator, route: Dialog_iOS.GeneralSettingsRoute)
  @objc deinit
}
extension IndexPath {
  public func isEquatToFirst(in sections: [Dialog_iOS.MessagesListSection]) -> Swift.Bool
  public func isEquatToLast(in sections: [Dialog_iOS.MessagesListSection]) -> Swift.Bool
}
public enum InfoMessage : Swift.Equatable {
  case none
  case hide
  case info(Swift.String)
  case error(Swift.String)
  public static func == (a: Dialog_iOS.InfoMessage, b: Dialog_iOS.InfoMessage) -> Swift.Bool
}
@_hasMissingDesignatedInitializers public class InfoMessagePresenter {
  @objc deinit
}
public protocol InfoMessageViewModelProtocol {
  var infoMessageOut: RxCocoa.Driver<Dialog_iOS.InfoMessage> { get }
  var infoMessageIn: RxSwift.AnyObserver<(Dialog_iOS.InfoMessage, RxSwift.RxTimeInterval)> { get }
}
@_hasMissingDesignatedInitializers final public class InputBarAccessoryWithAttachmentView : InputBarAccessoryView.InputBarAccessoryView {
  final public let attachButton: InputBarAccessoryView.InputBarButtonItem
  final public let stickerButton: InputBarAccessoryView.InputBarButtonItem
  final public let micButton: InputBarAccessoryView.InputBarButtonItem
  final public let cameraButton: InputBarAccessoryView.InputBarButtonItem
  final public let expandButton: InputBarAccessoryView.InputBarButtonItem
  final public var isWarning: Swift.Bool {
    get
    set
  }
  final public var warningText: Swift.String? {
    get
    set
  }
  final public var isEnabled: Swift.Bool {
    get
    set
  }
  final public var attachmentView: Dialog_iOS.InputBarAttachView
  override final public var isTranslucent: Swift.Bool {
    get
    set
  }
  final public var isAttachmentShown: RxSwift.AnyObserver<DialogProtocols.MessageAttachType?>
  final public var audioCanBeEnabled: RxSwift.AnyObserver<Swift.Bool> {
    get
    set
  }
  final public var isShowAutocompleteView: Swift.Bool {
    get
    set
  }
  public init(themeService: Dialog_iOS.AppThemeService, featureFlagsService: DialogProtocols.DialogFeatureFlagsServiceProtocol, callsService: DialogCalls.CallsServiceProtocol)
  @objc override final public func traitCollectionDidChange(_ previousTraitCollection: UIKit.UITraitCollection?)
  @objc override final public func inputTextViewDidChange()
  @objc override final public func didMoveToSuperview()
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
}
public protocol InputBarAttachViewModel : AnyObject {
  var didTapAttachDismiss: RxSwift.AnyObserver<Swift.Void> { get }
  var didTapAttachContent: RxSwift.AnyObserver<Swift.Void> { get }
  var isAttachShown: RxSwift.Observable<DialogProtocols.MessageAttachType?> { get }
  var attachmentAuthorName: RxCocoa.Driver<Swift.String?> { get }
  var attachmentText: RxCocoa.Driver<Swift.String?> { get }
  var attachmentFastThumb: RxSwift.Observable<DialogProtocols.DialogFastThumb?> { get }
  var attachmentHasFileError: RxCocoa.Driver<Swift.Bool> { get }
  var controlColor: RxCocoa.Driver<UIKit.UIColor> { get }
}
@objc @_hasMissingDesignatedInitializers public class InputBarAttachView : UIKit.UIView {
  public var attachmentAuthorsLabel: UIKit.UILabel {
    get
    set
  }
  public var attachmentDescriptionLabel: UIKit.UILabel {
    get
    set
  }
  public var dismissButton: UIKit.UIButton {
    get
    set
  }
  public var lineView: UIKit.UIView {
    get
    set
  }
  public var thumbnailView: UIKit.UIImageView {
    get
    set
  }
  public var thumbnailBlurView: UIKit.UIVisualEffectView {
    get
    set
  }
  public var thumbnailErrorView: UIKit.UIImageView {
    get
    set
  }
  public var attachTapButton: UIKit.UIButton {
    get
    set
  }
  public var thumbnailWrapperView: UIKit.UIView {
    get
    set
  }
  public var blurView: UIKit.UIVisualEffectView {
    get
    set
  }
  public var isTranslucent: Swift.Bool {
    get
    set
  }
  public init(design: Dialog_iOS.InputBarAttachViewDesign)
  public func bind(viewModel: Dialog_iOS.InputBarAttachViewModel)
  @objc override dynamic public func layoutSubviews()
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
public protocol InputBarAttachViewDesign {
  var paddings: UIKit.UIEdgeInsets { get }
  var textLeftSpacing: CoreGraphics.CGFloat { get }
  var thumbnailLeftSpacing: CoreGraphics.CGFloat { get }
  var dismissLeftSpacing: CoreGraphics.CGFloat { get }
  var authorToTextSpacing: CoreGraphics.CGFloat { get }
  var textToBottomSpacing: CoreGraphics.CGFloat { get }
  var lineWidth: CoreGraphics.CGFloat { get }
  var lineColor: UIKit.UIColor { get }
  var backgroundColor: UIKit.UIColor { get }
  var authorFont: UIKit.UIFont { get }
  var authorDefaultColor: UIKit.UIColor { get }
  var textFont: UIKit.UIFont { get }
  var textColor: UIKit.UIColor { get }
  var dismissIconName: Swift.String { get }
  var dismissIconColor: UIKit.UIColor { get }
  var dismissButtonBackgroundColor: UIKit.UIColor { get }
  var dismissButtonBorderWidth: CoreGraphics.CGFloat { get }
  var dismissButtonBorderColor: UIKit.UIColor { get }
  var dismissButtonCornerType: Dialog_iOS.CornerRadiusType { get }
  var dismissButtonSize: CoreGraphics.CGSize { get }
  var thumbnailCornerType: Dialog_iOS.CornerRadiusType { get }
  var thumbnailErrorIconSize: CoreGraphics.CGSize { get }
  var contentMaxHeight: CoreGraphics.CGFloat { get }
}
@_hasMissingDesignatedInitializers public class InputBarAttachmentMessageViewDefaultStyle : Dialog_iOS.InputBarAttachViewDesign {
  final public let paddings: UIKit.UIEdgeInsets
  final public let textLeftSpacing: CoreGraphics.CGFloat
  final public let lineToPreviewSpacing: CoreGraphics.CGFloat
  final public let thumbnailLeftSpacing: CoreGraphics.CGFloat
  final public let dismissLeftSpacing: CoreGraphics.CGFloat
  final public let authorToTextSpacing: CoreGraphics.CGFloat
  final public let textToBottomSpacing: CoreGraphics.CGFloat
  final public let lineWidth: CoreGraphics.CGFloat
  final public let lineColor: UIKit.UIColor
  final public let backgroundColor: UIKit.UIColor
  final public let authorFont: UIKit.UIFont
  final public let authorDefaultColor: UIKit.UIColor
  final public let textFont: UIKit.UIFont
  final public let textColor: UIKit.UIColor
  final public let dismissIconName: Swift.String
  final public let dismissIconColor: UIKit.UIColor
  final public let dismissButtonBackgroundColor: UIKit.UIColor
  final public let dismissButtonBorderWidth: CoreGraphics.CGFloat
  final public let dismissButtonBorderColor: UIKit.UIColor
  final public let dismissButtonCornerType: Dialog_iOS.CornerRadiusType
  final public let dismissButtonSize: CoreGraphics.CGSize
  final public let thumbnailCornerType: DialogSharedComponents.CornerRadiusType
  final public let thumbnailErrorIconSize: CoreGraphics.CGSize
  final public let contentMaxHeight: CoreGraphics.CGFloat
  @objc deinit
}
@objc @_inheritsConvenienceInitializers final public class InputBarJoinView : UIKit.UIView {
  final public var button: UIKit.UIButton {
    get
    set
  }
  final public var spinner: UIKit.UIActivityIndicatorView {
    get
    set
  }
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc override final public func layoutSubviews()
  final public func bind(viewModel: Dialog_iOS.ConversationJoinPanelViewModelProtocol)
  final public func unbind()
  @objc deinit
}
public protocol InputBarSelectionViewDesign {
  var buttonWidth: CoreGraphics.CGFloat { get }
  var contentInsets: UIKit.UIEdgeInsets { get }
  var forwardButtonImage: UIKit.UIImage { get }
  var deleteButtonImage: UIKit.UIImage { get }
  var backgroundColor: UIKit.UIColor { get }
}
@_hasMissingDesignatedInitializers open class InputBarSelectionViewDesignDefault : Dialog_iOS.InputBarSelectionViewDesign {
  public var buttonWidth: CoreGraphics.CGFloat
  public var contentInsets: UIKit.UIEdgeInsets
  public var forwardButtonImage: UIKit.UIImage
  public var deleteButtonImage: UIKit.UIImage
  public var backgroundColor: UIKit.UIColor
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers final public class InputBarSelectionView : UIKit.UIView {
  final public var design: RxSwift.AnyObserver<Dialog_iOS.InputBarSelectionViewDesign> {
    get
  }
  @objc dynamic public init()
  final public func bind(viewModel: Dialog_iOS.MessageInputSelectionPanelViewModelProtocol)
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
}
extension Theme.Domain {
  public static let inputBar: Dialog_iOS.Theme.Domain
}
extension Theme.Keys.InputBar {
  public static let separatorAutocomplete: Dialog_iOS.Theme.Keys.InputBar
  public static let autocompleteCellMentionTextColor: Dialog_iOS.Theme.Keys.InputBar
  public static let autocompleteCellUsernameFont: Dialog_iOS.Theme.Keys.InputBar
}
extension Theme.Defaults {
  public static let inputBar: DialogSharedComponents.Subtheme<Dialog_iOS.Theme.Keys.InputBar>
}
extension Theme.Keys {
  public struct InputBar : Dialog_iOS.DomainSpecificKey, Swift.RawRepresentable {
    public static var domain: Dialog_iOS.Theme.Domain
    public var domainInternalId: Swift.String {
      get
    }
    public let rawValue: Swift.String
    public init(rawValue: Swift.String)
    public typealias RawValue = Swift.String
  }
}
extension Int64 {
  public func makeUniqPair(with y: Swift.Int64) -> Swift.Int64
}
public enum TimeUnit {
  case seconds(Swift.Int64)
  case milliseconds(Swift.Int64)
}
public protocol InteractiveMediaGroupViewModelProtocol {
  var actionViewModels: [Dialog_iOS.InteractiveMediaViewModel] { get }
  var title: Swift.String? { get }
  var description: Swift.String? { get }
  func isEqual(_ other: Dialog_iOS.InteractiveMediaGroupViewModelProtocol?) -> Swift.Bool
}
extension InteractiveMediaGroupViewModelProtocol where Self : Swift.Equatable {
  public func isEqual(_ other: Dialog_iOS.InteractiveMediaGroupViewModelProtocol?) -> Swift.Bool
}
public struct InteractiveMediaGroupViewModel : Dialog_iOS.InteractiveMediaGroupViewModelProtocol {
  public let interactiveMediaGroup: DialogMessaging.DialogInteractiveMediaGroup
  public let actionViewModels: [Dialog_iOS.InteractiveMediaViewModel]
  public var title: Swift.String? {
    get
  }
  public var description: Swift.String? {
    get
  }
}
extension InteractiveMediaGroupViewModel : Swift.Equatable {
  public static func == (lhs: Dialog_iOS.InteractiveMediaGroupViewModel, rhs: Dialog_iOS.InteractiveMediaGroupViewModel) -> Swift.Bool
}
public protocol InteractiveMediaViewModelProtocol : Dialog_iOS.MessageContentViewModelDeferredSubscribeProtocol {
  var title: RxSwift.Observable<Swift.String> { get }
  var style: DialogMessaging.DialogInteractiveMediaStyle { get }
  var widget: DialogMessaging.DialogInteractiveMediaWidget? { get }
  var didTapMedia: RxSwift.AnyObserver<Swift.Void> { get }
  var performAction: RxSwift.Observable<Dialog_iOS.InteractiveMediaAction> { get }
  var isPerforming: RxCocoa.Driver<Swift.Bool> { get }
}
public struct InteractiveMediaSelectData {
}
public enum InteractiveMediaAction {
  case send(request: DialogProtocols.DialogMediaActionRequest, confirm: DialogMessaging.DialogInteractiveMediaConfirm?)
  case select(data: Dialog_iOS.InteractiveMediaSelectData, confirm: DialogMessaging.DialogInteractiveMediaConfirm?)
}
public struct InteractiveMediaViewModel : Dialog_iOS.InteractiveMediaViewModelProtocol {
  public let title: RxSwift.Observable<Swift.String>
  public let didTapMedia: RxSwift.AnyObserver<Swift.Void>
  public let performAction: RxSwift.Observable<Dialog_iOS.InteractiveMediaAction>
  public let isPerforming: RxCocoa.Driver<Swift.Bool>
  public var style: DialogMessaging.DialogInteractiveMediaStyle {
    get
  }
  public var widget: DialogMessaging.DialogInteractiveMediaWidget? {
    get
  }
  public func subscribe()
}
@_hasMissingDesignatedInitializers public class InteractiveMediaNodeDefaultStyle {
  @objc deinit
}
@_inheritsConvenienceInitializers final public class InviteUsersToGroupScene : Dialog_iOS.Scene<DialogProtocols.DialogGroupId, UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.InviteUsersToGroupScene.Builder
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<DialogProtocols.DialogGroupId, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
@_inheritsConvenienceInitializers final public class InviteUsersToNewGroupScene : Dialog_iOS.Scene<DialogProtocols.DialogGroupId, UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.InviteUsersToNewGroupScene.Builder
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<DialogProtocols.DialogGroupId, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
public struct InviteUsersSection {
  public typealias Item = Dialog_iOS.DUIInviteUserCellViewModel
  public let items: [Dialog_iOS.InviteUsersSection.Item]
  public init(items: [Dialog_iOS.InviteUsersSection.Item])
}
extension InviteUsersSection : Differentiator.AnimatableSectionModelType {
  public typealias Identity = Swift.Int
  public var identity: Swift.Int {
    get
  }
  public init(original: Dialog_iOS.InviteUsersSection, items: [Dialog_iOS.InviteUsersSection.Item])
}
public protocol InviteUsersViewModelProtocol : Dialog_iOS.ViewModelProtocol {
  var headerViewModel: Dialog_iOS.UserSectionHeaderViewModelProtocol { get }
  var hasBackButton: Swift.Bool { get }
  var userSelectAction: RxSwift.AnyObserver<DialogProtocols.DialogUser> { get }
  var searchText: RxSwift.AnyObserver<Swift.String?> { get }
  var proceed: RxSwift.AnyObserver<Swift.Void> { get }
  var cancel: RxSwift.AnyObserver<Swift.Void> { get }
  var inviteButtonEnabled: RxCocoa.Driver<Swift.Bool> { get }
  var saveButtonTitle: RxCocoa.Driver<Swift.String> { get }
  var title: RxCocoa.Driver<Dialog_iOS.DUINavigationTitleModel> { get }
  var sections: RxCocoa.Driver<[Dialog_iOS.InviteUsersSection]> { get }
  var error: RxCocoa.Driver<Swift.Error> { get }
  var allowsSelection: RxCocoa.Driver<Swift.Bool> { get }
  var progress: RxCocoa.Driver<Swift.Double?> { get }
}
public struct InviteUsersViewModelDependencies {
}
@_hasMissingDesignatedInitializers public class BaseInviteUsersViewModel : Dialog_iOS.InviteUsersViewModelProtocol {
  final public let headerViewModel: Dialog_iOS.UserSectionHeaderViewModelProtocol
  final public let userSelectAction: RxSwift.AnyObserver<DialogProtocols.DialogUser>
  final public let searchText: RxSwift.AnyObserver<Swift.String?>
  final public let proceed: RxSwift.AnyObserver<Swift.Void>
  public var cancel: RxSwift.AnyObserver<Swift.Void>
  public var inviteButtonEnabled: RxCocoa.Driver<Swift.Bool>
  final public let title: RxCocoa.Driver<Dialog_iOS.DUINavigationTitleModel>
  public var saveButtonTitle: RxCocoa.Driver<Swift.String>
  final public let sections: RxCocoa.Driver<[Dialog_iOS.InviteUsersSection]>
  final public let error: RxCocoa.Driver<Swift.Error>
  public var allowsSelection: RxCocoa.Driver<Swift.Bool>
  public var progress: RxCocoa.Driver<Swift.Double?>
  final public let disabledUsers: RxSwift.AnyObserver<[DialogProtocols.DialogUser]>
  public var hasBackButton: Swift.Bool
  @objc deinit
}
@_hasMissingDesignatedInitializers public class InviteUsersToNewGroupViewModel : Dialog_iOS.BaseInviteUsersViewModel {
  public init(myId: DialogProtocols.DialogUserId, groupId: DialogProtocols.DialogGroupId, dependencies: Dialog_iOS.InviteUsersViewModelDependencies)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class InviteUsersToGroupViewModel : Dialog_iOS.BaseInviteUsersViewModel {
  public init(myId: DialogProtocols.DialogUserId, groupId: DialogProtocols.DialogGroupId, dependencies: Dialog_iOS.InviteUsersViewModelDependencies)
  @objc deinit
}
@objc final public class JoinButtonNode : AsyncDisplayKit.ASButtonNode {
  final public var highlightColor: UIKit.UIColor?
  final public var enabledColor: UIKit.UIColor?
  final public var disabledColor: UIKit.UIColor?
  final public let title: Swift.String
  final public let font: UIKit.UIFont
  public init(title: Swift.String, font: UIKit.UIFont)
  @objc override final public var isHighlighted: Swift.Bool {
    @objc get
    @objc set
  }
  @objc deinit
  @objc override dynamic public init()
}
extension Reactive where Base : Dialog_iOS.JoinButtonNode {
  public var isEnabledWithColorChange: RxCocoa_Texture.ASBinder<Swift.Bool> {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class LabelRxConfigurator<Label> : Dialog_iOS.ViewRxConfigurator<Label> where Label : UIKit.UILabel {
  final public var text: RxSwift.AnyObserver<Swift.String?> {
    get
  }
  final public var textColor: RxSwift.AnyObserver<UIKit.UIColor?> {
    get
  }
  final public var numberOfLines: RxSwift.AnyObserver<Swift.Int> {
    get
  }
  override final public func createBindings(to: Label) -> [RxSwift.Disposable]
  @objc deinit
}
public protocol LayoutAttributesAnimator {
  func animate(collectionView: UIKit.UICollectionView, attributes: Dialog_iOS.AnimatedCollectionViewLayoutAttributes)
}
public enum LeaveGroupError : Swift.Error {
  case cancel
  public static func == (a: Dialog_iOS.LeaveGroupError, b: Dialog_iOS.LeaveGroupError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol LeaveGroupProtocol {
  var confirmLeave: RxSwift.AnyObserver<Swift.Void> { get }
  var requestOwnerLeaveAction: RxCocoa.Driver<DialogProtocols.DialogGroup.GroupType> { get }
  var selectNewGroupOwner: RxSwift.AnyObserver<Swift.Void> { get }
}
public typealias LeaveGroupActionId = Swift.String
extension Reactive where Base : UIKit.UIView, Base : Dialog_iOS.AnimatingViewProtocol {
  public var isAnimating: RxCocoa.Binder<Swift.Bool> {
    get
  }
}
extension Reactive where Base : UIKit.UIView, Base : Dialog_iOS.RevealLoaderViewProtocol {
  public var isAnimatingOnFullscreen: RxCocoa.Binder<Swift.Bool> {
    get
  }
}
public protocol AnimatingViewProtocol : AnyObject {
  var isAnimating: Swift.Bool { get set }
}
public protocol RevealLoaderViewProtocol : Dialog_iOS.AnimatingViewProtocol {
  func show(on view: UIKit.UIView?)
  func hide()
}
extension RevealLoaderViewProtocol {
  public func show(on view: UIKit.UIView? = nil)
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class SimpleBlurredLoaderView : UIKit.UIView, Dialog_iOS.RevealLoaderViewProtocol {
  public var isAnimating: Swift.Bool {
    get
    set
  }
  public func hide()
  public func show(on view: UIKit.UIView?)
  @objc override dynamic public func layoutSubviews()
  @objc deinit
}
public protocol LocalSearchDialogSourceProviderProtocol {
  var dialogSource: RxSwift.Observable<[DialogSearching.LocalSearchRelevanceIdentifiable]> { get }
}
final public class LocalSearchDialogSourceProvider : Dialog_iOS.LocalSearchDialogSourceProviderProtocol {
  public struct Config {
    public static let `default`: Dialog_iOS.LocalSearchDialogSourceProvider.Config
    public var chunkSize: Swift.Int
    public var debounce: Dispatch.DispatchTimeInterval
  }
  final public let dialogSource: RxSwift.Observable<[DialogSearching.LocalSearchRelevanceIdentifiable]>
  public init(dialogs: RxSwift.Observable<[DialogProtocols.DialogState]>, users: RxSwift.Observable<[DialogProtocols.DialogUserId : DialogProtocols.DialogUser]>, groups: RxSwift.Observable<[DialogProtocols.DialogGroupId : DialogProtocols.DialogGroup]>, config: Dialog_iOS.LocalSearchDialogSourceProvider.Config = .default)
  @objc deinit
}
extension Theme.Domain {
  public static let markdown: Dialog_iOS.Theme.Domain
}
extension Theme.Keys.Markdown {
  public static let codeFont: Dialog_iOS.Theme.Keys.Markdown
}
extension Theme.Defaults {
  public static let markdown: DialogSharedComponents.Subtheme<Dialog_iOS.Theme.Keys.Markdown>
}
extension Theme.Keys {
  public struct Markdown : Dialog_iOS.DomainSpecificKey, Swift.RawRepresentable {
    public static var domain: Dialog_iOS.Theme.Domain
    public var domainInternalId: Swift.String {
      get
    }
    public let rawValue: Swift.String
    public init(rawValue: Swift.String)
    public typealias RawValue = Swift.String
  }
}
final public class MediaConfigService : DialogProtocols.MediaConfigServiceProtocol {
  final public var currentAudioDeviceSetup: AVFoundation.AVAudioSessionRouteDescription {
    get
  }
  final public let audioDevicesCount: RxSwift.Observable<Swift.Int>
  final public let audioDeviceSetup: RxSwift.Observable<AVFoundation.AVAudioSessionRouteDescription>
  @objc deinit
  public init(notificationCenter: Foundation.NotificationCenter = .default)
  final public func startCheckingAudioRoute()
  final public func stopCheckingAudioRoute()
  final public func toggleDynamic()
  final public func audioSessionActivated(_ session: AVFoundation.AVAudioSession)
  final public func audioSessionDeactivated(_ session: AVFoundation.AVAudioSession)
  final public func setupAudioSessionForPlayAndRecord(videoOptions: DialogProtocols.MediaConfigSessionVideoOptions)
  final public func resetSessionModeForCall(videoOptions: DialogProtocols.MediaConfigSessionVideoOptions)
  final public func activateAudioSession()
  final public func deactivateAudioSession()
  final public func bindNetwork(isConnected: RxSwift.Observable<Swift.Bool>, hasActiveCall: RxSwift.Observable<Swift.Bool>)
}
extension AVAudioSession {
  public var currentRouteFirstOutputType: AVFoundation.AVAudioSession.Port? {
    get
  }
  public var isCurrentRouteSetToBuiltInReceiver: Swift.Bool {
    get
  }
  public var isCurrentRouteSetToSpeaker: Swift.Bool {
    get
  }
  public var isCurrentRouteSetToBluetoothDevice: Swift.Bool {
    get
  }
  public var outputsDescription: Swift.String {
    get
  }
  public func isCurrentRouteFirstOutputType(type: AVFoundation.AVAudioSession.Port) -> Swift.Bool
}
extension AVAudioSessionRouteDescription {
  public var isAnyNonEmbeddedSupportedPortConnected: Swift.Bool {
    get
  }
}
extension RTCAudioSession {
  public func configure(_ closure: (WebRTC.RTCAudioSession) throws -> Swift.Void) rethrows
}
public protocol MediaControlViewModelProtocol : AnyObject {
  var state: RxRelay.BehaviorRelay<Dialog_iOS.MediaControlState> { get }
  var tapAction: RxRelay.PublishRelay<Swift.Void> { get }
  var icon: RxCocoa.Driver<UIKit.UIImage?> { get }
  var tintColor: UIKit.UIColor { get }
  var isMyMessage: Swift.Bool { get }
  var themeService: Dialog_iOS.AppThemeService { get }
  var showErrorInfo: RxCocoa.Driver<Swift.String> { get }
  func subscribe()
}
public class MediaUploadControlViewModel : Dialog_iOS.MediaControlViewModelProtocol {
  public typealias LoadProgressInfo = (bytesWritten: Swift.Int64, totalBytes: Swift.Int64)
  final public let icon: RxCocoa.Driver<UIKit.UIImage?>
  final public let tintColor: UIKit.UIColor
  final public let isMyMessage: Swift.Bool
  final public let state: RxRelay.BehaviorRelay<Dialog_iOS.MediaControlState>
  final public let tapAction: RxRelay.PublishRelay<Swift.Void>
  final public let showErrorInfo: RxCocoa.Driver<Swift.String>
  final public let themeService: Dialog_iOS.AppThemeService
  public init(fileService: DialogFiles.DialogFileServiceProtocol, eventBusService: DialogProtocols.EventBusServiceProtocol, content: DialogMessaging.DialogDocumentMessageContent, isMyMessage: Swift.Bool, themeService: Dialog_iOS.AppThemeService)
  public func subscribe()
  @objc deinit
}
public class MediaDownloadControlViewModel : Dialog_iOS.MediaControlViewModelProtocol {
  public typealias LoadProgressInfo = (bytesWritten: Swift.Int64, totalBytes: Swift.Int64)
  final public let icon: RxCocoa.Driver<UIKit.UIImage?>
  final public let tintColor: UIKit.UIColor
  public var themeService: Dialog_iOS.AppThemeService
  final public let isMyMessage: Swift.Bool
  final public let state: RxRelay.BehaviorRelay<Dialog_iOS.MediaControlState>
  final public let tapAction: RxRelay.PublishRelay<Swift.Void>
  final public let showErrorInfo: RxCocoa.Driver<Swift.String>
  public init(fileService: DialogFiles.DialogFileServiceProtocol, metricsService: DialogMetrics.DialogMetricsServiceProtocol, eventBusService: DialogProtocols.EventBusServiceProtocol, content: DialogMessaging.DialogDocumentMessageContent, isMyMessage: Swift.Bool, themeService: Dialog_iOS.AppThemeService, autoload: Swift.Bool, showBlur: Swift.Bool)
  public func subscribe()
  @objc deinit
}
public struct MenuActionInfo {
  public let action: ObjectiveC.Selector
  public let sender: Any?
  public init(action: ObjectiveC.Selector, sender: Any?)
  public init(conversationAction: Dialog_iOS.ConversationStandardEditActionType, sender: Any?)
}
public struct MenuActionEvent {
  public let source: Any?
  public let info: Dialog_iOS.MenuActionInfo
  public init(source: Any?, info: Dialog_iOS.MenuActionInfo)
}
public protocol MessageAuthorViewModelProtocol {
  var messageAuthorText: RxSwift.Observable<Swift.String> { get }
  var messageAuthorColor: UIKit.UIColor { get }
}
public protocol MessageAuthorDesignProtocol {
  var preserveDefaultAuthorColor: Swift.Bool { get }
  var defaultAuthorColor: UIKit.UIColor { get }
  var authorLabelMaxLinesCount: Swift.UInt { get }
  var authorLabelInsets: UIKit.UIEdgeInsets { get }
  var authorLabelAttributes: [Foundation.NSAttributedString.Key : Any] { get }
  var authorIconImage: UIKit.UIImage? { get }
}
extension Theme.Defaults {
  public static let messageBubbles: DialogSharedComponents.Subtheme<Dialog_iOS.Theme.Keys.MessageBubbles>
}
public let subscribeViewModelScheduler: RxSwift.SerialDispatchQueueScheduler
public struct MessageCellViewModelIdentity : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Dialog_iOS.MessageCellViewModelIdentity, rhs: Dialog_iOS.MessageCellViewModelIdentity) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public protocol MessageCellViewModelProtocol {
  var identity: Dialog_iOS.MessageCellViewModelIdentity { get }
  func isEqualTo(message: Dialog_iOS.MessageCellViewModelProtocol) -> Swift.Bool
  var asAny: Dialog_iOS.AnyMessageCellViewModel { get }
}
public protocol MessageCellViewModelDeferredSubscribeProtocol {
  mutating func subscribe()
}
public struct AnyMessageCellViewModel : Dialog_iOS.MessageCellViewModelProtocol, Differentiator.IdentifiableType, Swift.Equatable {
  public var identity: Dialog_iOS.MessageCellViewModelIdentity {
    get
  }
  public static func == (lhs: Dialog_iOS.AnyMessageCellViewModel, rhs: Dialog_iOS.AnyMessageCellViewModel) -> Swift.Bool
  public typealias Identity = Dialog_iOS.MessageCellViewModelIdentity
}
extension MessageCellViewModelProtocol where Self : Swift.Equatable {
  public func isEqualTo(message: Dialog_iOS.MessageCellViewModelProtocol) -> Swift.Bool
  public var asAny: Dialog_iOS.AnyMessageCellViewModel {
    get
  }
}
public struct MessageCellViewModel : Dialog_iOS.MessageCellViewModelProtocol, Dialog_iOS.MessageCellViewModelDeferredSubscribeProtocol {
  public let messageDidReplied: RxSwift.AnyObserver<Swift.Void>
  public var canReply: RxRelay.BehaviorRelay<Swift.Bool>
  public struct Content {
  }
  public let isMyMessage: Swift.Bool
  public var content: Dialog_iOS.MessageCellViewModel.Content {
    get
  }
  public var midOfContent: DialogSDK_GRPC.Dialog_UUIDValue? {
    get
  }
  public let identity: Dialog_iOS.MessageCellViewModelIdentity
  public mutating func subscribe()
}
extension MessageCellViewModel : Swift.Equatable {
  public static func == (lhs: Dialog_iOS.MessageCellViewModel, rhs: Dialog_iOS.MessageCellViewModel) -> Swift.Bool
}
public protocol MessageContentViewModelDeferredSubscribeProtocol {
  func subscribe()
}
public protocol MessageContentDesignProtocol {
}
public protocol MessageContentNodeProtocol {
}
public protocol MessageInputSelectionPanelViewModelProtocol {
  var forwardSelectedMessages: RxSwift.AnyObserver<Swift.Void> { get }
  var deleteSelectedMessages: RxSwift.AnyObserver<Swift.Void> { get }
  var forwardAllowed: RxCocoa.Driver<Swift.Bool> { get }
  var deleteAllowed: RxCocoa.Driver<Swift.Bool> { get }
  var needShowForwardButton: RxCocoa.Driver<Swift.Bool> { get }
  var needShowDeleteButton: RxCocoa.Driver<Swift.Bool> { get }
  var needShowSelectionPanel: RxCocoa.Driver<Swift.Bool> { get }
  var generalColor: RxCocoa.Driver<UIKit.UIColor?> { get }
}
final public class MessageInputSelectionPanelViewModel : Dialog_iOS.MessageInputSelectionPanelViewModelProtocol {
  final public var forwardSelectedMessages: RxSwift.AnyObserver<Swift.Void>
  final public var deleteSelectedMessages: RxSwift.AnyObserver<Swift.Void>
  final public var forwardAllowed: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Swift.Bool>
  final public var deleteAllowed: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Swift.Bool>
  final public var needShowForwardButton: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Swift.Bool>
  final public let needShowDeleteButton: RxCocoa.Driver<Swift.Bool>
  final public var needShowSelectionPanel: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Swift.Bool>
  final public var generalColor: RxCocoa.Driver<UIKit.UIColor?>
  public init(conversationEventBus: RxSwift.Observable<Dialog_iOS.ConversationEventBus>, featureFlagsService: DialogProtocols.DialogFeatureFlagsServiceProtocol, editService: DialogMessaging.DialogMessageEditingServiceProtocol, peer: DialogProtocols.DialogPeer, activeUserId: DialogProtocols.DialogUserId, eventBus: DialogProtocols.EventBusServiceProtocol, generalColor: RxSwift.Observable<UIKit.UIColor?>)
  @objc deinit
}
public enum MessageInputContentType : Swift.Hashable {
  case textInput
  case selectionPanel
  case channelPanel
  case join
  public static func == (a: Dialog_iOS.MessageInputContentType, b: Dialog_iOS.MessageInputContentType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol MessageInputViewModelProtocol : Dialog_iOS.InputBarAttachViewModel, Dialog_iOS.ViewModelProtocol, InputBarAccessoryView.InputBarAccessoryViewDelegate {
  var themeService: Dialog_iOS.AppThemeService { get }
  var weakService: DialogMessaging.DialogWeakUpdatesServiceObjcProtocol { get }
  var canInputAnyMessages: RxCocoa.Driver<Swift.Bool> { get }
  var showWarning: RxCocoa.Driver<Swift.Bool> { get }
  var warningText: RxCocoa.Driver<Swift.String?> { get }
  var assignConversationEventBus: RxSwift.AnyObserver<Dialog_iOS.ConversationEventBus> { get }
  var selectionPanelViewModel: Dialog_iOS.MessageInputSelectionPanelViewModelProtocol { get }
  var joinPanelViewModel: Dialog_iOS.ConversationJoinPanelViewModelProtocol { get }
  var channelAccessoryViewModel: Dialog_iOS.ChannelAccessoryViewModelProtocol { get }
  var sendText: RxSwift.AnyObserver<Swift.String> { get }
  var jumpToMessage: RxSwift.Observable<DialogProtocols.DialogMessage> { get }
  var text: RxSwift.AnyObserver<Swift.String?> { get }
  var setText: RxCocoa.Driver<Swift.String?> { get }
  var isTextEditing: RxCocoa.Driver<Swift.Bool> { get }
  var join: RxSwift.AnyObserver<Swift.Void> { get }
  var attachTap: RxSwift.AnyObserver<Swift.Void> { get }
  var cameraTap: RxSwift.AnyObserver<Swift.Void> { get }
  var openPicker: RxCocoa.Driver<Swift.Void> { get }
  var openStickerCollection: RxCocoa.Driver<Swift.Void> { get }
  var sendAssets: RxSwift.AnyObserver<Dialog_iOS.TypeAssetToMessages> { get }
  var mentionUsersSource: RxCocoa.Driver<[Dialog_iOS.DialogAutocompleteTableViewCellViewModel]> { get }
  var contentType: RxCocoa.Driver<Dialog_iOS.MessageInputContentType> { get }
  var canSendMessge: RxCocoa.Driver<Swift.Bool> { get }
  var messageValidationError: RxCocoa.Driver<DialogProtocols.MessagingError> { get }
  var stickerViewModel: Dialog_iOS.StickerCollectionViewModel { get }
  var didTapEdit: RxCocoa.Driver<Swift.Void> { get }
  var featureFlagsService: DialogProtocols.DialogFeatureFlagsServiceProtocol { get }
  var presentCameraPicker: RxCocoa.Driver<Swift.Void> { get }
  var presentCameraAccessDeniedAlert: RxCocoa.Driver<Swift.Void> { get }
}
@_hasMissingDesignatedInitializers public class MessageInputViewModel : Dialog_iOS.MessageInputViewModelProtocol {
  final public let didTapAttachDismiss: RxSwift.AnyObserver<Swift.Void>
  final public let didTapAttachContent: RxSwift.AnyObserver<Swift.Void>
  final public let isAttachShown: RxSwift.Observable<DialogProtocols.MessageAttachType?>
  final public let attachmentAuthorName: RxCocoa.Driver<Swift.String?>
  final public let attachmentText: RxCocoa.Driver<Swift.String?>
  final public let attachmentHasFileError: RxCocoa.Driver<Swift.Bool>
  final public let attachmentFastThumb: RxSwift.Observable<DialogProtocols.DialogFastThumb?>
  final public let selectionPanelViewModel: Dialog_iOS.MessageInputSelectionPanelViewModelProtocol
  final public let channelAccessoryViewModel: Dialog_iOS.ChannelAccessoryViewModelProtocol
  public var joinPanelViewModel: Dialog_iOS.ConversationJoinPanelViewModelProtocol
  public var jumpToMessage: RxSwift.Observable<DialogProtocols.DialogMessage> {
    get
  }
  public var assignConversationEventBus: RxSwift.AnyObserver<Dialog_iOS.ConversationEventBus> {
    get
  }
  final public let themeService: Dialog_iOS.AppThemeService
  final public let weakService: DialogMessaging.DialogWeakUpdatesServiceObjcProtocol
  final public let canInputAnyMessages: RxCocoa.Driver<Swift.Bool>
  final public let showWarning: RxCocoa.Driver<Swift.Bool>
  final public let warningText: RxCocoa.Driver<Swift.String?>
  final public let setText: RxCocoa.Driver<Swift.String?>
  final public let isTextEditing: RxCocoa.Driver<Swift.Bool>
  final public let join: RxSwift.AnyObserver<Swift.Void>
  final public let sendText: RxSwift.AnyObserver<Swift.String>
  final public let text: RxSwift.AnyObserver<Swift.String?>
  final public let attachTap: RxSwift.AnyObserver<Swift.Void>
  final public let cameraTap: RxSwift.AnyObserver<Swift.Void>
  final public let openPicker: RxCocoa.Driver<Swift.Void>
  final public let openStickerCollection: RxCocoa.Driver<Swift.Void>
  final public let sendAssets: RxSwift.AnyObserver<Dialog_iOS.TypeAssetToMessages>
  final public let mentionUsersSource: RxCocoa.Driver<[Dialog_iOS.DialogAutocompleteTableViewCellViewModel]>
  final public let contentType: RxCocoa.Driver<Dialog_iOS.MessageInputContentType>
  final public let canSendMessge: RxCocoa.Driver<Swift.Bool>
  final public let messageValidationError: RxCocoa.Driver<DialogProtocols.MessagingError>
  public var controlColor: RxCocoa.Driver<UIKit.UIColor>
  final public let stickerViewModel: Dialog_iOS.StickerCollectionViewModel
  final public let didTapEdit: RxCocoa.Driver<Swift.Void>
  final public let featureFlagsService: DialogProtocols.DialogFeatureFlagsServiceProtocol
  final public let presentCameraPicker: RxCocoa.Driver<Swift.Void>
  final public let presentCameraAccessDeniedAlert: RxCocoa.Driver<Swift.Void>
  @objc deinit
}
extension MessageInputViewModel : InputBarAccessoryView.InputBarAccessoryViewDelegate {
  public func inputBar(_ inputBar: InputBarAccessoryView.InputBarAccessoryView, didPressSendButtonWith text: Swift.String)
  public func inputBar(_ inputBar: InputBarAccessoryView.InputBarAccessoryView, textViewTextDidChangeTo text: Swift.String)
}
public protocol MessageInputUIStyle {
  var autocompleteUserSymbol: Swift.String { get }
  var autocompleteUserTextAttributes: [Foundation.NSAttributedString.Key : Any] { get }
  var autocompleteUserNameAttributes: [Foundation.NSAttributedString.Key : Any] { get }
}
public protocol MessageInputInterface {
  var openPicker: RxSwift.Observable<Swift.Void> { get }
  var openStickerCollection: RxSwift.Observable<Swift.Void> { get }
  var assetsSelection: RxSwift.AnyObserver<Dialog_iOS.TypeAssetToMessages> { get }
  var assignEventBus: RxSwift.AnyObserver<Dialog_iOS.ConversationEventBus> { get }
  var jumpToMessage: RxSwift.Observable<DialogProtocols.DialogMessage> { get }
  var presentAlert: RxCocoa.Driver<UIKit.UIAlertController> { get }
  var textDidChange: RxCocoa.Driver<Swift.String?> { get }
  var presentCameraPicker: RxCocoa.Driver<Swift.Void> { get }
}
public protocol MessageInputUIEmbeddable : AnyObject {
  var view: UIKit.UIView { get }
  var interface: Dialog_iOS.MessageInputInterface { get }
  var autocompletionViewHeight: RxCocoa.Driver<CoreGraphics.CGFloat> { get }
}
@objc final public class MessageInputUIModule : ObjectiveC.NSObject, Dialog_iOS.MessageInputUIEmbeddable {
  final public var interface: Dialog_iOS.MessageInputInterface {
    get
  }
  final public let dialog: DialogProtocols.DialogState
  final public var autocompletionViewHeight: RxCocoa.Driver<CoreGraphics.CGFloat> {
    get
  }
  final public var view: UIKit.UIView {
    get
  }
  public init(dialog: DialogProtocols.DialogState, viewModel: Dialog_iOS.MessageInputViewModelProtocol, callsService: DialogCalls.CallsServiceProtocol)
  final public func configure(style: Dialog_iOS.MessageInputUIStyle, featureFlagsService: DialogProtocols.DialogFeatureFlagsServiceProtocol)
  @objc deinit
  @objc override dynamic public init()
}
extension MessageInputUIModule : UIKit.UITextPasteDelegate {
  @objc final public func textPasteConfigurationSupporting(_ textPasteConfigurationSupporting: UIKit.UITextPasteConfigurationSupporting, shouldAnimatePasteOf attributedString: Foundation.NSAttributedString, to textRange: UIKit.UITextRange) -> Swift.Bool
}
extension MessageInputUIModule : InputBarAccessoryView.AutocompleteManagerDelegate {
  final public func autocompleteManager(_ manager: InputBarAccessoryView.AutocompleteManager, shouldBecomeVisible: Swift.Bool)
  final public func autocompleteManager(_ manager: InputBarAccessoryView.AutocompleteManager, shouldRegister prefix: Swift.String, at range: Foundation.NSRange) -> Swift.Bool
  final public func autocompleteManager(_ manager: InputBarAccessoryView.AutocompleteManager, shouldUnregister prefix: Swift.String) -> Swift.Bool
  final public func autocompleteManager(_ manager: InputBarAccessoryView.AutocompleteManager, shouldComplete prefix: Swift.String, with text: Swift.String) -> Swift.Bool
  final public func setAutocompleteManager(active: Swift.Bool)
}
extension MessageInputUIModule : InputBarAccessoryView.AutocompleteManagerDataSource {
  final public func autocompleteManager(_ manager: InputBarAccessoryView.AutocompleteManager, autocompleteSourceFor prefix: Swift.String) -> [InputBarAccessoryView.AutocompleteCompletion]
  final public func autocompleteManager(_ manager: InputBarAccessoryView.AutocompleteManager, tableView: UIKit.UITableView, cellForRowAt indexPath: Foundation.IndexPath, for session: InputBarAccessoryView.AutocompleteSession) -> UIKit.UITableViewCell
}
public struct CellMenuSource {
}
public protocol MessageListMenuContextProtocol {
  var sections: [Dialog_iOS.MessagesListSection] { get }
}
extension MessageListMenuContextProtocol {
  public func content(at: Foundation.IndexPath) -> Dialog_iOS.MessageCellViewModel.Content?
  public func message(at: Foundation.IndexPath) -> DialogProtocols.DialogMessage?
  public func withMessage(at: Foundation.IndexPath, block: (DialogProtocols.DialogMessage) throws -> Swift.Void) rethrows
}
open class MessageListControllerContext : Dialog_iOS.MessageListMenuContextProtocol {
  public var sections: [Dialog_iOS.MessagesListSection] {
    get
  }
  public init(sectionsGetter: @escaping () -> ([Dialog_iOS.MessagesListSection]))
  @objc deinit
}
public enum MessageActionError : Swift.Error {
  case unknownContent
  case unexpectedEvent
  public static func == (a: Dialog_iOS.MessageActionError, b: Dialog_iOS.MessageActionError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public enum MessageListControllerMenuResolve : Swift.Equatable {
  case show(items: [UIKit.UIMenuItem])
  case doNotShow
  public static func == (a: Dialog_iOS.MessageListControllerMenuResolve, b: Dialog_iOS.MessageListControllerMenuResolve) -> Swift.Bool
}
public protocol ControllerMenuProtocol {
  func resolveMenu(forItem item: Dialog_iOS.MessageCellViewModel.Content?, messageStatus: DialogProtocols.DialogMyMessageStatusType?, fileError: DialogProtocols.DialogFileError?) -> Dialog_iOS.MessageListControllerMenuResolve
  func handleEvent(_ event: Dialog_iOS.MenuActionEvent, item: Dialog_iOS.MessageCellViewModel.Content?) throws
}
public protocol MenuInteractorProtocol {
  func canPerformAction(_ action: ObjectiveC.Selector, item: Dialog_iOS.MessageCellViewModel.Content, messageStatus: DialogProtocols.DialogMyMessageStatusType?, fileError: DialogProtocols.DialogFileError?) -> Swift.Bool
  func handleEvent(_ event: Dialog_iOS.MenuActionEvent, item: Dialog_iOS.MessageCellViewModel.Content) throws
}
open class ControllerMenu : Dialog_iOS.ControllerMenuProtocol {
  final public let interactor: Dialog_iOS.MenuInteractorProtocol
  public init(interactor: Dialog_iOS.MenuInteractorProtocol)
  open func resolveMenu(forItem item: Dialog_iOS.MessageCellViewModel.Content?, messageStatus: DialogProtocols.DialogMyMessageStatusType?, fileError: DialogProtocols.DialogFileError?) -> Dialog_iOS.MessageListControllerMenuResolve
  open func createMenuItems(item: Dialog_iOS.MessageCellViewModel.Content, messageStatus: DialogProtocols.DialogMyMessageStatusType?, fileError: DialogProtocols.DialogFileError?) -> [UIKit.UIMenuItem]
  open func menuItem(actionType: Dialog_iOS.ConversationStandardEditActionType, item: Dialog_iOS.MessageCellViewModel.Content, messageStatus: DialogProtocols.DialogMyMessageStatusType?, fileError: DialogProtocols.DialogFileError?) -> UIKit.UIMenuItem?
  open func handleEvent(_ event: Dialog_iOS.MenuActionEvent, item: Dialog_iOS.MessageCellViewModel.Content?) throws
  @objc deinit
}
public protocol MessageMediaCellViewModelProtocol {
  var actionGroupViewModels: [Dialog_iOS.InteractiveMediaGroupViewModelProtocol] { get }
  func isEqual(_ other: Dialog_iOS.MessageMediaCellViewModelProtocol?) -> Swift.Bool
}
extension MessageMediaCellViewModelProtocol where Self : Swift.Equatable {
  public func isEqual(_ other: Dialog_iOS.MessageMediaCellViewModelProtocol?) -> Swift.Bool
}
public struct MessageMediaCellViewModel : Dialog_iOS.MessageMediaCellViewModelProtocol {
  public let actionGroupViewModels: [Dialog_iOS.InteractiveMediaGroupViewModelProtocol]
}
extension MessageMediaCellViewModel : Swift.Equatable {
  public static func == (lhs: Dialog_iOS.MessageMediaCellViewModel, rhs: Dialog_iOS.MessageMediaCellViewModel) -> Swift.Bool
}
public protocol MessageReactionsViewModelProtocol {
  var state: RxSwift.Observable<Dialog_iOS.MessageReactionsNodeState> { get }
  var isMyMessage: Swift.Bool { get }
  var didAddReactionTap: RxSwift.AnyObserver<CoreGraphics.CGPoint> { get }
  var handleAddReactionTap: RxSwift.Observable<(CoreGraphics.CGPoint, DialogProtocols.DialogMessageReaction)> { get }
  func subscribe()
}
public struct MessageReactionsNodeState : Swift.Equatable {
  public static func == (a: Dialog_iOS.MessageReactionsNodeState, b: Dialog_iOS.MessageReactionsNodeState) -> Swift.Bool
}
public struct MessageReactionsViewModel : Dialog_iOS.MessageReactionsViewModelProtocol {
  public let isMyMessage: Swift.Bool
  public var didAddReactionTap: RxSwift.AnyObserver<CoreGraphics.CGPoint> {
    get
  }
  public var handleAddReactionTap: RxSwift.Observable<(CoreGraphics.CGPoint, DialogProtocols.DialogMessageReaction)> {
    get
  }
  public var state: RxSwift.Observable<Dialog_iOS.MessageReactionsNodeState> {
    get
  }
  public func subscribe()
}
public struct CalendarDay {
}
public struct MessagesListSectionsReload : Dialog_iOS.SectionsReloadModelType {
  public let sections: [Dialog_iOS.MessagesListSection]
  public let reloadType: Dialog_iOS.ReloadType
  public let jumpInfo: Dialog_iOS.JumpInfo?
  public typealias Section = Dialog_iOS.MessagesListSection
}
public struct MessagesListSection : Differentiator.AnimatableSectionModelType {
  public typealias Item = Dialog_iOS.AnyMessageCellViewModel
  public var items: [Dialog_iOS.MessagesListSection.Item]
  public let sectionTitle: Swift.String
  public init(sectionDate: Foundation.Date, items: [Dialog_iOS.MessagesListSection.Item])
  public init(original: Dialog_iOS.MessagesListSection, items: [Dialog_iOS.MessagesListSection.Item])
  public var identity: Swift.String {
    get
  }
  public typealias Identity = Swift.String
}
extension MessagesListSection {
  public static var dateFormatter: Foundation.DateFormatter
  public static var yearDateFormatter: Foundation.DateFormatter
}
public enum MessageListSelectionMode : Swift.Equatable {
  case off
  case selection(mids: [DialogSDK_GRPC.Dialog_UUIDValue])
  public var isOn: Swift.Bool {
    get
  }
  public static func == (a: Dialog_iOS.MessageListSelectionMode, b: Dialog_iOS.MessageListSelectionMode) -> Swift.Bool
}
public typealias JumpToPathInitialInfo = (Swift.Int32, UIKit.UICollectionView.ScrollPosition, Swift.Bool)
public typealias JumpToPathInfo = (Foundation.IndexPath, UIKit.UICollectionView.ScrollPosition, Swift.Bool)
public protocol MessagesListViewModelProtocol {
  var peer: DialogProtocols.DialogPeer { get }
  var assignConversationEventBus: RxSwift.AnyObserver<Dialog_iOS.ConversationEventBus> { get }
  var conversationEventBus: RxSwift.Observable<Dialog_iOS.ConversationEventBus?> { get }
  var messagesSections: RxSwift.Observable<Dialog_iOS.MessagesListSectionsReload> { get }
  var willStartBatch: RxSwift.AnyObserver<(AsyncDisplayKit.ASBatchContext, Dialog_iOS.BatchFetchingDirection)> { get }
  var shouldPrependBatchFetch: RxSwift.BehaviorSubject<Swift.Bool> { get }
  var shouldAppendBatchFetch: RxSwift.BehaviorSubject<Swift.Bool> { get }
  var currentScrollPosition: RxSwift.BehaviorSubject<UIKit.UICollectionView.ScrollPosition> { get }
  var indexPathToRead: RxSwift.AnyObserver<Foundation.IndexPath> { get }
  var jumpToIndexPath: RxCocoa.Driver<Dialog_iOS.JumpToPathInfo> { get }
  var didEndScrolling: RxSwift.AnyObserver<Swift.Void> { get }
  var userInteractionEnabled: RxCocoa.Driver<Swift.Bool> { get }
  var isMessagesListLoading: RxCocoa.Driver<Swift.Bool> { get }
  var isMessagesListEmpty: RxCocoa.Driver<Swift.Bool> { get }
  var performJumpToMessage: RxSwift.PublishSubject<DialogSDK_GRPC.Dialog_UUIDValue> { get }
  var performJumpToDown: RxSwift.PublishSubject<Swift.Void> { get }
  var performMediaAction: RxSwift.Observable<Dialog_iOS.InteractiveMediaAction> { get }
  var handleContentTap: RxSwift.AnyObserver<Dialog_iOS.PreviewInfo> { get }
  var handleDoubleTapOnMessage: RxSwift.AnyObserver<DialogProtocols.DialogMessage> { get }
  var handleAddReactionTap: RxSwift.Observable<(CoreGraphics.CGPoint, Dialog_iOS.ChooseReactionViewModelProtocol)> { get }
}
public class MessagesListViewModel : Dialog_iOS.MessagesListViewModelProtocol {
  final public let peer: DialogProtocols.DialogPeer
  final public let messagesSections: RxSwift.Observable<Dialog_iOS.MessagesListSectionsReload>
  final public let willStartBatch: RxSwift.AnyObserver<(AsyncDisplayKit.ASBatchContext, Dialog_iOS.BatchFetchingDirection)>
  final public let shouldPrependBatchFetch: RxSwift.BehaviorSubject<Swift.Bool>
  final public let shouldAppendBatchFetch: RxSwift.BehaviorSubject<Swift.Bool>
  final public let currentScrollPosition: RxSwift.BehaviorSubject<UIKit.UICollectionView.ScrollPosition>
  final public let indexPathToRead: RxSwift.AnyObserver<Foundation.IndexPath>
  final public let jumpToIndexPath: RxCocoa.Driver<Dialog_iOS.JumpToPathInfo>
  final public let didEndScrolling: RxSwift.AnyObserver<Swift.Void>
  final public let userInteractionEnabled: RxCocoa.Driver<Swift.Bool>
  final public let audioPlayerViewModel: Dialog_iOS.AudioPlayerViewModelProtocol
  public var isMessagesListEmpty: RxCocoa.Driver<Swift.Bool> {
    get
    set
  }
  public var isMessagesListLoading: RxCocoa.Driver<Swift.Bool> {
    get
    set
  }
  public var performJumpToMessage: RxSwift.PublishSubject<DialogSDK_GRPC.Dialog_UUIDValue>
  final public let performJumpToDown: RxSwift.PublishSubject<Swift.Void>
  final public let performMediaAction: RxSwift.Observable<Dialog_iOS.InteractiveMediaAction>
  final public let handleAddReactionTap: RxSwift.Observable<(CoreGraphics.CGPoint, Dialog_iOS.ChooseReactionViewModelProtocol)>
  public var handleContentTap: RxSwift.AnyObserver<Dialog_iOS.PreviewInfo> {
    get
    set
  }
  public var handleDoubleTapOnMessage: RxSwift.AnyObserver<DialogProtocols.DialogMessage> {
    get
    set
  }
  public var assignConversationEventBus: RxSwift.AnyObserver<Dialog_iOS.ConversationEventBus> {
    get
  }
  public var conversationEventBus: RxSwift.Observable<Dialog_iOS.ConversationEventBus?> {
    get
  }
  public init(service: DialogMessaging.DialogMessagesServiceProtocol, connectionService: DialogProtocols.ConnectionServiceProtocol, fileService: DialogFiles.DialogFileServiceProtocol, eventsService: DialogProtocols.EventBusServiceProtocol, userEventBus: DialogProtocols.UserEventBusServiceProtocol, mediaActionService: DialogMessaging.DialogMediaActionServiceProtocol, themeService: Dialog_iOS.AppThemeService, readService: DialogMessaging.DialogReadServiceProtocol, routerService: Dialog_iOS.RouterServiceProtocol, router: Dialog_iOS.UserSpecifiedRouterProtocol, featureFlagsService: DialogProtocols.DialogFeatureFlagsServiceProtocol, colorService: Dialog_iOS.DialogPeerColorsServiceProtocol, metricsService: DialogMetrics.DialogMetricsServiceProtocol, reactionsService: DialogMessaging.DialogReactionsServiceProtocol, callsService: DialogCalls.CallsServiceProtocol, deepLinkResolver: Dialog_iOS.DeepLinkResolver, deepLinkOpener: Dialog_iOS.DeepLinkOpenerProtocol, stickersStorageService: DialogMessaging.DialogStickersStorageServiceProtocol, audioPlayerViewModel: Dialog_iOS.AudioPlayerViewModelProtocol, activeUserId: DialogProtocols.DialogUserId, peer: DialogProtocols.DialogPeer, initialDate: Swift.Int64?, unreadCountState: DialogProtocols.DialogUnreadCountState?, peerType: DialogProtocols.PeerType)
  @objc deinit
}
public protocol MultiForwardTargetListCellViewModelBuilderProtocol {
  func build(dialogs: RxSwift.Observable<[DialogProtocols.DialogState]>) -> RxSwift.Observable<[Dialog_iOS.DUICellViewModel]>
  var selection: RxSwift.Observable<(dialog: DialogProtocols.DialogState, selected: Swift.Bool)> { get }
}
public typealias DUIMultiforwardTargetSection = Dialog_iOS.DUISimpleUniqueSection<Dialog_iOS.MultiforwardTargetSectionType>
final public class MultiForwardTargetListCellViewModelBuilder : Dialog_iOS.MultiForwardTargetListCellViewModelBuilderProtocol {
  final public let myId: DialogProtocols.DialogUserId
  final public let selection: RxSwift.Observable<(dialog: DialogProtocols.DialogState, selected: Swift.Bool)>
  public init(fileService: DialogFiles.DialogFileServiceProtocol, eventBusService: DialogProtocols.EventBusServiceProtocol, colorService: Dialog_iOS.DialogPeerColorsServiceProtocol, myId: DialogProtocols.DialogUserId, presenceService: DialogProtocols.UserPresenceStateServiceProtocol, featureFlagsService: DialogProtocols.DialogFeatureFlagsServiceProtocol, themeService: Dialog_iOS.AppThemeService, filter: Dialog_iOS.ForwardableDialogsFilterProtocol, design: RxSwift.Observable<Dialog_iOS.DialogsListCellDesignProtocol>)
  final public func buildCellVM(dialog: DialogProtocols.DialogState, design: Dialog_iOS.DialogsListCellDesignProtocol) -> Dialog_iOS.DUIForwardTargetCellViewModel
  final public func build(dialogs: RxSwift.Observable<[DialogProtocols.DialogState]>) -> RxSwift.Observable<[Dialog_iOS.DUICellViewModel]>
  @objc deinit
}
@_inheritsConvenienceInitializers public class MultiForwardTargetListScene : Dialog_iOS.Scene<Dialog_iOS.ForwardTargetsListSource, UIKit.UIViewController> {
  override public class func defaultSceneBuilder() -> Dialog_iOS.Scene<Dialog_iOS.ForwardTargetsListSource, UIKit.UIViewController>.Builder
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<Dialog_iOS.ForwardTargetsListSource, UIKit.UIViewController, Dialog_iOS.MultiForwardTargetListViewModelProtocol> {
    override final public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Dialog_iOS.ForwardTargetsListSource>) -> Dialog_iOS.MultiForwardTargetListViewModelProtocol
    override final public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Dialog_iOS.ForwardTargetsListSource>, viewModel: Dialog_iOS.MultiForwardTargetListViewModelProtocol) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<Dialog_iOS.ForwardTargetsListSource, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
public protocol DUICommonSearchResultsInterface {
  var search: RxSwift.AnyObserver<Swift.String?> { get }
  var toggleTargetSelection: RxSwift.Observable<Dialog_iOS.DUISelectedPeerInfoProtocol> { get }
  var selected: RxSwift.AnyObserver<Swift.Set<DialogProtocols.DialogPeer>> { get }
}
@_inheritsConvenienceInitializers public class MultiForwardTargetListSearchResultsScene : Dialog_iOS.Scene<Swift.Void, UIKit.UIViewController> {
  override public class func defaultSceneBuilder() -> Dialog_iOS.Scene<Swift.Void, UIKit.UIViewController>.Builder
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<Swift.Void, UIKit.UIViewController, Dialog_iOS.MultiForwardTargetListSearchViewModelProtocol> {
    override final public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>) -> Dialog_iOS.MultiForwardTargetListSearchViewModelProtocol
    override final public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>, viewModel: Dialog_iOS.MultiForwardTargetListSearchViewModelProtocol) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<Swift.Void, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
@objc @_inheritsConvenienceInitializers public class MultiForwardTargetListSearchResultsViewController : UIKit.UIViewController, UIKit.UISearchResultsUpdating, Dialog_iOS.DUICommonSearchResultsInterface, UIKit.UITableViewDelegate {
  public typealias ViewModel = Dialog_iOS.MultiForwardTargetListSearchViewModelProtocol
  public var search: RxSwift.AnyObserver<Swift.String?> {
    get
  }
  public var toggleTargetSelection: RxSwift.Observable<Dialog_iOS.DUISelectedPeerInfoProtocol> {
    get
  }
  public var selected: RxSwift.AnyObserver<Swift.Set<DialogProtocols.DialogPeer>> {
    get
  }
  @objc override dynamic public func viewDidLoad()
  @objc public func updateSearchResults(for searchController: UIKit.UISearchController)
  @objc override dynamic public func viewDidAppear(_ animated: Swift.Bool)
  @objc public func tableView(_ tableView: UIKit.UITableView, viewForHeaderInSection section: Swift.Int) -> UIKit.UIView?
  @objc public func tableView(_ tableView: UIKit.UITableView, heightForHeaderInSection section: Swift.Int) -> CoreGraphics.CGFloat
  @objc public func tableView(_ tableView: UIKit.UITableView, heightForRowAt indexPath: Foundation.IndexPath) -> CoreGraphics.CGFloat
  @objc public func tableView(_ tableView: UIKit.UITableView, willSelectRowAt indexPath: Foundation.IndexPath) -> Foundation.IndexPath?
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public struct MultiForwardTargetListSearchDesign : DialogProtocols.BaseStruct {
  public static let `default`: Dialog_iOS.MultiForwardTargetListSearchDesign
}
public protocol MultiForwardTargetListSearchViewModelProtocol {
  typealias Design = Dialog_iOS.MultiForwardTargetListSearchDesign
  typealias Section = Dialog_iOS.DUISimpleUniqueSection<Dialog_iOS.MultiForwardTargetListSearchSectionType>
  var search: RxSwift.AnyObserver<Swift.String?> { get }
  var sections: RxCocoa.Driver<[Self.Section]> { get }
  var selectedPeers: RxSwift.AnyObserver<Swift.Set<DialogProtocols.DialogPeer>> { get }
  var design: RxCocoa.Driver<Dialog_iOS.MultiForwardTargetListSearchDesign> { get }
}
public struct MultiForwardTargetListSearchSectionType : Swift.RawRepresentable, Swift.Hashable {
  public typealias RawValue = Swift.String
  public let rawValue: Dialog_iOS.MultiForwardTargetListSearchSectionType.RawValue
  public init(rawValue: Dialog_iOS.MultiForwardTargetListSearchSectionType.RawValue)
  public static let local: Dialog_iOS.MultiForwardTargetListSearchSectionType
  public static let contacts: Dialog_iOS.MultiForwardTargetListSearchSectionType
  public static let groups: Dialog_iOS.MultiForwardTargetListSearchSectionType
  public var proposedTitle: Swift.String? {
    get
  }
}
final public class MultiForwardTargetListSearchViewModel : Dialog_iOS.MultiForwardTargetListSearchViewModelProtocol {
  final public let search: RxSwift.AnyObserver<Swift.String?>
  final public let sections: RxCocoa.Driver<[Dialog_iOS.MultiForwardTargetListSearchViewModel.Section]>
  final public let selectedPeers: RxSwift.AnyObserver<Swift.Set<DialogProtocols.DialogPeer>>
  final public let design: RxCocoa.Driver<Dialog_iOS.MultiForwardTargetListSearchDesign>
  public init(searchService: DialogSearching.CombinedSearchServiceProtocol, themeService: Dialog_iOS.AppThemeService, builder: Dialog_iOS.MultiForwardTargetListSearchCellViewModelBuilderProtocol)
  @objc deinit
}
public protocol MultiForwardTargetListSearchCellViewModelBuilderProtocol {
  typealias Section = Dialog_iOS.DUISimpleUniqueSection<Dialog_iOS.MultiForwardTargetListSearchSectionType>
  var onLoadMore: RxSwift.Observable<DialogSearching.CombinedSearchLoadMoreTarget> { get }
  func build(state: DialogSearching.CombinedSearchState, selectedPeers: RxSwift.Observable<Swift.Set<DialogProtocols.DialogPeer>>) -> RxSwift.Observable<[Self.Section]>
}
extension MultiForwardTargetListSearchViewModel {
  @_hasMissingDesignatedInitializers final public class CellViewModelBuilder : Dialog_iOS.MultiForwardTargetListSearchCellViewModelBuilderProtocol {
    final public var onLoadMore: RxSwift.Observable<DialogSearching.CombinedSearchLoadMoreTarget> {
      get
    }
    public struct Services {
    }
    final public func build(state: DialogSearching.CombinedSearchState, selectedPeers: RxSwift.Observable<Swift.Set<DialogProtocols.DialogPeer>>) -> RxSwift.Observable<[Dialog_iOS.MultiForwardTargetListSearchViewModel.CellViewModelBuilder.Section]>
    @objc deinit
  }
}
@objc @_inheritsConvenienceInitializers public class MultiForwardTargetListViewController : UIKit.UIViewController, UIKit.UITableViewDelegate, UIKit.UISearchControllerDelegate, InputBarAccessoryView.InputBarAccessoryViewDelegate {
  public typealias ViewModel = Dialog_iOS.MultiForwardTargetListViewModelProtocol
  @objc override dynamic public func viewDidLoad()
  @objc override dynamic public var inputAccessoryView: UIKit.UIView? {
    @objc get
  }
  public func bind(viewModel: Dialog_iOS.MultiForwardTargetListViewController.ViewModel)
  @objc override dynamic public var canBecomeFirstResponder: Swift.Bool {
    @objc get
  }
  @objc public func tableView(_ tableView: UIKit.UITableView, willSelectRowAt indexPath: Foundation.IndexPath) -> Foundation.IndexPath?
  @objc public func tableView(_ tableView: UIKit.UITableView, viewForHeaderInSection section: Swift.Int) -> UIKit.UIView?
  @objc public func tableView(_ tableView: UIKit.UITableView, heightForHeaderInSection section: Swift.Int) -> CoreGraphics.CGFloat
  @objc public func tableView(_ tableView: UIKit.UITableView, heightForRowAt indexPath: Foundation.IndexPath) -> CoreGraphics.CGFloat
  @objc public func didDismissSearchController(_ searchController: UIKit.UISearchController)
  public func inputBar(_ inputBar: InputBarAccessoryView.InputBarAccessoryView, didPressSendButtonWith text: Swift.String)
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public struct MultiForwardTargetListDesign : DialogProtocols.BaseStruct {
  public static let `default`: Dialog_iOS.MultiForwardTargetListDesign
  public var selectedDialogsCellDesign: Dialog_iOS.DUISelectedDialogsTableCellDesignProtocol
  public var resultsCellStyle: Dialog_iOS.DUIForwardTargetCellViewModelStyle
}
public protocol MultiForwardTargetListViewModelProtocol {
  var searchViewController: (UIKit.UIViewController & UIKit.UISearchResultsUpdating) { get }
  var selectionDescription: RxCocoa.Driver<Swift.String> { get }
  var sections: RxCocoa.Driver<[Dialog_iOS.DUIMultiforwardTargetSection]> { get }
  var canSelectMore: RxCocoa.Driver<Swift.Bool> { get }
  var send: RxSwift.AnyObserver<Swift.String> { get }
  var canSend: RxCocoa.Driver<Swift.Bool> { get }
  var toggleCheckmark: RxSwift.AnyObserver<DialogProtocols.DialogPeer> { get }
  var selectionLimitViolated: RxSwift.Observable<Swift.Void> { get }
  var sendImage: RxCocoa.Driver<UIKit.UIImage?> { get }
  var design: RxCocoa.Driver<Dialog_iOS.MultiForwardTargetListDesign> { get }
  var stopSearching: RxSwift.Observable<Swift.Void> { get }
  var themeService: Dialog_iOS.AppThemeService { get }
}
public enum MultiforwardTargetSectionType : Swift.Int {
  case selection
  case targets
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
open class MultiForwardTargetListViewModel : Dialog_iOS.MultiForwardTargetListViewModelProtocol {
  public typealias Design = Dialog_iOS.MultiForwardTargetListDesign
  public struct Config {
    public var selectionLimit: Swift.Int
    public static let `default`: Dialog_iOS.MultiForwardTargetListViewModel.Config
  }
  public var selectedPeers: RxCocoa.Driver<[DialogProtocols.DialogPeer]>
  final public let selectionDescription: RxCocoa.Driver<Swift.String>
  final public let canSelectMore: RxCocoa.Driver<Swift.Bool>
  public var sections: RxCocoa.Driver<[Dialog_iOS.DUIMultiforwardTargetSection]>
  final public let send: RxSwift.AnyObserver<Swift.String>
  final public let canSend: RxCocoa.Driver<Swift.Bool>
  final public let toggleCheckmark: RxSwift.AnyObserver<DialogProtocols.DialogPeer>
  final public let selectionLimitViolated: RxSwift.Observable<Swift.Void>
  final public let sendImage: RxCocoa.Driver<UIKit.UIImage?>
  final public let searchViewController: (UIKit.UIViewController & UIKit.UISearchResultsUpdating)
  final public let design: RxCocoa.Driver<Dialog_iOS.MultiForwardTargetListDesign>
  final public let stopSearching: RxSwift.Observable<Swift.Void>
  final public let themeService: Dialog_iOS.AppThemeService
  public init(messages: [DialogProtocols.DialogMessage], dialogs: RxSwift.Observable<[DialogProtocols.DialogState]>, cellBuilder: Dialog_iOS.MultiForwardTargetListCellViewModelBuilderProtocol, sendService: DialogMessaging.DialogOneMessageServiceProtocol, router: Dialog_iOS.UserSpecifiedRouterProtocol, themeService: Dialog_iOS.AppThemeService, searchViewController: (UIKit.UIViewController & UIKit.UISearchResultsUpdating), featureFlagService: DialogProtocols.DialogFeatureFlagsServiceProtocol, config: Dialog_iOS.MultiForwardTargetListViewModel.Config = .default, myId: DialogProtocols.DialogUserId)
  @objc deinit
}
@_inheritsConvenienceInitializers final public class MultiForwardTextInputView : InputBarAccessoryView.InputBarAccessoryView {
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
}
public protocol MyUserResolverProtocol {
  var myUser: RxSwift.Observable<DialogProtocols.DialogUser?> { get }
}
@_hasMissingDesignatedInitializers final public class MyUserResolver : Dialog_iOS.MyUserResolverProtocol {
  final public var myUser: RxSwift.Observable<DialogProtocols.DialogUser?>
  @objc deinit
}
public protocol NavigationCoordinatorServiceProtocol {
  func resolveCoordinator<R>() -> XCoordinator.AnyCoordinator<R, XCoordinator.NavigationTransition>? where R : XCoordinator.Route
}
extension NavigationCoordinatorServiceProtocol {
  public func resolveCoordinator<R>(routeType: R.Type) -> XCoordinator.AnyCoordinator<R, XCoordinator.NavigationTransition>? where R : XCoordinator.Route
}
final public class NavigationCoordinatorService : Dialog_iOS.NavigationCoordinatorServiceProtocol {
  final public let resolver: Swinject.Resolver
  public init(resolver: Swinject.Resolver)
  final public func resolveCoordinator<R>() -> XCoordinator.AnyCoordinator<R, XCoordinator.NavigationTransition>? where R : XCoordinator.Route
  @objc deinit
}
extension Container {
  final public func registerWeakNavigationCoordinator<R, C>(fabric: @escaping () -> C?) where R : XCoordinator.Route, C : XCoordinator.AnyCoordinator<R, XCoordinator.NavigationTransition>
}
public protocol NavigationStackOwnerServiceProtocol {
  associatedtype R : XCoordinator.Route
  typealias Owner = XCoordinator.AnyCoordinator<Self.R, XCoordinator.NavigationTransition>
  func register(factory: @escaping () -> Self.Owner?)
  func resolve() -> Self.Owner?
}
public enum NewEventBusError : Swift.Error {
  case unregisteredState
  public static func == (a: Dialog_iOS.NewEventBusError, b: Dialog_iOS.NewEventBusError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol NewEventBusProtocol : AnyObject {
  associatedtype ContextIdType : Dialog_iOS.NewEventBusContextIdRepresentable
  func register<C>(context: C) where C : Dialog_iOS.NewEventBusIdentifiableContext, Self.ContextIdType == C.ContextId
  func post<E>(event: E) where E : Dialog_iOS.NewEventBusEventRepresentable, Self.ContextIdType == E.Context.ContextId
  func observeChanges<C>(context: C.Type) -> RxSwift.Observable<(state: C.State, eventId: C.EventId?)> where C : Dialog_iOS.NewEventBusIdentifiableContext, Self.ContextIdType == C.ContextId
}
@_hasMissingDesignatedInitializers final public class NewEventBus<ContextId> : Dialog_iOS.NewEventBusProtocol where ContextId : Dialog_iOS.NewEventBusContextIdRepresentable {
  public typealias ContextIdType = ContextId
  final public func register<C>(context: C) where ContextId == C.ContextId, C : Dialog_iOS.NewEventBusIdentifiableContext
  final public func post<E>(event: E) where ContextId == E.Context.ContextId, E : Dialog_iOS.NewEventBusEventRepresentable
  final public func observeChanges<C>(context: C.Type) -> RxSwift.Observable<(state: C.State, eventId: C.EventId?)> where ContextId == C.ContextId, C : Dialog_iOS.NewEventBusIdentifiableContext
  @objc deinit
}
extension NewEventBusProtocol {
  public func observeState<C>(context: C.Type) -> RxSwift.Observable<C.State> where C : Dialog_iOS.NewEventBusIdentifiableContext, Self.ContextIdType == C.ContextId
  public func observeEvents<C>(context: C.Type) -> RxSwift.Observable<C.EventId> where C : Dialog_iOS.NewEventBusIdentifiableContext, Self.ContextIdType == C.ContextId
}
public protocol NewEventBusContextIdRepresentable : Swift.Hashable {
}
public protocol NewEventBusContext : AnyObject {
  associatedtype ContextId : Dialog_iOS.NewEventBusContextIdRepresentable
  associatedtype EventId : Dialog_iOS.NewEventBusEventIdRepresentable
  associatedtype State
  func handle<E>(event: E) where E : Dialog_iOS.NewEventBusEventRepresentable, Self.ContextId == E.Context.ContextId, Self.EventId == E.Context.EventId, Self.State == E.Context.State
  func observe() -> RxSwift.Observable<(Self.State, Self.EventId?)>
}
public protocol NewEventBusIdentifiableContext : Dialog_iOS.NewEventBusContext {
  static var contextId: Self.ContextId { get }
}
open class NewEventBusBaseStateContext<CtxState, CtxID, EID> : Dialog_iOS.NewEventBusContext where CtxID : Dialog_iOS.NewEventBusContextIdRepresentable, EID : Dialog_iOS.NewEventBusEventIdRepresentable {
  public typealias AnyStore = Dialog_iOS.AnyNewEventBusContextStore<EID, CtxState>
  public typealias State = CtxState
  public typealias ContextId = CtxID
  public typealias EventId = EID
  convenience public init<S>(store: S) where CtxState == S.State, EID == S.EventId, S : Dialog_iOS.NewEventBusContextStoreProtocol
  public init(anyStore: Dialog_iOS.NewEventBusBaseStateContext<CtxState, CtxID, EID>.AnyStore)
  convenience public init(usingFabric: (Dialog_iOS.NewEventBusBaseStateContext<CtxState, CtxID, EID>.StoreFabric) -> Dialog_iOS.NewEventBusBaseStateContext<CtxState, CtxID, EID>.AnyStore)
  public func handle<E>(event: E) where CtxState == E.Context.State, CtxID == E.Context.ContextId, EID == E.Context.EventId, E : Dialog_iOS.NewEventBusEventRepresentable
  public func observe() -> RxSwift.Observable<(CtxState, Dialog_iOS.NewEventBusBaseStateContext<CtxState, CtxID, EID>.EventId?)>
  @objc deinit
}
final public class NewEventBusContextBehaviorSubjectStore<EID, S> : Dialog_iOS.NewEventBusContextStoreProtocol where EID : Dialog_iOS.NewEventBusEventIdRepresentable {
  public typealias EventId = EID
  public typealias State = S
  final public let subject: RxSwift.BehaviorSubject<(Dialog_iOS.NewEventBusContextBehaviorSubjectStore<EID, S>.State, Dialog_iOS.NewEventBusContextBehaviorSubjectStore<EID, S>.EventId?)>
  public init(initialValue: Dialog_iOS.NewEventBusContextBehaviorSubjectStore<EID, S>.State, inputScheduler: RxSwift.ImmediateSchedulerType?)
  final public func performUpdate(eventId: Dialog_iOS.NewEventBusContextBehaviorSubjectStore<EID, S>.EventId, modifier: @escaping (Dialog_iOS.NewEventBusContextBehaviorSubjectStore<EID, S>.State) -> Dialog_iOS.NewEventBusContextBehaviorSubjectStore<EID, S>.State)
  final public func asObservable() -> RxSwift.Observable<(Dialog_iOS.NewEventBusContextBehaviorSubjectStore<EID, S>.State, Dialog_iOS.NewEventBusContextBehaviorSubjectStore<EID, S>.EventId?)>
  final public var asAnyStore: Dialog_iOS.AnyNewEventBusContextStore<Dialog_iOS.NewEventBusContextBehaviorSubjectStore<EID, S>.EventId, Dialog_iOS.NewEventBusContextBehaviorSubjectStore<EID, S>.State> {
    get
  }
  @objc deinit
}
extension NewEventBusContextStoreFabric {
  final public func behaviorSubjectStore(initial: State, inputScheduler: RxSwift.ImmediateSchedulerType?) -> Dialog_iOS.NewEventBusContextStoreFabric<EID, State>.AnyStore
}
final public class NewEventBusContextSignalEventStore<EID, S> : Dialog_iOS.NewEventBusContextStoreProtocol where EID : Dialog_iOS.NewEventBusEventIdRepresentable {
  public typealias State = S
  public typealias EventId = EID
  public init(eventInputState: Dialog_iOS.NewEventBusContextSignalEventStore<EID, S>.State)
  final public func performUpdate(eventId: Dialog_iOS.NewEventBusContextSignalEventStore<EID, S>.EventId, modifier: @escaping (Dialog_iOS.NewEventBusContextSignalEventStore<EID, S>.State) -> Dialog_iOS.NewEventBusContextSignalEventStore<EID, S>.State)
  final public func asObservable() -> RxSwift.Observable<(Dialog_iOS.NewEventBusContextSignalEventStore<EID, S>.State, Dialog_iOS.NewEventBusContextSignalEventStore<EID, S>.EventId?)>
  final public var asAnyStore: Dialog_iOS.AnyNewEventBusContextStore<Dialog_iOS.NewEventBusContextSignalEventStore<EID, S>.EventId, Dialog_iOS.NewEventBusContextSignalEventStore<EID, S>.State> {
    get
  }
  @objc deinit
}
extension NewEventBusContextStoreFabric {
  final public func constantStateStore(value: State) -> Dialog_iOS.NewEventBusContextStoreFabric<EID, State>.AnyStore
}
public protocol NewEventBusContextStoreProtocol {
  associatedtype EventId : Dialog_iOS.NewEventBusEventIdRepresentable
  associatedtype State
  func performUpdate(eventId: Self.EventId, modifier: @escaping (Self.State) -> Self.State)
  func asObservable() -> RxSwift.Observable<(Self.State, Self.EventId?)>
  var asAnyStore: Dialog_iOS.AnyNewEventBusContextStore<Self.EventId, Self.State> { get }
}
final public class AnyNewEventBusContextStore<EID, S> : Dialog_iOS.NewEventBusContextStoreProtocol where EID : Dialog_iOS.NewEventBusEventIdRepresentable {
  public typealias EventId = EID
  public typealias State = S
  public init<O>(original: O) where EID == O.EventId, S == O.State, O : Dialog_iOS.NewEventBusContextStoreProtocol
  final public var asAnyStore: Dialog_iOS.AnyNewEventBusContextStore<EID, S> {
    get
  }
  final public func performUpdate(eventId: Dialog_iOS.AnyNewEventBusContextStore<EID, S>.EventId, modifier: @escaping (Dialog_iOS.AnyNewEventBusContextStore<EID, S>.State) -> Dialog_iOS.AnyNewEventBusContextStore<EID, S>.State)
  final public func asObservable() -> RxSwift.Observable<(Dialog_iOS.AnyNewEventBusContextStore<EID, S>.State, Dialog_iOS.AnyNewEventBusContextStore<EID, S>.EventId?)>
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class NewEventBusContextStoreFabric<EID, State> where EID : Dialog_iOS.NewEventBusEventIdRepresentable {
  public typealias AnyStore = Dialog_iOS.AnyNewEventBusContextStore<EID, State>
  @objc deinit
}
extension NewEventBusContext {
  public typealias StoreFabric = Dialog_iOS.NewEventBusContextStoreFabric<Self.EventId, Self.State>
  public static var storeFabric: Self.StoreFabric {
    get
  }
}
public protocol NewEventBusEventIdRepresentable : Swift.Hashable {
}
public protocol NewEventBusEventDescription {
  associatedtype Context : Dialog_iOS.NewEventBusIdentifiableContext
}
public protocol NewEventBusEventUpdateResponsible : Dialog_iOS.NewEventBusEventDescription {
  typealias Update = (Self, Self.Context.State) -> Self.Context.State
  static var update: Self.Update { get }
}
public protocol NewEventBusEventRepresentable : Dialog_iOS.NewEventBusEventUpdateResponsible {
  static var id: Self.Context.EventId { get }
}
extension NewEventBusEventUpdateResponsible {
  public func performUpdate(state: Self.Context.State) -> Self.Context.State
}
public protocol NodePropertyProtocol {
  associatedtype E
  var controlProperty: RxCocoa.ControlProperty<Self.E> { get }
}
final public class NodeProperty<E> : Dialog_iOS.NodePropertyProtocol {
  final public let controlProperty: RxCocoa.ControlProperty<E>
  final public let relay: RxRelay.BehaviorRelay<E>
  final public let setter: RxSwift.AnyObserver<E>
  public init(value: E)
  @objc deinit
}
public struct NotificationKey {
  public enum MissedCall : Swift.String {
    case callerType
    case callerUserId
    case callerAccessHash
    public var asNSString: Foundation.NSString {
      get
    }
    public typealias RawValue = Swift.String
    public init?(rawValue: Swift.String)
    public var rawValue: Swift.String {
      get
    }
  }
}
public enum MissedCallCaller {
  case unknown
  case user(id: DialogProtocols.DialogUserId, accessHash: Swift.Int64)
  public func put(to userInfo: inout [Swift.AnyHashable : Any])
  public func put(to content: UserNotifications.UNMutableNotificationContent)
  public init?(userInfo: [Swift.AnyHashable : Any])
}
public class NotificationPreferencesCellViewModel : Dialog_iOS.SubtitledSwitcherTableViewModelCellProtocol, Differentiator.IdentifiableType {
  public typealias Identity = Swift.String
  public var identity: Swift.String {
    get
  }
  public var switchToggledHandle: RxSwift.AnyObserver<Swift.Bool>
  public var switchInitSet: RxCocoa.Driver<Swift.Bool>
  public var isActive: RxCocoa.Driver<Swift.Bool>
  public var title: RxCocoa.Driver<Swift.String>
  public var subTitle: RxCocoa.Driver<Swift.String?>
  public init(state: RxSwift.Observable<[DialogProtocols.DialogNotificationSetting : Swift.Bool]>, changesEnabled: RxSwift.Observable<Swift.Bool>, valueHandler: RxSwift.AnyObserver<(DialogProtocols.DialogNotificationSetting, Swift.Bool)>, setting: DialogProtocols.DialogNotificationSetting)
  @objc deinit
}
extension NotificationPreferencesCellViewModel : Swift.Equatable {
  public static func == (lhs: Dialog_iOS.NotificationPreferencesCellViewModel, rhs: Dialog_iOS.NotificationPreferencesCellViewModel) -> Swift.Bool
}
@objc final public class NotificationPreferencesViewController : UIKit.UIViewController {
  public typealias VM = Dialog_iOS.NotificationsPreferencesModelProtocol
  public init(viewModel: Dialog_iOS.NotificationPreferencesViewController.VM)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc override final public func viewDidLoad()
  @objc deinit
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
}
public protocol NotificationsPreferencesModelProtocol : AnyObject {
  var changesEnabled: RxCocoa.Driver<Swift.Bool> { get }
  var switcherToggledHandle: RxSwift.AnyObserver<(DialogProtocols.DialogNotificationSetting, Swift.Bool)> { get }
  var sections: RxCocoa.Driver<[Dialog_iOS.NotificationSettingSection]> { get }
}
final public class NotificationsPreferencesViewModel : Dialog_iOS.NotificationsPreferencesModelProtocol {
  final public let sections: RxCocoa.Driver<[Dialog_iOS.NotificationSettingSection]>
  final public let switcherToggledHandle: RxSwift.AnyObserver<(DialogProtocols.DialogNotificationSetting, Swift.Bool)>
  final public let changesEnabled: RxCocoa.Driver<Swift.Bool>
  public init(notificationService: DialogProtocols.GlobalNotificationsSettingsConfigServiceProtocol, appNotificationSettingsService: Dialog_iOS.AppNotificationSettingsServiceProtocol = AppNotificationSettingsService())
  @objc deinit
}
public struct NotificationSettingSection : Differentiator.AnimatableSectionModelType {
  public typealias Identity = Swift.String
  public var identity: Swift.String {
    get
  }
  public var items: [Dialog_iOS.NotificationSettingSection.Item]
}
extension NotificationSettingSection : Differentiator.SectionModelType {
  public typealias Item = Dialog_iOS.NotificationPreferencesCellViewModel
  public init(original: Dialog_iOS.NotificationSettingSection, items: [Dialog_iOS.NotificationPreferencesCellViewModel])
}
@_inheritsConvenienceInitializers final public class NotificationsPreferencesScene : Dialog_iOS.Scene<Swift.Void, UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.NotificationsPreferencesScene.Builder
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<Swift.Void, UIKit.UIViewController, Dialog_iOS.NotificationsPreferencesModelProtocol> {
    override final public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>) -> Dialog_iOS.NotificationsPreferencesModelProtocol
    override final public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>, viewModel: Dialog_iOS.NotificationsPreferencesModelProtocol) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<Swift.Void, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
@_hasMissingDesignatedInitializers final public class NotificationsTokenUtility {
  @objc deinit
}
extension NSLayoutConstraint {
  public func prioriterized(_ priority: UIKit.UILayoutPriority) -> UIKit.NSLayoutConstraint
  public func identified(_ identifier: Swift.String) -> UIKit.NSLayoutConstraint
}
extension NSAttributedString {
  public func extractAttachedImage() -> (Foundation.NSAttributedString, UIKit.UIImage?)
}
extension NSAttributedString {
  public func attributedStringByTrimmingCharacterSet(charSet: Foundation.CharacterSet) -> Foundation.NSAttributedString
}
extension NSAttributedString {
  public var width: CoreGraphics.CGFloat {
    get
  }
  public var size: CoreGraphics.CGSize {
    get
  }
}
extension NSMutableAttributedString {
  public func trimCharactersInSet(charSet: Foundation.CharacterSet)
}
extension NSUserActivity {
  public var startCallHandle: (Intents.INPersonHandle, DialogProtocols.AccessibleCallType)? {
    get
  }
}
extension Observable {
  public func asDriverIgnoringErrors() -> RxCocoa.Driver<Element>
}
extension Observable where Element == DialogAuth.AuthFlowState {
  public func applyStep(latestFrom: RxSwift.Observable<DialogAuth.AuthFlowStep>) -> RxSwift.Observable<DialogAuth.AuthFlowState>
}
extension Observable where Element : Swift.Equatable {
  public func filterIfEqualLatest(observable: RxSwift.Observable<Element>) -> RxSwift.Observable<Element>
}
extension Observable {
  public func debounceAfterFirst(dueTime: Dispatch.DispatchTimeInterval, scheduler: RxSwift.SchedulerType) -> RxSwift.Observable<Element>
}
extension Observable {
  public func skipFirst(_ predicate: @escaping (Element) throws -> Swift.Bool) -> RxSwift.Observable<Element>
}
extension Observable {
  public func switchToNilAfter(timeout: RxSwift.RxTimeInterval = .seconds(5), scheduler: RxSwift.SchedulerType = MainScheduler.asyncInstance) -> RxSwift.Observable<Element?>
}
extension Observable {
  public func switchAfter(timeout: RxSwift.RxTimeInterval = .seconds(5), scheduler: RxSwift.SchedulerType = MainScheduler.asyncInstance, newValue: Element) -> RxSwift.Observable<Element>
}
public enum TargetIndexType {
  case top
  case bottom
  public static func == (a: Dialog_iOS.TargetIndexType, b: Dialog_iOS.TargetIndexType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
@objc @_inheritsConvenienceInitializers public class OffsetAwareVerticalFlowLayoutV2 : UIKit.UICollectionViewFlowLayout {
  public var automaticallyAdjustsContentOffset: Swift.Bool
  public func resetLayoutAttributes()
  public func setTargetIntexType(_ type: Dialog_iOS.TargetIndexType)
  public func setTargetIndex(_ indexPath: Foundation.IndexPath?)
  @objc override dynamic open func prepare()
  @objc override dynamic open func prepare(forCollectionViewUpdates updateItems: [UIKit.UICollectionViewUpdateItem])
  @objc override dynamic open func finalizeCollectionViewUpdates()
  @objc override dynamic open func shouldInvalidateLayout(forBoundsChange newBounds: CoreGraphics.CGRect) -> Swift.Bool
  @objc override dynamic open func targetContentOffset(forProposedContentOffset proposedContentOffset: CoreGraphics.CGPoint) -> CoreGraphics.CGPoint
  @objc override dynamic public init()
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@_inheritsConvenienceInitializers final public class OnboardingPreviewScene : Dialog_iOS.Scene<Swift.Void, UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.OnboardingPreviewScene.Builder
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<Swift.Void, UIKit.UIViewController, Dialog_iOS.OnboardingPreviewViewModelProtocol> {
    override final public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>) -> Dialog_iOS.OnboardingPreviewViewModelProtocol
    override final public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>, viewModel: Dialog_iOS.OnboardingPreviewViewModelProtocol) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<Swift.Void, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
public protocol OnboardingPreviewViewControllerDesignProtocol {
  var indicatorStyle: UIKit.UIActivityIndicatorView.Style { get }
  var activityIndicatorTransform: CoreGraphics.CGFloat { get }
  var backgroundColor: UIKit.UIColor { get }
}
public struct OnboardingPreviewViewControllerDefaultStyle : Dialog_iOS.OnboardingPreviewViewControllerDesignProtocol {
  public let indicatorStyle: UIKit.UIActivityIndicatorView.Style
  public let activityIndicatorTransform: CoreGraphics.CGFloat
  public let backgroundColor: UIKit.UIColor
}
@objc @_hasMissingDesignatedInitializers final public class OnboardingPreviewViewController : UIKit.UIViewController {
  final public var viewModel: Dialog_iOS.OnboardingPreviewViewModelProtocol
  public init(viewModel vm: Dialog_iOS.OnboardingPreviewViewModelProtocol, design: Dialog_iOS.OnboardingPreviewViewControllerDesignProtocol)
  @objc override final public func viewDidLoad()
  final public func bind(to viewModel: Dialog_iOS.OnboardingPreviewViewModelProtocol)
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc deinit
}
extension OnboardingPreviewViewController : WebKit.WKNavigationDelegate {
  @objc final public func webView(_ webView: WebKit.WKWebView, didFinish navigation: WebKit.WKNavigation!)
}
public protocol OnboardingPreviewViewModelProtocol : AnyObject {
  var title: RxCocoa.Driver<Swift.String> { get }
  var settingsVersion: RxCocoa.Driver<Swift.String?> { get }
  var featureFlagsVersion: RxCocoa.Driver<Swift.String?> { get }
  var featureFlagsUrl: RxCocoa.Driver<Swift.String?> { get }
}
final public class OnboardingPreviewViewModel : Dialog_iOS.OnboardingPreviewViewModelProtocol {
  final public let title: RxCocoa.Driver<Swift.String>
  final public let featureFlagsUrl: RxCocoa.Driver<Swift.String?>
  final public let settingsVersion: RxCocoa.Driver<Swift.String?>
  final public let featureFlagsVersion: RxCocoa.Driver<Swift.String?>
  public init(configService: DialogProtocols.SettingsConfigServiceProtocol, onboardingService: Dialog_iOS.OnboardingServiceProtocol)
  @objc deinit
}
@_inheritsConvenienceInitializers final public class OnboardingScene : Dialog_iOS.Scene<Swift.Void, UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.OnboardingScene.Builder
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<Swift.Void, UIKit.UIViewController, Dialog_iOS.OnboardingViewModelProtocol> {
    override final public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>) -> Dialog_iOS.OnboardingViewModelProtocol
    override final public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>, viewModel: Dialog_iOS.OnboardingViewModelProtocol) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<Swift.Void, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
public protocol OnboardingServiceProtocol : AnyObject {
  var shouldSetupAgree: RxSwift.AnyObserver<Swift.Bool> { get }
  var requestIsRequired: RxSwift.Observable<Swift.Bool?> { get }
  var settingsVersion: RxSwift.Observable<Swift.String?> { get }
  var featureFlagsVersion: RxSwift.Observable<Swift.String?> { get }
  var featureFlagsUrl: RxSwift.Observable<Swift.String?> { get }
  var agree: RxSwift.Observable<Swift.Bool> { get }
}
public class OnboardingService : Dialog_iOS.OnboardingServiceProtocol {
  final public let requestIsRequired: RxSwift.Observable<Swift.Bool?>
  final public let settingsVersion: RxSwift.Observable<Swift.String?>
  final public let featureFlagsVersion: RxSwift.Observable<Swift.String?>
  final public let featureFlagsUrl: RxSwift.Observable<Swift.String?>
  final public let agree: RxSwift.Observable<Swift.Bool>
  final public let shouldSetupAgree: RxSwift.AnyObserver<Swift.Bool>
  public init(featureFlagsService: DialogProtocols.DialogFeatureFlagsServiceProtocol, configService: DialogProtocols.SettingsConfigServiceProtocol, eventBus: DialogProtocols.EventBusServiceProtocol)
  @objc deinit
}
public protocol OnboardingViewControllerDesignProtocol {
  var indicatorStyle: UIKit.UIActivityIndicatorView.Style { get }
  var buttonFont: UIKit.UIFont { get }
  var titleFont: UIKit.UIFont { get }
  var titleColor: UIKit.UIColor { get }
  var cancelButtonColor: UIKit.UIColor { get }
  var acceptButtonColor: UIKit.UIColor { get }
  var highlightedButtonColor: UIKit.UIColor { get }
  var buttonHeight: CoreGraphics.CGFloat { get }
  var buttonWidth: CoreGraphics.CGFloat { get }
  var activityIndicatorTransform: CoreGraphics.CGFloat { get }
  var backgroundColor: UIKit.UIColor { get }
}
public struct OnboardingViewControllerDefaultStyle : Dialog_iOS.OnboardingViewControllerDesignProtocol {
  public let titleColor: UIKit.UIColor
  public let cancelButtonColor: UIKit.UIColor
  public let acceptButtonColor: UIKit.UIColor
  public let highlightedButtonColor: UIKit.UIColor
  public let indicatorStyle: UIKit.UIActivityIndicatorView.Style
  public let buttonFont: UIKit.UIFont
  public let titleFont: UIKit.UIFont
  public let buttonHeight: CoreGraphics.CGFloat
  public let buttonWidth: CoreGraphics.CGFloat
  public let activityIndicatorTransform: CoreGraphics.CGFloat
  public let backgroundColor: UIKit.UIColor
}
@objc @_hasMissingDesignatedInitializers final public class OnboardingViewController : UIKit.UIViewController {
  final public var viewModel: Dialog_iOS.OnboardingViewModelProtocol
  public init(viewModel vm: Dialog_iOS.OnboardingViewModelProtocol, design: Dialog_iOS.OnboardingViewControllerDesignProtocol)
  @objc override final public func viewDidLoad()
  @objc override final public var preferredStatusBarStyle: UIKit.UIStatusBarStyle {
    @objc get
  }
  final public func bind(to viewModel: Dialog_iOS.OnboardingViewModelProtocol)
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc deinit
}
extension OnboardingViewController : WebKit.WKNavigationDelegate {
  @objc final public func webView(_ webView: WebKit.WKWebView, didFinish navigation: WebKit.WKNavigation!)
}
public protocol OnboardingViewModelProtocol : AnyObject {
  var title: RxCocoa.Driver<Swift.String> { get }
  var cancelTitle: RxCocoa.Driver<Swift.String> { get }
  var continueTitle: RxCocoa.Driver<Swift.String> { get }
  var settingsVersion: RxCocoa.Driver<Swift.String?> { get }
  var featureFlagsVersion: RxCocoa.Driver<Swift.String?> { get }
  var featureFlagsUrl: RxCocoa.Driver<Swift.String?> { get }
  var channelState: RxCocoa.Driver<SwiftGRPC.Channel.ConnectivityState> { get }
  var cancelButtonDidTap: RxSwift.AnyObserver<Swift.Void> { get }
  var continueButtonDidTap: RxSwift.AnyObserver<Swift.Void> { get }
}
final public class OnboardingViewModel : Dialog_iOS.OnboardingViewModelProtocol {
  final public let title: RxCocoa.Driver<Swift.String>
  final public let cancelTitle: RxCocoa.Driver<Swift.String>
  final public let continueTitle: RxCocoa.Driver<Swift.String>
  final public let featureFlagsUrl: RxCocoa.Driver<Swift.String?>
  final public let settingsVersion: RxCocoa.Driver<Swift.String?>
  final public let featureFlagsVersion: RxCocoa.Driver<Swift.String?>
  final public let channelState: RxCocoa.Driver<SwiftGRPC.Channel.ConnectivityState>
  final public let cancelButtonDidTap: RxSwift.AnyObserver<Swift.Void>
  final public let continueButtonDidTap: RxSwift.AnyObserver<Swift.Void>
  public init(configService: DialogProtocols.SettingsConfigServiceProtocol, onboardingService: Dialog_iOS.OnboardingServiceProtocol, channelService: DialogProtocols.DialogChannelServiceProtocol)
  @objc deinit
}
extension DialogFeatureFlag.Key {
  public static let confidentialPolicyURL: DialogProtocols.DialogFeatureFlag.Key
  public static let confidentialPolicyVersion: DialogProtocols.DialogFeatureFlag.Key
}
public protocol OneTextFieldViewProtocol : UIKit.UIView {
  static func createForViewController(_ viewController: UIKit.UIViewController) -> Self
  var textFieldView: Dialog_iOS.TextField! { get }
  var subtitleLabel: UIKit.UILabel! { get }
}
@objc @_inheritsConvenienceInitializers final public class OneTextFieldView : UIKit.UIView, Dialog_iOS.OneTextFieldViewProtocol, Dialog_iOS.Identifiable {
  @objc @IBOutlet final public var textFieldView: Dialog_iOS.TextField! {
    get
  }
  @objc @IBOutlet final public var subtitleLabel: UIKit.UILabel! {
    get
  }
  final public class func createForViewController(_ viewController: UIKit.UIViewController) -> Dialog_iOS.OneTextFieldView
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public enum OneTextFieldViewModelLoadingState {
  case noLoading
  case loading(details: Swift.String?)
  public var isLoading: Swift.Bool {
    get
  }
}
public enum ContextedText {
  case none
  case details(Swift.String)
  case warning(Swift.String)
  case error(Swift.String)
  public var string: Swift.String? {
    get
  }
}
public protocol OneTextFieldViewModelProtocol : Dialog_iOS.ViewModelProtocol {
  var action: RxSwift.AnyObserver<Swift.Void> { get }
  var textFieldInput: RxSwift.AnyObserver<Swift.String?> { get }
  var textFieldValidationResult: RxSwift.AnyObserver<Dialog_iOS.TextValidationResult> { get }
  var textFieldConfigurator: Dialog_iOS.TextFieldRxConfigurator<Dialog_iOS.TextField> { get }
  var detailsLabelConfigurator: Dialog_iOS.LabelRxConfigurator<UIKit.UILabel> { get }
  var canGoNext: RxCocoa.Driver<Swift.Bool> { get }
  var loadingState: RxCocoa.Driver<Dialog_iOS.OneTextFieldViewModelLoadingState> { get }
}
@objc public class OneTextFieldViewViewController : UIKit.UIViewController {
  public typealias VM = Dialog_iOS.OneTextFieldViewModelProtocol
  final public let viewModel: Dialog_iOS.OneTextFieldViewViewController.VM
  public var customView: Dialog_iOS.OneTextFieldView! {
    get
  }
  required public init(viewModel: Dialog_iOS.OneTextFieldViewViewController.VM)
  @objc override dynamic public func loadView()
  @objc override dynamic public func viewDidLoad()
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  public func bind(to viewModel: Dialog_iOS.OneTextFieldViewViewController.VM)
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc deinit
}
extension OptionSet where Self.RawValue : Swift.FixedWidthInteger {
  public func elements() -> Swift.AnySequence<Self>
}
public protocol PasswordValidationServiceProtocol {
  func validate(password: Swift.String, useRegExp: Swift.Bool) -> Dialog_iOS.PasswordValidationServiceResult
}
public enum PasswordValidationServiceResult : Swift.Equatable {
  case valid
  case invalid(reason: Swift.String)
  public var isValid: Swift.Bool {
    get
  }
  public static func == (a: Dialog_iOS.PasswordValidationServiceResult, b: Dialog_iOS.PasswordValidationServiceResult) -> Swift.Bool
}
final public class PhoneFormatter : Dialog_iOS.TextFormatterProtocol {
  public init(kit: PhoneNumberKit.PhoneNumberKit = PhoneNumberKit())
  final public var formattingRequired: Swift.Bool {
    get
  }
  final public func format<R>(replacement: Swift.String, in string: Swift.String?, at range: R) -> Dialog_iOS.TextFormatResult where R : Swift.RangeExpression, R.Bound == Swift.String.Index
  @objc deinit
}
public enum PhoneValidationError : Foundation.LocalizedError {
  case undefined
  case lengthTooSmall
  case lengthTooBig
  case invalidCharacters
  case incorrectNumber
  public var errorDescription: Swift.String? {
    get
  }
  public var localizedDescription: Swift.String {
    get
  }
  public static func == (a: Dialog_iOS.PhoneValidationError, b: Dialog_iOS.PhoneValidationError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
final public class PhoneValidator : Dialog_iOS.TextValidatorProtocol {
  public init(kit: PhoneNumberKit.PhoneNumberKit = PhoneNumberKit())
  final public func validate(text: Swift.String) throws
  @objc deinit
}
public protocol PhotoMessageCellDesignProtocol : Dialog_iOS.MessageContentDesignProtocol {
  var messageMaxPhotoHeight: CoreGraphics.CGFloat { get }
  var undefinedPhotoSize: CoreGraphics.CGSize { get }
  var minCellHeight: CoreGraphics.CGFloat { get }
}
public protocol PickerFactoryProtocol {
  func getTelegramPicker() -> Dialog_iOS.PickerPresentableRx
  func getPicker() -> Dialog_iOS.PickerWrapperViewController
}
public struct PickerData {
}
public struct PickerItem : Swift.Hashable {
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Dialog_iOS.PickerItem, b: Dialog_iOS.PickerItem) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class PickerWrapperViewController : Dialog_iOS.PresentWrapperViewController {
  override public init(parentWindow: UIKit.UIWindow?)
  public func showPicker(with data: Dialog_iOS.PickerData, handler: @escaping ((Dialog_iOS.PickerItem) -> Swift.Void))
  @objc deinit
}
public struct Platform {
  public static var isSimulator: Swift.Bool {
    get
  }
}
public protocol PreferredRegionServiceProtocol {
  func setRegion(code: Swift.String)
  var preferredRegion: RxSwift.Observable<Swift.String?> { get }
}
@_hasMissingDesignatedInitializers final public class PreferredRegionService : Dialog_iOS.PreferredRegionServiceProtocol {
  final public var preferredRegion: RxSwift.Observable<Swift.String?> {
    get
  }
  final public func setRegion(code: Swift.String)
  @objc deinit
}
extension UIWindow.Level {
  public static let alertsPicker: UIKit.UIWindow.Level
}
@objc @_hasMissingDesignatedInitializers public class PresentWrapperViewController : UIKit.UIViewController {
  public init(parentWindow: UIKit.UIWindow?)
  @objc deinit
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
}
public enum PrivateProfileRoute : XCoordinator.Route {
  case initial
  case `default`
  public static func == (a: Dialog_iOS.PrivateProfileRoute, b: Dialog_iOS.PrivateProfileRoute) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public typealias PrivateProfileRouter = XCoordinator.WeakRouter<Dialog_iOS.PrivateProfileRoute>
public typealias AnyPrivateProfileCoordinator = Dialog_iOS.PrivateProfileCoordinator.AnyCoordinatorType
final public class PrivateProfileCoordinator : XCoordinator.NavigationCoordinator<Dialog_iOS.PrivateProfileRoute> {
  override final public var viewController: UIKit.UIViewController! {
    get
  }
  public init(container: Swinject.Container, rootViewController: UIKit.UINavigationController)
  override final public func prepareTransition(for route: Dialog_iOS.PrivateProfileRoute) -> XCoordinator.NavigationTransition
  override public init(rootViewController: XCoordinator.NavigationCoordinator<Dialog_iOS.PrivateProfileRoute>.RootViewController = super, initialRoute: Dialog_iOS.PrivateProfileRoute? = super)
  override public init(rootViewController: XCoordinator.NavigationCoordinator<Dialog_iOS.PrivateProfileRoute>.RootViewController = super, root: XCoordinator.Presentable)
  @objc deinit
}
public class PrivateProfileEditingHeaderViewModel : Dialog_iOS.DUICellViewModel, Dialog_iOS.AvatarNodeModelProtocol {
  public var route: Dialog_iOS.GeneralSettingsRoute
  final public let userAvatarBasicColor: RxCocoa.Driver<UIKit.UIColor>
  final public let avatarCenterText: RxSwift.Observable<Swift.String?>
  final public let avatarImage: RxSwift.Observable<UIKit.UIImage?>
  public var avatarNodeDidTapped: RxRelay.PublishRelay<Swift.Void>
  final public let text: RxRelay.BehaviorRelay<Swift.String?>
  final public let didSelectCell: RxSwift.PublishSubject<UIKit.UITapGestureRecognizer>
  final public let handlePickerSelecting: RxSwift.AnyObserver<Dialog_iOS.ChangeAvatarResult>
  final public let isEditable: RxCocoa.Driver<Swift.Bool>
  public var validationViewTextAndHighlightStatus: RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, (Swift.String?, Swift.Bool)>
  final public let showActivityIndicator: RxCocoa.Driver<Swift.Bool>
  public init(myUserResolver: Dialog_iOS.MyUserResolverProtocol, textRelay: RxRelay.BehaviorRelay<Swift.String?>, isEditable: RxRelay.BehaviorRelay<Swift.Bool>, fileService: DialogFiles.DialogFileServiceProtocol, profileService: DialogProtocols.PrivateProfileServiceProtocol, uploadService: DialogFiles.DialogUploadFileServiceProtocol, assetService: Dialog_iOS.AssetsServiceProtocol, colorService: Dialog_iOS.DialogPeerColorsServiceProtocol, validationError: RxCocoa.Driver<Dialog_iOS.DTextValidator.Output>? = nil)
  @objc deinit
  override public init(identity: Dialog_iOS.DUICellViewModelIdentity)
}
@_inheritsConvenienceInitializers final public class PrivateProfileScene : Dialog_iOS.Scene<Swift.Void, UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.PrivateProfileScene.Builder
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<Swift.Void, UIKit.UIViewController, Dialog_iOS.PrivateProfileViewModel> {
    override final public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>) -> Dialog_iOS.PrivateProfileViewModel
    override final public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Swift.Void>, viewModel: Dialog_iOS.PrivateProfileViewModel) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<Swift.Void, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
public class PrivateProfileViewModel {
  final public let sections: RxCocoa.Driver<[Dialog_iOS.DUIFooteredSection]>
  public init(myUserResolver: Dialog_iOS.MyUserResolverProtocol, routerService: Dialog_iOS.RouterServiceProtocol, eventBusService: DialogProtocols.EventBusServiceProtocol, fileService: DialogFiles.DialogFileServiceProtocol, uploadService: DialogFiles.DialogUploadFileServiceProtocol, profileService: DialogProtocols.PrivateProfileServiceProtocol, userService: DialogProtocols.DialogUserServiceProtocol, assetsService: Dialog_iOS.AssetsServiceProtocol, colorService: Dialog_iOS.DialogPeerColorsServiceProtocol)
  @objc deinit
}
public protocol ProfileActionCellStyleProtocol : Dialog_iOS.ProfileCellStyleProtocol {
  var iconSize: CoreGraphics.CGSize { get }
  var insets: UIKit.UIEdgeInsets { get }
  var spacing: CoreGraphics.CGFloat { get }
  var titleAttributesText: [Foundation.NSAttributedString.Key : Any]? { get }
}
extension ProfileActionCellStyleProtocol {
  public var iconSize: CoreGraphics.CGSize {
    get
  }
  public var insets: UIKit.UIEdgeInsets {
    get
  }
  public var spacing: CoreGraphics.CGFloat {
    get
  }
  public var titleAttributesText: [Foundation.NSAttributedString.Key : Any]? {
    get
  }
  public var activityIndicatiorSize: CoreGraphics.CGSize {
    get
  }
}
public struct ProfileActionCellDefaultStyle : Dialog_iOS.ProfileActionCellStyleProtocol {
  public let iconSize: CoreGraphics.CGSize
  public let insets: UIKit.UIEdgeInsets
  public let spacing: CoreGraphics.CGFloat
  public var titleAttributesText: [Foundation.NSAttributedString.Key : Any]?
}
public struct ProfileActionCellDestructiveStyle : Dialog_iOS.ProfileActionCellStyleProtocol {
  public let iconSize: CoreGraphics.CGSize
  public let insets: UIKit.UIEdgeInsets
  public let spacing: CoreGraphics.CGFloat
  public var titleAttributesText: [Foundation.NSAttributedString.Key : Any]?
}
@objc public class ProfileActionCell : AsyncDisplayKit.ASCellNode {
  public init(viewModel: Dialog_iOS.ProfileActionCellViewModelProtocol, style: Dialog_iOS.ProfileActionCellStyleProtocol)
  @objc override dynamic public func didLoad()
  @objc override dynamic public func layoutSpecThatFits(_ constrainedSize: AsyncDisplayKit.ASSizeRange) -> AsyncDisplayKit.ASLayoutSpec
  @objc deinit
  @objc override dynamic public init(viewControllerBlock: @escaping AsyncDisplayKit.ASDisplayNodeViewControllerBlock, didLoad didLoadBlock: AsyncDisplayKit.ASDisplayNodeDidLoadBlock? = nil)
  @objc override dynamic public init()
}
public protocol ProfileDestructiveActionCellViewModelProtocol : Dialog_iOS.ProfileActionCellViewModelProtocol {
}
public protocol ProfileActionCellViewModelProtocol : Dialog_iOS.ProfileCellViewModelProtocol {
  var title: RxCocoa.Driver<Swift.String> { get }
  var icon: RxCocoa.Driver<UIKit.UIImage?>? { get }
  var inProgress: RxCocoa.Driver<Swift.Bool> { get }
}
@_inheritsConvenienceInitializers public class ProfileDestructiveActionCellViewModel : Dialog_iOS.ProfileActionCellViewModel, Dialog_iOS.ProfileDestructiveActionCellViewModelProtocol {
  @objc deinit
  override public init(type: Swift.Int, title: Swift.String, icon: UIKit.UIImage? = super, inProgress: RxCocoa.Driver<Swift.Bool> = super, themeService: Dialog_iOS.AppThemeService)
  override public init(type: Swift.Int, title: RxCocoa.Driver<Swift.String>, icon: RxCocoa.Driver<UIKit.UIImage?>? = super, inProgress: RxCocoa.Driver<Swift.Bool> = super, themeService: Dialog_iOS.AppThemeService)
}
public class ProfileActionCellViewModel : Dialog_iOS.ProfileCellViewModel, Dialog_iOS.ProfileActionCellViewModelProtocol {
  final public let title: RxCocoa.Driver<Swift.String>
  final public let icon: RxCocoa.Driver<UIKit.UIImage?>?
  final public let inProgress: RxCocoa.Driver<Swift.Bool>
  public init(type: Swift.Int, title: Swift.String, icon: UIKit.UIImage? = nil, inProgress: RxCocoa.Driver<Swift.Bool> = Driver.just(false), themeService: Dialog_iOS.AppThemeService)
  public init(type: Swift.Int, title: RxCocoa.Driver<Swift.String>, icon: RxCocoa.Driver<UIKit.UIImage?>? = nil, inProgress: RxCocoa.Driver<Swift.Bool> = Driver.just(false), themeService: Dialog_iOS.AppThemeService)
  override public init(type: Swift.Int, themeService: Dialog_iOS.AppThemeService)
  @objc deinit
}
public protocol ProfileBoolCellStyleProtocol : Dialog_iOS.ProfileCellStyleProtocol {
  var iconSize: CoreGraphics.CGSize { get }
  var spacing: CoreGraphics.CGFloat { get }
  var insets: UIKit.UIEdgeInsets { get }
  var titleAttributesText: [Foundation.NSAttributedString.Key : Any] { get }
  var primaryColor: UIKit.UIColor { get }
  var disabledColor: UIKit.UIColor { get }
}
public struct ProfileBoolCellDefaultStyle : Dialog_iOS.ProfileBoolCellStyleProtocol {
  public var iconSize: CoreGraphics.CGSize
  public let spacing: CoreGraphics.CGFloat
  public let insets: UIKit.UIEdgeInsets
  public var titleAttributesText: [Foundation.NSAttributedString.Key : Any]
  public let primaryColor: UIKit.UIColor
  public let disabledColor: UIKit.UIColor
}
@objc public class ProfileBoolCell : AsyncDisplayKit.ASCellNode {
  final public let profileStyle: Dialog_iOS.ProfileBoolCellStyleProtocol
  public init(viewModel: Dialog_iOS.ProfileBoolCellViewModelProtocol, style: Dialog_iOS.ProfileBoolCellStyleProtocol)
  @objc override dynamic public func layoutSpecThatFits(_ constrainedSize: AsyncDisplayKit.ASSizeRange) -> AsyncDisplayKit.ASLayoutSpec
  @objc deinit
  @objc override dynamic public init(viewControllerBlock: @escaping AsyncDisplayKit.ASDisplayNodeViewControllerBlock, didLoad didLoadBlock: AsyncDisplayKit.ASDisplayNodeDidLoadBlock? = nil)
  @objc override dynamic public init()
}
public protocol ProfileBoolCellViewModelProtocol : Dialog_iOS.ProfileCellViewModelProtocol {
  var title: Swift.String { get }
  var icon: UIKit.UIImage? { get }
  var on: Swift.Bool { get }
}
public class ProfileBoolCellViewModel : Dialog_iOS.ProfileCellViewModel, Dialog_iOS.ProfileBoolCellViewModelProtocol {
  final public let title: Swift.String
  final public let icon: UIKit.UIImage?
  final public let on: Swift.Bool
  required public init(type: Swift.Int, title: Swift.String, icon: UIKit.UIImage?, on: Swift.Bool, themeService: Dialog_iOS.AppThemeService)
  @objc deinit
  override public init(type: Swift.Int, themeService: Dialog_iOS.AppThemeService)
}
public protocol ProfileCallAndMessageCellStyleProtocol : Dialog_iOS.ProfileCellStyleProtocol {
  var callIcon: UIKit.UIImage { get }
  var messageIcon: UIKit.UIImage { get }
  var iconBackgroundColor: UIKit.UIColor { get }
  var contentInsets: UIKit.UIEdgeInsets { get }
  var buttonInsents: UIKit.UIEdgeInsets { get }
  var roundSize: CoreGraphics.CGSize { get }
  var spacing: CoreGraphics.CGFloat { get }
  var borderWidth: CoreGraphics.CGFloat { get }
  var buttonRoundRect: CoreGraphics.CGFloat { get }
  var buttonHeight: AsyncDisplayKit.ASDimension { get }
}
public struct ProfileCallAndMessageCellDefaultStyle : Dialog_iOS.ProfileCallAndMessageCellStyleProtocol {
  public let separatorInsets: UIKit.UIEdgeInsets
  public let callIcon: UIKit.UIImage
  public let messageIcon: UIKit.UIImage
  public var iconBackgroundColor: UIKit.UIColor {
    get
  }
  public let contentInsets: UIKit.UIEdgeInsets
  public let buttonInsents: UIKit.UIEdgeInsets
  public let roundSize: CoreGraphics.CGSize
  public let iconSize: CoreGraphics.CGSize
  public let spacing: CoreGraphics.CGFloat
  public let borderWidth: CoreGraphics.CGFloat
  public let buttonRoundRect: CoreGraphics.CGFloat
  public let buttonHeight: AsyncDisplayKit.ASDimension
}
@objc public class ProfileCallAndMessageCell : AsyncDisplayKit.ASCellNode {
  public init(viewModel: Dialog_iOS.ProfileCallAndMessageCellViewModelProtocol, style: Dialog_iOS.ProfileCallAndMessageCellStyleProtocol)
  @objc override dynamic public func didLoad()
  @objc override dynamic public func layoutSpecThatFits(_ constrainedSize: AsyncDisplayKit.ASSizeRange) -> AsyncDisplayKit.ASLayoutSpec
  @objc deinit
  @objc override dynamic public init(viewControllerBlock: @escaping AsyncDisplayKit.ASDisplayNodeViewControllerBlock, didLoad didLoadBlock: AsyncDisplayKit.ASDisplayNodeDidLoadBlock? = nil)
  @objc override dynamic public init()
}
public protocol ProfileCallAndMessageCellViewModelProtocol : Dialog_iOS.ProfileCellViewModelProtocol {
  var callAction: RxSwift.AnyObserver<Swift.Void> { get }
  var openDialogAction: RxSwift.AnyObserver<Swift.Void> { get }
  var callButtonTitle: Swift.String { get }
  var messageButtonTitle: Swift.String { get }
  var isCallButtonEnabled: RxSwift.Observable<Swift.Bool> { get }
}
public class ProfileCallAndMessageCellViewModel : Dialog_iOS.ProfileCellViewModel, Dialog_iOS.ProfileCallAndMessageCellViewModelProtocol {
  final public let callAction: RxSwift.AnyObserver<Swift.Void>
  final public let openDialogAction: RxSwift.AnyObserver<Swift.Void>
  final public let callButtonTitle: Swift.String
  final public let messageButtonTitle: Swift.String
  final public let isCallButtonEnabled: RxSwift.Observable<Swift.Bool>
  required public init(type: Swift.Int, callAction: RxSwift.AnyObserver<Swift.Void>, callsEnabled: RxSwift.Observable<Swift.Bool>, openDialogAction: RxSwift.AnyObserver<Swift.Void>, callsService: DialogCalls.CallsServiceProtocol, userId: DialogProtocols.DialogUserId, themeService: Dialog_iOS.AppThemeService)
  @objc deinit
  override public init(type: Swift.Int, themeService: Dialog_iOS.AppThemeService)
}
public protocol ProfileCellStyleProtocol {
  var separatorInsets: UIKit.UIEdgeInsets { get }
}
extension ProfileCellStyleProtocol {
  public var separatorInsets: UIKit.UIEdgeInsets {
    get
  }
  public var hiddenSeparatorInsets: UIKit.UIEdgeInsets {
    get
  }
}
public protocol ProfileCellViewModelProtocol {
  var selectAction: RxSwift.AnyObserver<Swift.Void>? { get }
  var menuAction: RxSwift.AnyObserver<Swift.Void>? { get }
  var generalColor: RxCocoa.Driver<UIKit.UIColor> { get }
}
public class ProfileCellViewModel : Dialog_iOS.ProfileCellViewModelProtocol, Differentiator.IdentifiableType, Swift.Equatable {
  public var selectAction: RxSwift.AnyObserver<Swift.Void>?
  public var menuAction: RxSwift.AnyObserver<Swift.Void>?
  final public let generalColor: RxCocoa.Driver<UIKit.UIColor>
  public typealias Identity = Swift.Int
  public var identity: Swift.Int
  public init(type: Swift.Int, themeService: Dialog_iOS.AppThemeService)
  public static func == (lhs: Dialog_iOS.ProfileCellViewModel, rhs: Dialog_iOS.ProfileCellViewModel) -> Swift.Bool
  @objc deinit
}
public protocol ProfileFavouritesCellViewModelProtocol : Dialog_iOS.ProfileActionCellViewModelProtocol {
}
public class ProfileFavouritesCellViewModel : Dialog_iOS.ProfileActionCellViewModel, Dialog_iOS.ProfileFavouritesCellViewModelProtocol {
  required public init(type: Swift.Int, peerId: Swift.Int32, eventBusService: DialogProtocols.EventBusServiceProtocol, themeService: Dialog_iOS.AppThemeService)
  @objc deinit
  override public init(type: Swift.Int, title: Swift.String, icon: UIKit.UIImage? = super, inProgress: RxCocoa.Driver<Swift.Bool> = super, themeService: Dialog_iOS.AppThemeService)
  override public init(type: Swift.Int, title: RxCocoa.Driver<Swift.String>, icon: RxCocoa.Driver<UIKit.UIImage?>? = super, inProgress: RxCocoa.Driver<Swift.Bool> = super, themeService: Dialog_iOS.AppThemeService)
}
public protocol ProfileHeaderCellStyleProtocol : Dialog_iOS.ProfileCellStyleProtocol {
  var contentInsets: UIKit.UIEdgeInsets { get }
  var backgroundColor: UIKit.UIColor { get }
}
public struct ProfileHeaderCellDefaultStyle : Dialog_iOS.ProfileHeaderCellStyleProtocol {
  public var separatorInsets: UIKit.UIEdgeInsets {
    get
  }
  public let contentInsets: UIKit.UIEdgeInsets
  public let backgroundColor: UIKit.UIColor
}
@objc public class ProfileHeaderCell : AsyncDisplayKit.ASCellNode {
  final public let profileNode: Dialog_iOS.ProfileHeaderNode
  final public let profileStyle: Dialog_iOS.ProfileHeaderCellStyleProtocol
  public init(viewModel: Dialog_iOS.ProfileHeaderCellViewModelProtocol, style: Dialog_iOS.ProfileHeaderCellStyleProtocol)
  @objc override dynamic public func layoutSpecThatFits(_ constrainedSize: AsyncDisplayKit.ASSizeRange) -> AsyncDisplayKit.ASLayoutSpec
  @objc deinit
  @objc override dynamic public init(viewControllerBlock: @escaping AsyncDisplayKit.ASDisplayNodeViewControllerBlock, didLoad didLoadBlock: AsyncDisplayKit.ASDisplayNodeDidLoadBlock? = nil)
  @objc override dynamic public init()
}
public protocol ProfileHeaderCellViewModelProtocol : Dialog_iOS.AvatarNodeModelProtocol, Dialog_iOS.ProfileCellViewModelProtocol, Dialog_iOS.ViewModelProtocol {
  var title: RxCocoa.Driver<Swift.String> { get }
}
public protocol ProfileHeaderNodeDesignProtocol {
  var backgroundColor: UIKit.UIColor { get }
  var titleAttributes: [Foundation.NSAttributedString.Key : Any] { get }
  var statusAttributes: [Foundation.NSAttributedString.Key : Any] { get }
  var avatarSize: CoreGraphics.CGSize { get }
  var spacing: CoreGraphics.CGFloat { get }
}
public struct ProfileHeaderNodeDesign : Dialog_iOS.ProfileHeaderNodeDesignProtocol {
  public let backgroundColor: UIKit.UIColor
  public let titleAttributes: [Foundation.NSAttributedString.Key : Any]
  public let statusAttributes: [Foundation.NSAttributedString.Key : Any]
  public let avatarSize: CoreGraphics.CGSize
  public let spacing: CoreGraphics.CGFloat
}
@objc public class ProfileHeaderNode : AsyncDisplayKit.ASDisplayNode {
  final public let viewModel: Dialog_iOS.ProfileHeaderCellViewModelProtocol
  final public let design: Dialog_iOS.ProfileHeaderNodeDesignProtocol
  final public let avatarNode: Dialog_iOS.AvatarNode
  final public let nameNode: AsyncDisplayKit.ASTextNode
  public init(viewModel: Dialog_iOS.ProfileHeaderCellViewModelProtocol, design: Dialog_iOS.ProfileHeaderNodeDesignProtocol)
  @objc override dynamic public func didLoad()
  public func layoutHeadLeftNode(_ constrainedSize: AsyncDisplayKit.ASSizeRange) -> AsyncDisplayKit.ASLayoutSpec
  public func layoutHeadRightNode(_ constrainedSize: AsyncDisplayKit.ASSizeRange) -> AsyncDisplayKit.ASLayoutSpec
  public func layoutHeadNode(_ constrainedSize: AsyncDisplayKit.ASSizeRange) -> AsyncDisplayKit.ASLayoutSpec
  @objc override dynamic public func layoutSpecThatFits(_ constrainedSize: AsyncDisplayKit.ASSizeRange) -> AsyncDisplayKit.ASLayoutSpec
  @objc override dynamic public init()
  @objc deinit
}
public struct ProfileOpenDetailsCellDefaultStyle : Dialog_iOS.ProfileActionCellStyleProtocol {
  public var titleAttributesText: [Foundation.NSAttributedString.Key : Any]?
}
@objc @_inheritsConvenienceInitializers public class ProfileOpenDetailsCell : Dialog_iOS.ProfileActionCell {
  override public init(viewModel: Dialog_iOS.ProfileActionCellViewModelProtocol, style: Dialog_iOS.ProfileActionCellStyleProtocol)
  @objc deinit
}
public protocol ProfileOpenDetailsCellViewModelProtocol : Dialog_iOS.ProfileActionCellViewModelProtocol {
}
@_inheritsConvenienceInitializers public class ProfileOpenDetailsCellViewModel : Dialog_iOS.ProfileActionCellViewModel, Dialog_iOS.ProfileOpenDetailsCellViewModelProtocol {
  @objc deinit
  override public init(type: Swift.Int, title: Swift.String, icon: UIKit.UIImage? = super, inProgress: RxCocoa.Driver<Swift.Bool> = super, themeService: Dialog_iOS.AppThemeService)
  override public init(type: Swift.Int, title: RxCocoa.Driver<Swift.String>, icon: RxCocoa.Driver<UIKit.UIImage?>? = super, inProgress: RxCocoa.Driver<Swift.Bool> = super, themeService: Dialog_iOS.AppThemeService)
}
public struct ProfileShowMoreCellDefaultStyle : Dialog_iOS.ProfileActionCellStyleProtocol {
  public var titleAttributesText: [Foundation.NSAttributedString.Key : Any]?
}
@objc @_inheritsConvenienceInitializers public class ProfileShowMoreCell : Dialog_iOS.ProfileActionCell {
  override public init(viewModel: Dialog_iOS.ProfileActionCellViewModelProtocol, style: Dialog_iOS.ProfileActionCellStyleProtocol)
  @objc override dynamic public func layoutSpecThatFits(_ constrainedSize: AsyncDisplayKit.ASSizeRange) -> AsyncDisplayKit.ASLayoutSpec
  @objc deinit
}
public protocol ProfileShowMoreCellViewModelProtocol : Dialog_iOS.ProfileActionCellViewModelProtocol {
}
@_inheritsConvenienceInitializers public class ProfileShowMoreCellViewModel : Dialog_iOS.ProfileActionCellViewModel, Dialog_iOS.ProfileShowMoreCellViewModelProtocol {
  @objc deinit
  override public init(type: Swift.Int, title: Swift.String, icon: UIKit.UIImage? = super, inProgress: RxCocoa.Driver<Swift.Bool> = super, themeService: Dialog_iOS.AppThemeService)
  override public init(type: Swift.Int, title: RxCocoa.Driver<Swift.String>, icon: RxCocoa.Driver<UIKit.UIImage?>? = super, inProgress: RxCocoa.Driver<Swift.Bool> = super, themeService: Dialog_iOS.AppThemeService)
}
public protocol ProfileSpaceCellStyleProtocol : Dialog_iOS.ProfileCellStyleProtocol {
  var height: CoreGraphics.CGFloat { get }
}
public struct ProfileSpaceCellDefaultStyle : Dialog_iOS.ProfileSpaceCellStyleProtocol {
  public let height: CoreGraphics.CGFloat
  public var separatorInsets: UIKit.UIEdgeInsets {
    get
  }
}
@objc public class ProfileSpaceCell : AsyncDisplayKit.ASCellNode {
  final public let cellStyle: Dialog_iOS.ProfileSpaceCellStyleProtocol
  final public let spaceNode: AsyncDisplayKit.ASDisplayNode
  public init(viewModel: Dialog_iOS.ProfileSpaceCellViewModelProtocol, style: Dialog_iOS.ProfileSpaceCellStyleProtocol)
  @objc override dynamic public func layoutSpecThatFits(_ constrainedSize: AsyncDisplayKit.ASSizeRange) -> AsyncDisplayKit.ASLayoutSpec
  @objc deinit
  @objc override dynamic public init(viewControllerBlock: @escaping AsyncDisplayKit.ASDisplayNodeViewControllerBlock, didLoad didLoadBlock: AsyncDisplayKit.ASDisplayNodeDidLoadBlock? = nil)
  @objc override dynamic public init()
}
public protocol ProfileSpaceCellViewModelProtocol : Dialog_iOS.ProfileCellViewModelProtocol {
}
public protocol ProfileSwitchCellStyleProtocol : Dialog_iOS.ProfileCellStyleProtocol {
  var spacing: CoreGraphics.CGFloat { get }
  var insets: UIKit.UIEdgeInsets { get }
  var titleAttributesText: [Foundation.NSAttributedString.Key : Any] { get }
}
public struct ProfileSwitchCellDefaultStyle : Dialog_iOS.ProfileSwitchCellStyleProtocol {
  public let spacing: CoreGraphics.CGFloat
  public let insets: UIKit.UIEdgeInsets
  public var titleAttributesText: [Foundation.NSAttributedString.Key : Any]
}
@objc public class ProfileSwitchCell : AsyncDisplayKit.ASCellNode {
  final public let profileStyle: Dialog_iOS.ProfileSwitchCellStyleProtocol
  public init(viewModel: Dialog_iOS.ProfileSwitchCellViewModelProtocol, style: Dialog_iOS.ProfileSwitchCellStyleProtocol)
  @objc override dynamic public func layoutSpecThatFits(_ constrainedSize: AsyncDisplayKit.ASSizeRange) -> AsyncDisplayKit.ASLayoutSpec
  @objc deinit
  @objc override dynamic public init(viewControllerBlock: @escaping AsyncDisplayKit.ASDisplayNodeViewControllerBlock, didLoad didLoadBlock: AsyncDisplayKit.ASDisplayNodeDidLoadBlock? = nil)
  @objc override dynamic public init()
}
public protocol ProfileSwitchCellViewModelProtocol : Dialog_iOS.ProfileCellViewModelProtocol {
  var title: Swift.String { get }
  var on: Dialog_iOS.RxValue<Swift.Bool> { get }
}
public class ProfileSwitchCellViewModel : Dialog_iOS.ProfileCellViewModel, Dialog_iOS.ProfileSwitchCellViewModelProtocol {
  final public let title: Swift.String
  public var on: Dialog_iOS.RxValue<Swift.Bool>
  required public init(type: Swift.Int, title: Swift.String, value: Dialog_iOS.RxValue<Swift.Bool>, themeService: Dialog_iOS.AppThemeService)
  @objc deinit
  override public init(type: Swift.Int, themeService: Dialog_iOS.AppThemeService)
}
public protocol ProfileTextCellStyleProtocol : Dialog_iOS.ProfileCellStyleProtocol {
  var iconSize: CoreGraphics.CGSize { get }
  var spacing: CoreGraphics.CGFloat { get }
  var insets: UIKit.UIEdgeInsets { get }
  var titleAttributes: [Foundation.NSAttributedString.Key : Any] { get }
  var textAttributes: [Foundation.NSAttributedString.Key : Any] { get }
  var iconColor: UIKit.UIColor { get }
}
public struct ProfileTextCellDefaultStyle : Dialog_iOS.ProfileTextCellStyleProtocol {
  public let iconSize: CoreGraphics.CGSize
  public let spacing: CoreGraphics.CGFloat
  public let insets: UIKit.UIEdgeInsets
  public var textAttributes: [Foundation.NSAttributedString.Key : Any]
  public let titleAttributes: [Foundation.NSAttributedString.Key : Any]
  public let iconColor: UIKit.UIColor
}
@objc public class ProfileTextCell : AsyncDisplayKit.ASCellNode {
  final public let profileStyle: Dialog_iOS.ProfileTextCellStyleProtocol
  public init(viewModel: Dialog_iOS.ProfileTextCellViewModelProtocol, style: Dialog_iOS.ProfileTextCellStyleProtocol)
  @objc override dynamic public func layoutSpecThatFits(_ constrainedSize: AsyncDisplayKit.ASSizeRange) -> AsyncDisplayKit.ASLayoutSpec
  @objc deinit
  @objc override dynamic public init(viewControllerBlock: @escaping AsyncDisplayKit.ASDisplayNodeViewControllerBlock, didLoad didLoadBlock: AsyncDisplayKit.ASDisplayNodeDidLoadBlock? = nil)
  @objc override dynamic public init()
}
public protocol ProfileTextCellViewModelProtocol : Dialog_iOS.ProfileCellViewModelProtocol {
  var title: Swift.String { get }
  var text: Swift.String { get }
  var icon: UIKit.UIImage? { get }
}
public class ProfileTextCellViewModel : Dialog_iOS.ProfileCellViewModel, Dialog_iOS.ProfileTextCellViewModelProtocol {
  final public let title: Swift.String
  final public let text: Swift.String
  final public let icon: UIKit.UIImage?
  required public init(type: Swift.Int, title: Swift.String, code: Swift.String = "", text: Swift.String, icon: UIKit.UIImage? = nil, themeService: Dialog_iOS.AppThemeService)
  @objc deinit
  override public init(type: Swift.Int, themeService: Dialog_iOS.AppThemeService)
}
public protocol ProfileStyleProtocol {
  var backgroundColor: UIKit.UIColor { get }
}
public struct ProfileDefaultStyle : Dialog_iOS.ProfileStyleProtocol {
  public let backgroundColor: UIKit.UIColor
}
public protocol ProfileViewModelProtocol {
  var sections: RxCocoa.Driver<[Dialog_iOS.ProfileSection]> { get }
  var title: RxCocoa.Driver<Swift.String> { get }
  var beginCallTypeChoiceViewModel: Dialog_iOS.BeginCallTypeChoiceViewModelProtocol { get }
}
public struct ProfileSection {
  public let items: [Dialog_iOS.ProfileCellViewModel]
  public init(items: [Dialog_iOS.ProfileCellViewModel])
}
extension ProfileSection : Differentiator.AnimatableSectionModelType {
  public typealias Identity = Swift.Int
  public var identity: Swift.Int {
    get
  }
  public typealias Item = Dialog_iOS.ProfileCellViewModel
  public init(original: Dialog_iOS.ProfileSection, items: [Dialog_iOS.ProfileSection.Item])
}
public class ProfileViewModel : Dialog_iOS.ProfileViewModelProtocol {
  final public let sections: RxCocoa.Driver<[Dialog_iOS.ProfileSection]>
  final public let title: RxCocoa.Driver<Swift.String>
  public var beginCallTypeChoiceViewModel: Dialog_iOS.BeginCallTypeChoiceViewModelProtocol
  public init(peerId: Swift.Int32, router: Dialog_iOS.UserSpecifiedRouterProtocol, dialogService: DialogMessaging.DialogServiceProtocol, eventBusService: DialogProtocols.EventBusServiceProtocol, callsService: DialogCalls.CallsServiceProtocol, beginCallChoiceViewModel: Dialog_iOS.BeginCallTypeChoiceViewModelProtocol)
  @objc deinit
}
public protocol ProtectedDataIndependentServiceProtocol {
}
extension Resolver {
  public func resolveProtectedDataIndependentService<S>(type: S.Type) -> S?
}
public protocol ProtectedDataMetricsServiceProtocol {
  func saveEvents(events: [DialogMetrics.DialogMetricStoragableEvent], instantly: Swift.Bool)
}
public class ProtectedDataMetricsService : Dialog_iOS.ProtectedDataMetricsServiceProtocol {
  public init(container: Swinject.Container)
  public func saveEvents(events: [DialogMetrics.DialogMetricStoragableEvent], instantly: Swift.Bool)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers final public class ProtectedDataUnavailableViewController : UIKit.UIViewController {
  @objc override final public func viewDidLoad()
  @objc deinit
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public enum PublicProfileCellType : Swift.Int {
  case header
  case callAndMessage
  case username
  case phone
  case about
  case notifications
  case sharedMedia
  case addToContacts
  case removeFromContacts
  case addToFavourites
  case openDetail
  case hideDetail
  case spaceDetail
  case blockContact
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
  public init?(rawValue: Swift.Int)
}
public class PublicProfileHeaderCellViewModel : Dialog_iOS.ProfileCellViewModel, Dialog_iOS.ProfileHeaderCellViewModelProtocol, Dialog_iOS.GeneralSettingsCellViewModelProtocol, Dialog_iOS.AvatarNodeModelProtocol {
  public var route: Dialog_iOS.GeneralSettingsRoute
  public var userAvatarBasicColor: RxCocoa.Driver<UIKit.UIColor>
  final public let avatarCenterText: RxSwift.Observable<Swift.String?>
  final public let avatarImage: RxSwift.Observable<UIKit.UIImage?>
  public var avatarNodeDidTapped: RxRelay.PublishRelay<Swift.Void>
  public var title: RxCocoa.Driver<Swift.String>
  public var nickname: RxCocoa.Driver<Swift.String?>
  required public init(myUserResolver: Dialog_iOS.MyUserResolverProtocol, type: Swift.Int, user: DialogProtocols.DialogUser, fileService: DialogFiles.DialogFileServiceProtocol, eventBusService: DialogProtocols.EventBusServiceProtocol, colorService: Dialog_iOS.DialogPeerColorsServiceProtocol, themeService: Dialog_iOS.AppThemeService, routerService: Dialog_iOS.RouterServiceProtocol)
  override public init(type: Swift.Int, themeService: Dialog_iOS.AppThemeService)
  @objc deinit
}
public struct UserProfileSceneArgument {
  public let id: DialogProtocols.DialogUserId
  public var initialUser: DialogProtocols.DialogUser?
  public init(id: DialogProtocols.DialogUserId)
  public init(user: DialogProtocols.DialogUser)
  public init(routeArgument: Dialog_iOS.UserProfileRouteArgs)
}
@_inheritsConvenienceInitializers final public class PublicProfileScene : Dialog_iOS.Scene<Dialog_iOS.UserProfileSceneArgument, UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.PublicProfileScene.Builder
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<Dialog_iOS.UserProfileSceneArgument, UIKit.UIViewController, Dialog_iOS.ProfileViewModelProtocol> {
    override final public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Dialog_iOS.UserProfileSceneArgument>) -> Dialog_iOS.ProfileViewModelProtocol
    override final public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Dialog_iOS.UserProfileSceneArgument>, viewModel: Dialog_iOS.ProfileViewModelProtocol) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<Dialog_iOS.UserProfileSceneArgument, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
public protocol PublicProfileViewModelProtocol {
  func subscribeToUserPresenceStateService()
  var requestRemoveFromContacts: RxCocoa.Driver<Swift.Void> { get }
  var removeFromContacts: RxSwift.AnyObserver<Swift.Void> { get }
}
public class PublicProfileViewModel : Dialog_iOS.ProfileViewModel, Dialog_iOS.PublicProfileViewModelProtocol {
  final public let requestRemoveFromContacts: RxCocoa.Driver<Swift.Void>
  final public let removeFromContacts: RxSwift.AnyObserver<Swift.Void>
  required public init(myUserResolver: Dialog_iOS.MyUserResolverProtocol, userId: DialogProtocols.DialogUserId, initialUser: DialogProtocols.DialogUser? = nil, routerService: Dialog_iOS.RouterServiceProtocol, router: Dialog_iOS.UserSpecifiedRouterProtocol, userService: DialogProtocols.DialogUserServiceProtocol, dialogService: DialogMessaging.DialogServiceProtocol, fileService: DialogFiles.DialogFileServiceProtocol, eventBusService: DialogProtocols.EventBusServiceProtocol, muteService: DialogMuteSettingsService.DialogMuteSettingsServiceProtocol, userPresenceStateService: DialogProtocols.UserPresenceStateServiceProtocol, callsService: DialogCalls.CallsServiceProtocol, colorService: Dialog_iOS.DialogPeerColorsServiceProtocol, contactsService: DialogMessaging.DialogContactsServiceProtocol, featureFlagsService: DialogProtocols.DialogFeatureFlagsServiceProtocol, beginCallChoiceViewModel: Dialog_iOS.BeginCallTypeChoiceViewModelProtocol, searchTaskPerformer: DialogSearching.SearchTaskPerformerProtocol, sharedFilesService: Dialog_iOS.SharedFilesServiceWithRemoteItemsProtocol, themeService: Dialog_iOS.AppThemeService)
  public func subscribeToUserPresenceStateService()
  override public init(peerId: Swift.Int32, router: Dialog_iOS.UserSpecifiedRouterProtocol, dialogService: DialogMessaging.DialogServiceProtocol, eventBusService: DialogProtocols.EventBusServiceProtocol, callsService: DialogCalls.CallsServiceProtocol, beginCallChoiceViewModel: Dialog_iOS.BeginCallTypeChoiceViewModelProtocol)
  @objc deinit
}
public protocol PushRegistryServiceProtocol : Dialog_iOS.ProtectedDataIndependentServiceProtocol {
  var events: RxSwift.Observable<Dialog_iOS.PushRegistryServiceEvent> { get }
  var state: RxSwift.Observable<Dialog_iOS.PushRegistryServiceState> { get }
}
extension PushRegistryServiceProtocol {
  public var pushes: RxSwift.Observable<Dialog_iOS.PushEvent> {
    get
  }
}
public protocol PushVoIPCallPayload {
  var name: Swift.String? { get }
  var phone: Swift.String? { get }
  var alert: Swift.String? { get }
}
@_hasMissingDesignatedInitializers final public class PushVoIPCallPayloadAdapter : Dialog_iOS.PushVoIPCallPayload {
  final public var name: Swift.String? {
    get
  }
  final public var phone: Swift.String? {
    get
  }
  final public var alert: Swift.String? {
    get
  }
  @objc deinit
}
public struct PushPayloadStringKey : Swift.RawRepresentable, Swift.Hashable, Swift.CustomStringConvertible {
  public typealias RawValue = Swift.String
  public let rawValue: Dialog_iOS.PushPayloadStringKey.RawValue
  public init(rawValue: Dialog_iOS.PushPayloadStringKey.RawValue)
  public var description: Swift.String {
    get
  }
  public static let aps: Dialog_iOS.PushPayloadStringKey
  public static let phone: Dialog_iOS.PushPayloadStringKey
  public static let name: Dialog_iOS.PushPayloadStringKey
  public static let alert: Dialog_iOS.PushPayloadStringKey
}
public struct PushRegistryServiceState : Swift.Equatable {
  public static func == (a: Dialog_iOS.PushRegistryServiceState, b: Dialog_iOS.PushRegistryServiceState) -> Swift.Bool
}
final public class PushRegistryService : Dialog_iOS.PushRegistryServiceProtocol {
  final public var events: RxSwift.Observable<Dialog_iOS.PushRegistryServiceEvent> {
    get
  }
  final public let state: RxSwift.Observable<Dialog_iOS.PushRegistryServiceState>
  public init(registry: PushKit.PKPushRegistry = PKPushRegistry(queue: nil), authStateService: Dialog_iOS.AppAuthStateServiceProtocol, pushHandlerResolver: @escaping (() -> Dialog_iOS.VoIPNotificationsHandlingServiceProtocol?), protectedDataChecker: Dialog_iOS.ApplicationProtectedDataAvailabilityServiceProtocol, unknownActiveUserPushHandler: Dialog_iOS.UnknownActiveUserPushHandlerProtocol? = nil)
  @objc deinit
}
extension PKPushRegistry {
  public func appendType(_ type: PushKit.PKPushType)
  public func removeType(_ type: PushKit.PKPushType)
}
public enum PushRegistryServiceEvent {
  case pushReceived(Dialog_iOS.PushEvent)
  case credentialsUpdated(PushKit.PKPushCredentials, type: PushKit.PKPushType)
  case tokenInvalidated(Foundation.Data, type: PushKit.PKPushType)
}
public enum PushRegistryServiceRequest {
  case registerForVoIPNotificaitons
  case unregisterForVoIPNotifications
  public static func == (a: Dialog_iOS.PushRegistryServiceRequest, b: Dialog_iOS.PushRegistryServiceRequest) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
extension PKPushPayload {
  public var callId: Swift.String? {
    get
  }
  public var displayName: Swift.String? {
    get
  }
  public var userId: Swift.String? {
    get
  }
}
public struct PushEvent {
  public init(payload: PushKit.PKPushPayload, type: PushKit.PKPushType, processingControl: Dialog_iOS.PushProcessingControl? = nil)
}
public protocol PushProcessingControl {
  func blockCompletion() -> Dialog_iOS.PushProcessingCompletionBlocker?
  var uuid: Foundation.UUID { get }
}
public protocol PushProcessingCompletionBlocker {
  var completionAlreadyAllowed: Swift.Bool { get }
  func allowCompletion()
}
public protocol PushNotificationsServiceProtocol {
  func handle(event: Dialog_iOS.NotificationEvent)
  func requestUserPermissions()
  func exchangeKeysIfNeeded()
  func registerForPushNotifications()
  func unregisterForPushNotifications()
  var pushToken: Swift.String? { get }
}
public protocol PushNotificationServiceAppDelegateInput {
  func application(_ application: UIKit.UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Foundation.Data)
  func application(_ application: UIKit.UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Swift.Error)
  func application(_ application: UIKit.UIApplication, didReceiveRemoteNotification userInfo: [Swift.AnyHashable : Any], fetchCompletionHandler completionHandler: @escaping (UIKit.UIBackgroundFetchResult) -> Swift.Void)
}
extension PushNotificationsServiceProtocol {
  public func start()
  public func stop()
}
public enum ReachabilityError : Swift.Error {
  case FailedToCreateWithAddress(Darwin.sockaddr_in)
  case FailedToCreateWithHostname(Swift.String)
  case UnableToSetCallback
  case UnableToSetDispatchQueue
  case UnableToGetInitialFlags
}
@available(*, unavailable, renamed: "Notification.Name.reachabilityChanged")
public let ReachabilityChangedNotification: Foundation.NSNotification.Name
extension NSNotification.Name {
  public static let reachabilityChanged: Foundation.Notification.Name
}
public class Reachability {
  public typealias NetworkReachable = (Dialog_iOS.Reachability) -> ()
  public typealias NetworkUnreachable = (Dialog_iOS.Reachability) -> ()
  @available(*, unavailable, renamed: "Connection")
  public enum NetworkStatus : Swift.CustomStringConvertible {
    case notReachable, reachableViaWiFi, reachableViaWWAN
    public var description: Swift.String {
      get
    }
    public static func == (a: Dialog_iOS.Reachability.NetworkStatus, b: Dialog_iOS.Reachability.NetworkStatus) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public enum Connection : Swift.CustomStringConvertible {
    case none, wifi, cellular
    public var description: Swift.String {
      get
    }
    public static func == (a: Dialog_iOS.Reachability.Connection, b: Dialog_iOS.Reachability.Connection) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public var whenReachable: Dialog_iOS.Reachability.NetworkReachable?
  public var whenUnreachable: Dialog_iOS.Reachability.NetworkUnreachable?
  @available(*, deprecated, renamed: "allowsCellularConnection")
  final public let reachableOnWWAN: Swift.Bool
  public var allowsCellularConnection: Swift.Bool
  public var notificationCenter: Foundation.NotificationCenter
  @available(*, deprecated, renamed: "connection.description")
  public var currentReachabilityString: Swift.String {
    get
  }
  @available(*, unavailable, renamed: "connection")
  public var currentReachabilityStatus: Dialog_iOS.Reachability.Connection {
    get
  }
  public var connection: Dialog_iOS.Reachability.Connection {
    get
  }
  required public init(reachabilityRef: SystemConfiguration.SCNetworkReachability, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil)
  convenience public init?(hostname: Swift.String, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil)
  convenience public init?(queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil)
  @objc deinit
}
extension Reachability {
  public func startNotifier() throws
  public func stopNotifier()
  @available(*, deprecated, message: "Please use `connection != .none`")
  public var isReachable: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .cellular`")
  public var isReachableViaWWAN: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .wifi`")
  public var isReachableViaWiFi: Swift.Bool {
    get
  }
  public var description: Swift.String {
    get
  }
}
extension Theme.Domain {
  public static let reactions: Dialog_iOS.Theme.Domain
}
extension Theme.Keys.Reactions {
  public static let backgroundColor: Dialog_iOS.Theme.Keys.Reactions
  public static let shadowColor: Dialog_iOS.Theme.Keys.Reactions
}
extension Theme.Defaults {
  public static let reactions: DialogSharedComponents.Subtheme<Dialog_iOS.Theme.Keys.Reactions>
}
extension Theme.Keys {
  public struct Reactions : Dialog_iOS.DomainSpecificKey, Swift.RawRepresentable {
    public static var domain: Dialog_iOS.Theme.Domain
    public var domainInternalId: Swift.String {
      get
    }
    public let rawValue: Swift.String
    public init(rawValue: Swift.String)
    public typealias RawValue = Swift.String
  }
}
public protocol ReactiveLocalizable {
  func getLocalizedText(eventBus: DialogProtocols.EventBusServiceProtocol, messagePeerId: Swift.Int32) -> RxSwift.Observable<Swift.String>
}
public protocol CustomReactiveLocalizable {
  func getLocalizedText(eventBus: DialogProtocols.EventBusServiceProtocol, messagePeerId: Swift.Int32, date: Swift.Int64, author: DialogProtocols.DialogPeer) -> RxSwift.Observable<Swift.String>
}
extension Array where Element == Dialog_iOS.DateFormaterRule {
  public static let serviceMessageRules: [Dialog_iOS.DateFormaterRule]
}
extension DialogMessage {
  public func getLocalizedText(eventBus: DialogProtocols.EventBusServiceProtocol) -> RxSwift.Observable<Swift.String>
}
extension DialogServiceMessageGroupCreatedContent : Dialog_iOS.ReactiveLocalizable {
  final public func getLocalizedText(eventBus: DialogProtocols.EventBusServiceProtocol, messagePeerId: Swift.Int32) -> RxSwift.Observable<Swift.String>
}
extension DialogServiceMessageUserLeftContent : Dialog_iOS.ReactiveLocalizable {
  final public func getLocalizedText(eventBus: DialogProtocols.EventBusServiceProtocol, messagePeerId: Swift.Int32) -> RxSwift.Observable<Swift.String>
}
extension DialogServiceMessageUserInvitedContent : Dialog_iOS.ReactiveLocalizable {
  final public func getLocalizedText(eventBus: DialogProtocols.EventBusServiceProtocol, messagePeerId: Swift.Int32) -> RxSwift.Observable<Swift.String>
}
extension DialogServiceMessageUserKickedContent : Dialog_iOS.ReactiveLocalizable {
  final public func getLocalizedText(eventBus: DialogProtocols.EventBusServiceProtocol, messagePeerId: Swift.Int32) -> RxSwift.Observable<Swift.String>
}
extension DialogServiceMessageUserJoinedContent : Dialog_iOS.ReactiveLocalizable {
  final public func getLocalizedText(eventBus: DialogProtocols.EventBusServiceProtocol, messagePeerId: Swift.Int32) -> RxSwift.Observable<Swift.String>
}
extension DialogServiceMessageChangedShortnameContent : Dialog_iOS.ReactiveLocalizable {
  final public func getLocalizedText(eventBus: DialogProtocols.EventBusServiceProtocol, messagePeerId: Swift.Int32) -> RxSwift.Observable<Swift.String>
}
extension DialogServiceMessageChangedTitleContent : Dialog_iOS.ReactiveLocalizable {
  final public func getLocalizedText(eventBus: DialogProtocols.EventBusServiceProtocol, messagePeerId: Swift.Int32) -> RxSwift.Observable<Swift.String>
}
extension DialogServiceMessageChangedAboutContent : Dialog_iOS.ReactiveLocalizable {
  final public func getLocalizedText(eventBus: DialogProtocols.EventBusServiceProtocol, messagePeerId: Swift.Int32) -> RxSwift.Observable<Swift.String>
}
extension DialogServiceMessageChangedAvatarContent : Dialog_iOS.ReactiveLocalizable {
  final public func getLocalizedText(eventBus: DialogProtocols.EventBusServiceProtocol, messagePeerId: Swift.Int32) -> RxSwift.Observable<Swift.String>
}
extension DialogServiceMessagePhoneMissedContent : Dialog_iOS.CustomReactiveLocalizable {
  final public func getLocalizedText(eventBus: DialogProtocols.EventBusServiceProtocol, messagePeerId: Swift.Int32, date: Swift.Int64, author: DialogProtocols.DialogPeer) -> RxSwift.Observable<Swift.String>
}
extension DialogServiceMessagePhoneRejectedContent : Dialog_iOS.CustomReactiveLocalizable {
  final public func getLocalizedText(eventBus: DialogProtocols.EventBusServiceProtocol, messagePeerId: Swift.Int32, date: Swift.Int64, author: DialogProtocols.DialogPeer) -> RxSwift.Observable<Swift.String>
}
extension DialogServiceMessagePhoneCallContent : Dialog_iOS.CustomReactiveLocalizable {
  final public func getLocalizedText(eventBus: DialogProtocols.EventBusServiceProtocol, messagePeerId: Swift.Int32, date: Swift.Int64, author: DialogProtocols.DialogPeer) -> RxSwift.Observable<Swift.String>
}
@objc @_inheritsConvenienceInitializers final public class RegionCodeCountryFlagFormatter : Foundation.ValueTransformer {
  final public func transform(code: Swift.String?, countryCodeIfNoFlat: Swift.Bool = false) -> Swift.String?
  @objc override final public func transformedValue(_ value: Any?) -> Any?
  @objc override dynamic public init()
  @objc deinit
}
public protocol BundleNameExecutable {
  var appName: Swift.String? { get }
}
extension Bundle : Dialog_iOS.BundleNameExecutable {
  public var appName: Swift.String? {
    get
  }
}
public protocol DeviceNameExecutable {
  var deviceName: Swift.String? { get }
}
extension UIDevice : Dialog_iOS.DeviceNameExecutable {
  public var deviceName: Swift.String? {
    get
  }
}
final public class RegistrationInfoProvider : DialogAuth.RegistrationTaskPerformerRequestInfoProvider {
  public init(bundleNameProvider: Dialog_iOS.BundleNameExecutable = Bundle.main, deviceNameProvider: Dialog_iOS.DeviceNameExecutable = UIDevice.current)
  final public var appName: Swift.String {
    get
    set
  }
  final public var deviceName: Swift.String {
    get
  }
  @objc deinit
}
@available(*, deprecated, message: "Use `AppRouterServiceProtocol' or 'UserSpecifiedRouterProtocol' instead")
public protocol RouterServiceProtocol {
  func resolveRouter<R>() -> XCoordinator.WeakRouter<R>? where R : XCoordinator.Route
}
extension RouterServiceProtocol {
  public func resolveRouter<R>(routeType: R.Type) -> XCoordinator.WeakRouter<R>? where R : XCoordinator.Route
  public func resolveRouter<R>(ofType: XCoordinator.WeakRouter<R>.Type) -> XCoordinator.WeakRouter<R>? where R : XCoordinator.Route
}
final public class RouterService : Dialog_iOS.RouterServiceProtocol {
  final public let resolver: Swinject.Resolver
  public init(resolver: Swinject.Resolver)
  final public func resolveRouter<R>() -> XCoordinator.WeakRouter<R>? where R : XCoordinator.Route
  @objc deinit
}
extension RouterServiceProtocol {
  public var rx: RxSwift.Reactive<Self> {
    get
  }
}
extension Reactive where Base : Dialog_iOS.RouterServiceProtocol {
  public func trigger<R>(_ route: R, with options: XCoordinator.TransitionOptions) -> RxSwift.Observable<Swift.Void> where R : XCoordinator.Route
}
extension RouterServiceProtocol {
  public func trigger<R>(route: R) -> RxSwift.Observable<Swift.Void> where R : XCoordinator.Route
  public func trigger<R>(route: R, options: XCoordinator.TransitionOptions) -> RxSwift.Observable<Swift.Void> where R : XCoordinator.Route
}
extension ObservableType where Self.Element : XCoordinator.Route {
  public func execRoute(service: Dialog_iOS.RouterServiceProtocol, options: XCoordinator.TransitionOptions = TransitionOptions(animated: true)) -> RxSwift.Observable<Swift.Void>
}
extension ObservableType {
  public func execRoute<R>(_ route: R, options: XCoordinator.TransitionOptions = TransitionOptions(animated: true), service: Dialog_iOS.RouterServiceProtocol) -> RxSwift.Observable<Swift.Void> where R : XCoordinator.Route
}
extension Container {
  final public func registerRouter<R, T>(coordinator: XCoordinator.AnyCoordinator<R, T>) where R : XCoordinator.Route, T : XCoordinator.TransitionProtocol
  final public func registerRouter<R>(fabric: @escaping () -> XCoordinator.WeakRouter<R>) where R : XCoordinator.Route
}
public enum ReloadType {
  case reload
  case update(adjustContentOffset: Swift.Bool)
}
public struct JumpInfo {
}
public protocol SectionsReloadModelType {
  associatedtype Section : Differentiator.AnimatableSectionModelType
  typealias S = Self.Section
  var sections: [Self.Section] { get }
  var reloadType: Dialog_iOS.ReloadType { get }
  var jumpInfo: Dialog_iOS.JumpInfo? { get }
}
public class RxASCollectionAdjustOffsetDataSource<O> : RxASDataSources.ASCollectionSectionedDataSource<O.S>, RxASDataSources.RxASCollectionDataSourceType where O : Dialog_iOS.SectionsReloadModelType {
  public var triggerDistanceEnableAdjustOffset: CoreGraphics.CGFloat
  final public let batchFetchingContext: AsyncDisplayKit.ASBatchContext
  public typealias Element = O
  public var animationConfiguration: RxASDataSources.RowAnimation
  final public let canUpdateSections: RxSwift.BehaviorSubject<Swift.Bool>
  override open var sectionModels: [O.S] {
    get
  }
  public init(batchFetchingContext: AsyncDisplayKit.ASBatchContext, animationConfiguration: RxASDataSources.RowAnimation = RowAnimation(), configureCell: @escaping Dialog_iOS.RxASCollectionAdjustOffsetDataSource<O>.ConfigureCell, configureSupplementaryView: Dialog_iOS.RxASCollectionAdjustOffsetDataSource<O>.ConfigureSupplementaryView? = nil, moveItem: @escaping Dialog_iOS.RxASCollectionAdjustOffsetDataSource<O>.MoveItem = { _, _, _ in () }, canMoveItemAtIndexPath: @escaping Dialog_iOS.RxASCollectionAdjustOffsetDataSource<O>.CanMoveItemAtIndexPath = { _, _ in false })
  public func reset(_ collectionNode: AsyncDisplayKit.ASCollectionNode)
  open func collectionNode(_ collectionNode: AsyncDisplayKit.ASCollectionNode, observedEvent: RxSwift.Event<Dialog_iOS.RxASCollectionAdjustOffsetDataSource<O>.Element>)
  override public init(configureCell: @escaping RxASDataSources.ASCollectionSectionedDataSource<O.S>.ConfigureCell, configureSupplementaryView: RxASDataSources.ASCollectionSectionedDataSource<O.S>.ConfigureSupplementaryView? = super, moveItem: @escaping RxASDataSources.ASCollectionSectionedDataSource<O.S>.MoveItem = super, canMoveItemAtIndexPath: @escaping RxASDataSources.ASCollectionSectionedDataSource<O.S>.CanMoveItemAtIndexPath = super)
  override public init(configureCellBlock: @escaping RxASDataSources.ASCollectionSectionedDataSource<O.S>.ConfigureCellBlock, configureSupplementaryView: RxASDataSources.ASCollectionSectionedDataSource<O.S>.ConfigureSupplementaryView? = super, moveItem: @escaping RxASDataSources.ASCollectionSectionedDataSource<O.S>.MoveItem = super, canMoveItemAtIndexPath: @escaping RxASDataSources.ASCollectionSectionedDataSource<O.S>.CanMoveItemAtIndexPath = super)
  override public init(configureCell: @escaping RxASDataSources.ASCollectionSectionedDataSource<O.S>.ConfigureCell, configureSupplementaryViewBlock: RxASDataSources.ASCollectionSectionedDataSource<O.S>.ConfigureSupplementaryViewBlock? = super, moveItem: @escaping RxASDataSources.ASCollectionSectionedDataSource<O.S>.MoveItem = super, canMoveItemAtIndexPath: @escaping RxASDataSources.ASCollectionSectionedDataSource<O.S>.CanMoveItemAtIndexPath = super)
  override public init(configureCellBlock: @escaping RxASDataSources.ASCollectionSectionedDataSource<O.S>.ConfigureCellBlock, configureSupplementaryViewBlock: RxASDataSources.ASCollectionSectionedDataSource<O.S>.ConfigureSupplementaryViewBlock? = super, moveItem: @escaping RxASDataSources.ASCollectionSectionedDataSource<O.S>.MoveItem = super, canMoveItemAtIndexPath: @escaping RxASDataSources.ASCollectionSectionedDataSource<O.S>.CanMoveItemAtIndexPath = super)
  @objc deinit
}
public protocol RxValueType : RxSwift.ObservableType, RxSwift.ObserverType {
  func asRxValue() -> Dialog_iOS.RxValue<Self.Element>
}
public struct RxValue<ValueType> : Dialog_iOS.RxValueType {
  public typealias E = ValueType
  public init<V, S>(values: V, valueSink: S) where ValueType == V.Element, V : RxSwift.ObservableType, S : RxSwift.ObserverType, V.Element == S.Element
  public func subscribe<O>(_ observer: O) -> RxSwift.Disposable where ValueType == O.Element, O : RxSwift.ObserverType
  public var changed: RxSwift.Observable<ValueType> {
    get
  }
  public func asObservable() -> RxSwift.Observable<Dialog_iOS.RxValue<ValueType>.E>
  public func asRxValue() -> Dialog_iOS.RxValue<ValueType>
  public func on(_ event: RxSwift.Event<Dialog_iOS.RxValue<ValueType>.E>)
  public typealias Element = ValueType
}
extension RxValueType where Self.Element == Swift.String? {
  public var orEmpty: Dialog_iOS.RxValue<Swift.String> {
    get
  }
}
extension RxValueType where Self.Element == Swift.Bool {
  public var negative: Dialog_iOS.RxValue<Swift.Bool> {
    get
  }
}
extension Resolver {
  public func resolveSceneViewController<MainArg, VC, S>(_ scene: S.Type, arg: Dialog_iOS.Scene<MainArg, VC>.Argument, resolver: Swinject.Resolver) -> VC? where VC : UIKit.UIViewController, S : Dialog_iOS.Scene<MainArg, VC>
  public func resolveSceneViewController<VC, S>(_ scene: S.Type, resolver: Swinject.Resolver) -> VC? where VC : UIKit.UIViewController, S : Dialog_iOS.Scene<Swift.Void, VC>
}
extension Container {
  final public func registerScene<MainArg, VC, S>(_ scene: S.Type) where VC : UIKit.UIViewController, S : Dialog_iOS.Scene<MainArg, VC>
  final public func replaceSceneResolving<MainArg, VC, S>(_ scene: S.Type, builder: Dialog_iOS.Scene<MainArg, VC>.Builder) where VC : UIKit.UIViewController, S : Dialog_iOS.Scene<MainArg, VC>
}
open class Scene<MainArgument, ViewController> where ViewController : UIKit.UIViewController {
  public typealias Argument = Dialog_iOS.SceneArgument<MainArgument>
  public typealias Builder = Dialog_iOS.AnySceneBuilder<ViewController, MainArgument>
  open class func defaultSceneBuilder() -> Dialog_iOS.Scene<MainArgument, ViewController>.Builder
  required public init(builder: Dialog_iOS.Scene<MainArgument, ViewController>.Builder = defaultSceneBuilder(), resolver: Swinject.Resolver)
  public func build(argument: Dialog_iOS.Scene<MainArgument, ViewController>.Argument, resolver: Swinject.Resolver) -> ViewController
  @objc deinit
}
public struct SceneArgument<MainArgument> {
  public typealias MainArgument = MainArgument
  public typealias UserInfo = [Dialog_iOS.SceneArgumentKey : Swift.AnyObject]
  public let userInfo: Dialog_iOS.SceneArgument<MainArgument>.UserInfo
  public let main: MainArgument
  public init(main: MainArgument, userInfo: Dialog_iOS.SceneArgument<MainArgument>.UserInfo = .init())
}
public struct SceneArgumentKey : Swift.RawRepresentable, Swift.Hashable {
  public typealias RawValue = Swift.String
  public let rawValue: Dialog_iOS.SceneArgumentKey.RawValue
  public init(rawValue: Dialog_iOS.SceneArgumentKey.RawValue)
  public init(_ rawValue: Dialog_iOS.SceneArgumentKey.RawValue)
}
public protocol SceneBuilderProtocol {
  associatedtype ViewController : UIKit.UIViewController
  associatedtype MainArgument
  func build(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Self.MainArgument>) -> Self.ViewController
}
extension SceneBuilderProtocol {
  public var uniqueBuilderName: Swift.String {
    get
  }
}
extension SceneBuilderProtocol {
  public var asAnyBuilder: Dialog_iOS.AnySceneBuilder<Self.ViewController, Self.MainArgument> {
    get
  }
}
public class AnySceneBuilder<VC, Arg> : Dialog_iOS.SceneBuilderProtocol where VC : UIKit.UIViewController {
  public typealias ViewController = VC
  public typealias Argument = Arg
  public init<B>(builder: B) where VC == B.ViewController, Arg == B.MainArgument, B : Dialog_iOS.SceneBuilderProtocol
  public func build(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Arg>) -> Dialog_iOS.AnySceneBuilder<VC, Arg>.ViewController
  public typealias MainArgument = Arg
  @objc deinit
}
final public class ScenesAssembler : Swinject.Assembly {
  public init()
  final public func assemble(container: Swinject.Container)
  @objc deinit
}
public protocol ScreenDimmingViewDesignProtocol {
  var dimmedColor: UIKit.UIColor { get }
  var dimmedOpacity: CoreGraphics.CGFloat { get }
}
public struct DarkenDimmingViewStyle : Dialog_iOS.ScreenDimmingViewDesignProtocol {
  public let dimmedColor: UIKit.UIColor
  public let dimmedOpacity: CoreGraphics.CGFloat
}
@objc @_hasMissingDesignatedInitializers public class ScreenDimmingView : UIKit.UIView {
  public init(design: Dialog_iOS.ScreenDimmingViewDesignProtocol, frame: CoreGraphics.CGRect)
  convenience public init(design: Dialog_iOS.ScreenDimmingViewDesignProtocol)
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
}
public protocol SearchResultsViewControllerProviderProtocol {
  typealias SearchResultsViewController = (UIKit.UIViewController & UIKit.UISearchResultsUpdating)
  func provideSearchResultsViewController() -> Self.SearchResultsViewController
}
final public class SearchResultsViewControllerProvider : Dialog_iOS.SearchResultsViewControllerProviderProtocol {
  final public var controller: Dialog_iOS.SearchResultsViewControllerProvider.SearchResultsViewController {
    get
    set
  }
  public typealias Fabric = (() -> Dialog_iOS.SearchResultsViewControllerProvider.SearchResultsViewController)
  final public let fabric: Dialog_iOS.SearchResultsViewControllerProvider.Fabric
  public init(fabric: @escaping Dialog_iOS.SearchResultsViewControllerProvider.Fabric)
  final public func provideSearchResultsViewController() -> Dialog_iOS.SearchResultsViewControllerProvider.SearchResultsViewController
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class EmptyResultsGroupSearchService : DialogSearching.RemoteSearchServiceProtocol {
  final public let state: RxSwift.Observable<DialogSearching.RemoteSearchServiceCompositeState>
  final public let search: RxSwift.AnyObserver<DialogSearching.RemoteSearchServiceRequest>
  @objc deinit
}
public protocol SectionLoadingDesignProtocol : Dialog_iOS.MessageContentDesignProtocol {
  var indicatorStyle: UIKit.UIActivityIndicatorView.Style { get }
  var spacing: CoreGraphics.CGFloat { get }
}
public struct SectionLoadingDesign : Dialog_iOS.SectionLoadingDesignProtocol {
  public static let `default`: Dialog_iOS.SectionLoadingDesign
  public let indicatorStyle: UIKit.UIActivityIndicatorView.Style
  public let spacing: CoreGraphics.CGFloat
}
@objc public class SectionLoadingCellNode : AsyncDisplayKit.ASCellNode {
  public init(design: Dialog_iOS.SectionLoadingDesignProtocol = SectionLoadingDesign.default)
  @objc override dynamic public func layoutSpecThatFits(_ constrainedSize: AsyncDisplayKit.ASSizeRange) -> AsyncDisplayKit.ASLayoutSpec
  @objc deinit
  @objc override dynamic public init(viewControllerBlock: @escaping AsyncDisplayKit.ASDisplayNodeViewControllerBlock, didLoad didLoadBlock: AsyncDisplayKit.ASDisplayNodeDidLoadBlock? = nil)
  @objc override dynamic public init()
}
public protocol SectionTitleCellNodeDesign {
  var containerBackgroundColor: UIKit.UIColor { get }
  var containerHeight: CoreGraphics.CGFloat { get }
  var wrapperBackgroundColor: UIKit.UIColor { get }
  var wrapperInsets: UIKit.UIEdgeInsets { get }
  var wrapperCornerRadiusType: Dialog_iOS.CornerRadiusType { get }
  var labelFont: UIKit.UIFont { get }
  var labelColor: UIKit.UIColor { get }
}
@_hasMissingDesignatedInitializers public class SectionTitleCellNodeDefaultStyle : Dialog_iOS.SectionTitleCellNodeDesign {
  final public let containerBackgroundColor: UIKit.UIColor
  final public let containerHeight: CoreGraphics.CGFloat
  final public let wrapperBackgroundColor: UIKit.UIColor
  final public let wrapperInsets: UIKit.UIEdgeInsets
  final public let wrapperCornerRadiusType: Dialog_iOS.CornerRadiusType
  final public let labelFont: UIKit.UIFont
  final public let labelColor: UIKit.UIColor
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers public class SectionTitleCellNode : AsyncDisplayKit.ASCellNode {
  @objc override dynamic public func layoutDidFinish()
  @objc override dynamic public func layoutSpecThatFits(_ constrainedSize: AsyncDisplayKit.ASSizeRange) -> AsyncDisplayKit.ASLayoutSpec
  @objc override dynamic public init(viewControllerBlock: @escaping AsyncDisplayKit.ASDisplayNodeViewControllerBlock, didLoad didLoadBlock: AsyncDisplayKit.ASDisplayNodeDidLoadBlock? = nil)
  @objc override dynamic public init()
  @objc deinit
}
public struct SelectUserInGroupSection : Differentiator.SectionModelType {
  public let items: [Dialog_iOS.SelectUserInGroupCellViewModelProtocol]
  public init(original: Dialog_iOS.SelectUserInGroupSection, items: [Dialog_iOS.SelectUserInGroupCellViewModelProtocol])
  public init(items: [Dialog_iOS.SelectUserInGroupCellViewModelProtocol])
  public typealias Item = Dialog_iOS.SelectUserInGroupCellViewModelProtocol
}
public protocol SelectUserInGroupCellViewModelProtocol : DialogSharedComponents.AvatarViewModelProtocol {
  var userId: DialogProtocols.DialogUserId { get }
  var fullname: RxCocoa.Driver<Swift.String> { get }
  var canChange: RxSwift.Observable<Swift.Bool> { get }
}
public class SelectUserInGroupCellViewModel : Dialog_iOS.SelectUserInGroupCellViewModelProtocol {
  final public let userId: DialogProtocols.DialogUserId
  final public let fullname: RxCocoa.Driver<Swift.String>
  final public let canChange: RxSwift.Observable<Swift.Bool>
  public var avatarImage: RxCocoa.Driver<UIKit.UIImage?> {
    get
  }
  final public let basicColor: UIKit.UIColor
  final public let avatarCenterText: RxCocoa.Driver<Swift.String?>
  public var isAvatarLoading: RxCocoa.Driver<Swift.Bool>
  public init?(myId: DialogProtocols.DialogUserId, user: DialogProtocols.DialogUser, canChange: Swift.Bool = true, eventBusService: DialogProtocols.EventBusServiceProtocol, fileService: DialogFiles.DialogFileServiceProtocol, userPresenceStateService: DialogProtocols.UserPresenceStateServiceProtocol, colorService: Dialog_iOS.DialogPeerColorsServiceProtocol)
  @objc deinit
}
@_inheritsConvenienceInitializers public class SelectUserInGroupScene : Dialog_iOS.Scene<(DialogProtocols.DialogGroupId, Dialog_iOS.UserSelectionHandler, Dialog_iOS.CancelHandler), UIKit.UIViewController> {
  override public class func defaultSceneBuilder() -> Dialog_iOS.SelectUserInGroupScene.Builder
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<(DialogProtocols.DialogGroupId, Dialog_iOS.UserSelectionHandler, Dialog_iOS.CancelHandler), UIKit.UIViewController, Dialog_iOS.SelectUserInGroupViewModelProtocol> {
    override final public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<(DialogProtocols.DialogGroupId, Dialog_iOS.UserSelectionHandler, Dialog_iOS.CancelHandler)>) -> Dialog_iOS.SelectUserInGroupViewModelProtocol
    override final public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<(DialogProtocols.DialogGroupId, Dialog_iOS.UserSelectionHandler, Dialog_iOS.CancelHandler)>, viewModel: Dialog_iOS.SelectUserInGroupViewModelProtocol) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<(DialogProtocols.DialogGroupId, Dialog_iOS.UserSelectionHandler, Dialog_iOS.CancelHandler), UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
public protocol SelectUserInGroupViewModelProtocol : Dialog_iOS.ViewModelProtocol {
  var title: RxCocoa.Driver<Swift.String> { get }
  var sections: RxCocoa.Driver<[Dialog_iOS.SelectUserInGroupSection]> { get }
  var searchText: RxSwift.AnyObserver<Swift.String?> { get }
  var selectUser: RxSwift.AnyObserver<Dialog_iOS.SelectUserInGroupCellViewModelProtocol> { get }
  func removeFromParent()
}
public typealias UserSelectionHandler = (DialogProtocols.DialogUserId) -> Swift.Void
public typealias CancelHandler = () -> Swift.Void
public class SelectUserInGroupViewModel : Dialog_iOS.SelectUserInGroupViewModelProtocol {
  final public let title: RxCocoa.Driver<Swift.String>
  final public let searchText: RxSwift.AnyObserver<Swift.String?>
  final public let selectUser: RxSwift.AnyObserver<Dialog_iOS.SelectUserInGroupCellViewModelProtocol>
  final public let sections: RxCocoa.Driver<[Dialog_iOS.SelectUserInGroupSection]>
  public init(myId: DialogProtocols.DialogUserId, groupId: DialogProtocols.DialogGroupId, groupService: DialogProtocols.DialogGroupServiceProtocol, eventBusService: DialogProtocols.EventBusServiceProtocol, routerService: Dialog_iOS.RouterServiceProtocol, fileService: DialogFiles.DialogFileServiceProtocol, userPresenceStateService: DialogProtocols.UserPresenceStateServiceProtocol, colorService: Dialog_iOS.DialogPeerColorsServiceProtocol, cancelHandler: @escaping Dialog_iOS.CancelHandler = {}, userSelectionHandler: @escaping Dialog_iOS.UserSelectionHandler)
  public func removeFromParent()
  @objc deinit
}
public protocol SendabilityServiceProtocol {
  func canSendMessage(toPeer peer: DialogProtocols.DialogPeer) -> RxSwift.Observable<Swift.Bool>
}
final public class SendabilityService : Dialog_iOS.SendabilityServiceProtocol {
  final public let eventBus: DialogProtocols.EventBusServiceProtocol
  public init(eventBus: DialogProtocols.EventBusServiceProtocol, myId: DialogProtocols.DialogUserId)
  final public func canSendMessage(toPeer peer: DialogProtocols.DialogPeer) -> RxSwift.Observable<Swift.Bool>
  @objc deinit
}
public struct Server {
  public let asServerSettings: DialogProtocols.ServerSettings
  public var isSelected: Swift.Bool
}
extension Server : Swift.Equatable {
}
public func == (lhs: Dialog_iOS.Server, rhs: Dialog_iOS.Server) -> Swift.Bool
extension Server : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension ServiceEntry {
  @discardableResult
  final public func scoped(by objectScope: Swinject.ObjectScope?) -> Self
}
@_hasMissingDesignatedInitializers public class ServiceMessageCellNodeDefaultStyle {
  final public let prefferedHeight: CoreGraphics.CGFloat
  final public let maxCornerRadius: CoreGraphics.CGFloat
  final public let textInsets: UIKit.UIEdgeInsets
  final public let textHorizontalPadding: CoreGraphics.CGFloat
  final public let isBlurBgStyle: Swift.Bool
  public var textFont: UIKit.UIFont {
    get
  }
  final public let textColor: UIKit.UIColor
  final public let backgroundColor: UIKit.UIColor
  @objc deinit
}
extension Theme.Domain {
  public static let sharedContactsListHeaderStyle: Dialog_iOS.Theme.Domain
}
extension Theme.Keys.SharedContactsListHeaderStyle {
  public static let titleLabelFontSize: Dialog_iOS.Theme.Keys.SharedContactsListHeaderStyle
  public static let titleLabelTextColor: Dialog_iOS.Theme.Keys.SharedContactsListHeaderStyle
  public static let titleLabelInsets: Dialog_iOS.Theme.Keys.SharedContactsListHeaderStyle
  public static let viewBackgroundColor: Dialog_iOS.Theme.Keys.SharedContactsListHeaderStyle
}
extension Theme.Keys {
  public struct SharedContactsListHeaderStyle : Dialog_iOS.DomainSpecificKey, Swift.RawRepresentable {
    public static var domain: Dialog_iOS.Theme.Domain
    public var domainInternalId: Swift.String {
      get
    }
    public let rawValue: Swift.String
    public init(rawValue: Swift.String)
    public typealias RawValue = Swift.String
  }
}
extension Theme.Defaults {
  public static let sharedContactsListHeaderStyle: DialogSharedComponents.Subtheme<Dialog_iOS.Theme.Keys.SharedContactsListHeaderStyle>
}
public enum SearchRequest {
  case reset
  case search(text: Swift.String)
  case nextPage
  case retry(text: Swift.String)
}
public enum LoadingState {
  case isLoading(isRemote: Swift.Bool)
  case idle
}
public protocol SharedFilesServiceWithRemoteItemsProtocol : Dialog_iOS.SharedFilesServiceProtocol {
  var onlyRemoteFindedItems: [Dialog_iOS.AttachmentCategory : RxSwift.Observable<[Dialog_iOS.SearchedItem]>] { get }
  var performRemoteLoading: RxSwift.AnyObserver<Self.PerformRequest> { get }
}
public typealias LoadTaskState = DialogSearching.SupplementableSearchService.PageLoadTask
public protocol SharedFilesServiceProtocol : AnyObject {
  typealias PerformRequest = (DialogProtocols.DialogMessagesRequestDirection, Dialog_iOS.AttachmentCategory)
  var searchRequest: RxSwift.AnyObserver<Dialog_iOS.SearchRequest> { get }
  var textFilter: RxSwift.AnyObserver<Swift.String?> { get }
  var items: [Dialog_iOS.AttachmentCategory : RxSwift.Observable<[Dialog_iOS.SearchedItem]>] { get }
  var performLoading: RxSwift.AnyObserver<Self.PerformRequest> { get }
  var loadingState: RxSwift.Observable<Dialog_iOS.LoadTaskState> { get }
  var loadingError: RxSwift.Observable<Dialog_iOS.SomeError> { get }
}
public typealias SomeError = Swift.Bool
public protocol SortedDialogSourceServiceProtocol {
  var dialogs: RxSwift.Observable<[DialogProtocols.DialogState]> { get }
}
final public class SortedDialogSourceService : Dialog_iOS.SortedDialogSourceServiceProtocol {
  final public let dialogs: RxSwift.Observable<[DialogProtocols.DialogState]>
  public init(eventBus: DialogProtocols.EventBusServiceProtocol, sorter: Dialog_iOS.DialogSortingServiceProtocol)
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers final public class SpinnerBarButtonItem : UIKit.UIBarButtonItem {
  public static func createDefaultSpinner() -> UIKit.UIActivityIndicatorView
  @objc override final public var customView: UIKit.UIView? {
    @objc get
    @objc set
  }
  final public var spinner: UIKit.UIActivityIndicatorView {
    get
  }
  public init(spinner: UIKit.UIActivityIndicatorView = createDefaultSpinner())
  @objc override dynamic public init()
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers final public class SpinneredButton : UIKit.UIButton {
  final public var isLoading: Swift.Bool {
    get
    set
  }
  @objc dynamic public init()
  @objc override final public func layoutSubviews()
  @objc override final public func setTitleColor(_ color: UIKit.UIColor?, for state: UIKit.UIControl.State)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
extension Reactive where Base : Dialog_iOS.SpinneredButton {
  public var isLoading: RxCocoa.Binder<Swift.Bool> {
    get
  }
}
public enum StateMarker : Swift.Equatable {
  case image(UIKit.UIImage)
  case symbol(Swift.String)
  case none
  public static func == (a: Dialog_iOS.StateMarker, b: Dialog_iOS.StateMarker) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers final public class StateMarkerView : UIKit.UIControl {
  final public let imageView: UIKit.UIImageView
  final public let label: UIKit.UILabel
  final public var currentTargetView: UIKit.UIView?
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  final public var marker: Dialog_iOS.StateMarker {
    get
    set
  }
  @objc override final public func layoutSubviews()
  @objc override final public func sizeThatFits(_ size: CoreGraphics.CGSize) -> CoreGraphics.CGSize
  @objc override final public var intrinsicContentSize: CoreGraphics.CGSize {
    @objc get
  }
  @objc override final public func traitCollectionDidChange(_ previousTraitCollection: UIKit.UITraitCollection?)
  @objc deinit
}
extension Reactive where Base : Dialog_iOS.StateMarkerView {
  public var stateMarker: RxCocoa.Binder<Dialog_iOS.StateMarker> {
    get
  }
}
public struct StateValue<State, Value> {
}
public typealias ControlStateValue<Value> = Dialog_iOS.StateValue<Dialog_iOS.UIControlState, Value>
public struct StickerCollectionViewCellViewModel {
}
@_hasMissingDesignatedInitializers public class StickerCollectionViewModel {
  final public let sections: RxCocoa.Driver<[Dialog_iOS.StickerCollectionViewSection]>
  final public let stickerDidTapped: RxRelay.PublishRelay<DialogProtocols.DialogSticker>
  final public let scrollToPack: RxRelay.PublishRelay<Swift.Int>
  final public let didScrollToSection: RxRelay.PublishRelay<Swift.Int>
  @objc deinit
}
public struct StickerCollectionViewSection {
  public var items: [Dialog_iOS.StickerCollectionViewSection.Item]
  public init(title: Swift.String, items: [Dialog_iOS.StickerCollectionViewCellViewModel])
}
extension StickerCollectionViewSection : Differentiator.SectionModelType {
  public typealias Item = Dialog_iOS.StickerCollectionViewCellViewModel
  public init(original: Dialog_iOS.StickerCollectionViewSection, items: [Dialog_iOS.StickerCollectionViewCellViewModel])
}
public protocol SharedFilesLocalStorageFetcherProtocol : Dialog_iOS.SharedFilesServiceProtocol {
}
extension DialogMessage {
  public static func previuosMessages(forPeerId peerId: Swift.Int32, withContentType contentType: DialogProtocols.MessageContentType.RawValue, cursor: Swift.Int32, limit: Swift.Int32) -> (Swift.String, GRDB.StatementArguments?)
}
extension AttachmentCategory {
  public var mapTo: DialogProtocols.MessageContentType {
    get
  }
}
extension String {
  public func remove(characters: Foundation.CharacterSet) -> Swift.String
  public var toInt: Swift.Int32? {
    get
  }
  public var urlMatches: [Foundation.NSTextCheckingResult] {
    get
  }
  public subscript(bounds: Swift.CountableClosedRange<Swift.Int>) -> Swift.String {
    get
  }
  public subscript(bounds: Swift.CountableRange<Swift.Int>) -> Swift.String {
    get
  }
}
extension String.UTF16View {
  public subscript(bounds: Swift.CountableClosedRange<Swift.Int>) -> Swift.String? {
    get
  }
  public subscript(bounds: Swift.CountableRange<Swift.Int>) -> Swift.String? {
    get
  }
}
public protocol SubtitledSwitcherTableViewModelCellProtocol {
  var isActive: RxCocoa.Driver<Swift.Bool> { get }
  var title: RxCocoa.Driver<Swift.String> { get }
  var subTitle: RxCocoa.Driver<Swift.String?> { get }
  var switchToggledHandle: RxSwift.AnyObserver<Swift.Bool> { get }
  var switchInitSet: RxCocoa.Driver<Swift.Bool> { get }
}
@objc @_inheritsConvenienceInitializers public class SubtitledSwitcherTableViewCell : Dialog_iOS.DisposableTableViewCell, Dialog_iOS.Identifiable {
  public func bind(to viewModel: Dialog_iOS.SubtitledSwitcherTableViewModelCellProtocol)
  @objc deinit
  @available(iOS 3.0, *)
  @objc override dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
extension Container {
  @discardableResult
  final public func prepareForLogout(scope: Swinject.ObjectScopeProtocol) -> DialogProtocols.AuthUserEntry?
  final public func logout(user entry: DialogProtocols.AuthUserEntry)
}
extension Resolver {
  public func resolveActiveUser() -> DialogProtocols.AuthUserEntry?
  public func resolveMyId() -> DialogProtocols.DialogUserId?
}
public protocol SwinjectUserContainersServiceProtocol {
  func childContainer(user: DialogProtocols.AuthUserEntry, parent: Swinject.Container) -> Swinject.Container
  func checkChildContainerExist(user: DialogProtocols.AuthUserEntry) -> Swift.Bool
  func getResolver(user: DialogProtocols.AuthUserEntry) -> Swinject.Resolver?
  func destroyChildContainer(user: DialogProtocols.AuthUserEntry)
}
@_hasMissingDesignatedInitializers public class SwinjectUserContainersService : Dialog_iOS.SwinjectUserContainersServiceProtocol, Swift.CustomStringConvertible {
  public func childContainer(user: DialogProtocols.AuthUserEntry, parent: Swinject.Container) -> Swinject.Container
  public func getResolver(user: DialogProtocols.AuthUserEntry) -> Swinject.Resolver?
  public func checkChildContainerExist(user: DialogProtocols.AuthUserEntry) -> Swift.Bool
  public func destroyChildContainer(user: DialogProtocols.AuthUserEntry)
  public var description: Swift.String {
    get
  }
  @objc deinit
}
extension Container {
  final public func setupChildContainer(user: DialogProtocols.AuthUserEntry, registeringClosure: ((Swinject.Container) -> Swift.Void)? = nil) -> Swinject.Container
  final public func destroyChildContainer(user: DialogProtocols.AuthUserEntry)
}
extension Assembler {
  final public func registerDefaultDialogServices()
}
public protocol SwipeToReplyNodeDesign {
  var size: CoreGraphics.CGSize { get }
  var iconName: Swift.String { get }
  var iconColor: UIKit.UIColor { get }
  var showsBackground: Swift.Bool { get }
  var backgroundColor: UIKit.UIColor { get }
  var borderWidth: CoreGraphics.CGFloat { get }
  var borderColor: UIKit.UIColor { get }
}
@_hasMissingDesignatedInitializers public class SwipeToReplyNodeDefaultStyle : Dialog_iOS.SwipeToReplyNodeDesign {
  final public let size: CoreGraphics.CGSize
  final public let iconName: Swift.String
  final public let iconColor: UIKit.UIColor
  final public let showsBackground: Swift.Bool
  final public let backgroundColor: UIKit.UIColor
  final public let borderWidth: CoreGraphics.CGFloat
  final public let borderColor: UIKit.UIColor
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers public class SwipeToReplyNode : AsyncDisplayKit.ASDisplayNode {
  @objc override dynamic public func layoutSpecThatFits(_ constrainedSize: AsyncDisplayKit.ASSizeRange) -> AsyncDisplayKit.ASLayoutSpec
  @objc override dynamic public func didLoad()
  @objc override dynamic public init()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class SwitchNode : AsyncDisplayKit.ASDisplayNode {
  public var on: RxCocoa.ControlProperty<Swift.Bool>! {
    get
    set
  }
  convenience public init(color: RxCocoa.Driver<UIKit.UIColor>)
  @objc override dynamic public func didLoad()
  @objc override dynamic open func calculateSizeThatFits(_ constrainedSize: CoreGraphics.CGSize) -> CoreGraphics.CGSize
  @objc override dynamic public init()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers open class TapAreaButton : UIKit.UIButton {
  public var tapAreaInsets: UIKit.UIEdgeInsets
  @objc override dynamic open func point(inside point: CoreGraphics.CGPoint, with event: UIKit.UIEvent?) -> Swift.Bool
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public protocol PickerPresentableRx : Dialog_iOS.PickerPresentable {
  var showPicker: RxSwift.AnyObserver<Swift.Void> { get }
  var assets: RxSwift.Observable<Dialog_iOS.TypeAssetToMessages> { get }
}
public enum TextValidationResult {
  case valid
  case invalid(Swift.Error)
  public var isValid: Swift.Bool {
    get
  }
}
@objc @_inheritsConvenienceInitializers public class TextField : UIKit.UITextField, UIKit.UITextFieldDelegate {
  @objc override dynamic public var delegate: UIKit.UITextFieldDelegate? {
    @objc get
    @objc set
  }
  public var validationResult: Dialog_iOS.TextValidationResult {
    get
  }
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc override dynamic public func layoutSubviews()
  public func validate()
  @objc public func textField(_ textField: UIKit.UITextField, shouldChangeCharactersIn range: Foundation.NSRange, replacementString string: Swift.String) -> Swift.Bool
  public var formatter: Dialog_iOS.TextFormatterProtocol? {
    get
    set
  }
  public var validator: Dialog_iOS.TextValidatorProtocol? {
    get
    set
  }
  @objc deinit
}
extension Reactive where Base : Dialog_iOS.TextField {
  public var validationResult: RxSwift.Observable<Dialog_iOS.TextValidationResult> {
    get
  }
  public var validator: RxCocoa.ControlProperty<Dialog_iOS.TextValidatorProtocol?> {
    get
  }
  public var formatter: RxCocoa.ControlProperty<Dialog_iOS.TextFormatterProtocol?> {
    get
  }
}
@_inheritsConvenienceInitializers public class UiTextRxConfigurator<TF> : Dialog_iOS.AbstractRxConfigurator<TF> where TF : UIKit.UITextField {
  final public let text: RxSwift.AnyObserver<Swift.String?>
  final public let keyboardType: RxSwift.AnyObserver<UIKit.UIKeyboardType>
  final public let textContentType: RxSwift.AnyObserver<UIKit.UITextContentType>
  public init()
  override public func createBindings(to: TF) -> [RxSwift.Disposable]
  @objc deinit
}
@_inheritsConvenienceInitializers public class TextFieldRxConfigurator<TF> : Dialog_iOS.UiTextRxConfigurator<TF> where TF : Dialog_iOS.TextField {
  public var formatter: RxSwift.AnyObserver<Dialog_iOS.TextFormatterProtocol> {
    get
  }
  public var validator: RxSwift.AnyObserver<Dialog_iOS.TextValidatorProtocol> {
    get
  }
  override public func createBindings(to: TF) -> [RxSwift.Disposable]
  override public init()
  @objc deinit
}
public enum TextFormatResult {
  case denied(Swift.Error)
  case auto
  case formatted(Swift.String, selection: Dialog_iOS.TextFormatResult.Selection)
  public enum Selection {
    case begin
    case end
    case auto
    case positioned(Swift.Range<Swift.String.Index>)
  }
}
public protocol TextFormatterProtocol {
  func format<R>(replacement: Swift.String, in string: Swift.String?, at range: R) -> Dialog_iOS.TextFormatResult where R : Swift.RangeExpression, R.Bound == Swift.String.Index
}
public protocol TextValidatorProtocol {
  func validate(text: Swift.String) throws
}
@objc @_inheritsConvenienceInitializers final public class TextView : UIKit.UITextView {
  final public var underlineViewHeight: CoreGraphics.CGFloat {
    get
    set
  }
  final public var underlineInactiveColor: UIKit.UIColor {
    get
    set
  }
  final public var underlineActiveColor: UIKit.UIColor {
    get
    set
  }
  @objc override final public func willMove(toSuperview newSuperview: UIKit.UIView?)
  @objc override final public func layoutSubviews()
  @objc deinit
  @available(iOS 7.0, *)
  @objc override dynamic public init(frame: CoreGraphics.CGRect, textContainer: UIKit.NSTextContainer?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
extension Theme.Domain {
  public static let publicProfileScene: Dialog_iOS.Theme.Domain
  public static let publicProfileSceneActionCell: Dialog_iOS.Theme.Domain
}
extension Theme.Keys {
  public struct PublicProfileScene : Dialog_iOS.DomainSpecificKey, Swift.RawRepresentable {
    public static var domain: Dialog_iOS.Theme.Domain
    public var domainInternalId: Swift.String {
      get
    }
    public let rawValue: Swift.String
    public init(rawValue: Swift.String)
    public typealias RawValue = Swift.String
  }
}
extension Theme.Keys.PublicProfileScene {
  public struct ActionCell : Dialog_iOS.DomainSpecificKey, Swift.RawRepresentable {
    public static var domain: Dialog_iOS.Theme.Domain
    public var domainInternalId: Swift.String {
      get
    }
    public let rawValue: Swift.String
    public init(rawValue: Swift.String)
    public typealias RawValue = Swift.String
  }
}
extension Theme.Defaults {
  public static let publicProfileActionCell: DialogSharedComponents.Subtheme<Dialog_iOS.Theme.Keys.PublicProfileScene.ActionCell>
}
extension Theme.Keys.PublicProfileScene.ActionCell {
  public typealias Path = Dialog_iOS.Theme.Keys.PublicProfileScene.ActionCell
  public struct Tags {
  }
}
final public class CallInfoHoldService {
  public static let shared: Dialog_iOS.CallInfoHoldService
  public init(tokenFilename: Swift.String = "token.dat", endpointFilename: Swift.String = "endpoint.dat")
  final public func holdEndpoint(_ ep: Swift.String)
  final public func readEndpoint() -> Swift.String?
  final public func holdToken(_ token: Swift.String)
  final public func readToken() -> Swift.String?
  @objc deinit
}
extension CallInfoHoldService {
  final public func getInfo() throws -> (endpoint: Swift.String, token: Swift.String)?
}
public protocol TransferOwnerGroupCellViewModelProtocol : Dialog_iOS.BaseGroupPermissionCellViewModelProtocol {
  var title: RxCocoa.Driver<Swift.String> { get }
}
extension Transition {
  public static func dismiss(animation: XCoordinator.Animation? = nil, _ completion: @escaping () -> ()) -> XCoordinator.Transition<RootViewController>
}
extension UIAlertController {
  public static func fromContext(_ context: Dialog_iOS.DialogAlertContext, handler: (() -> Swift.Void)? = nil) -> UIKit.UIAlertController
}
extension UIActivityViewController {
  public static func fromContext(_ context: Dialog_iOS.DialogActivityContext) -> UIKit.UIActivityViewController
}
extension UIApplication {
  public class func getTopViewController(from baseViewController: UIKit.UIViewController? = UIApplication.shared.appWindow?.rootViewController) -> UIKit.UIViewController?
}
extension Reactive where Base : UIKit.UIApplication {
  public var badge: RxCocoa.Binder<Swift.Int> {
    get
  }
}
extension Reactive where Base : UIKit.UIButton {
  public func title(with attribute: [Foundation.NSAttributedString.Key : Any]?, for controlState: Dialog_iOS.UIControlState = []) -> RxCocoa.Binder<Swift.String?>
  public func titleFont() -> RxCocoa.Binder<UIKit.UIFont>
}
extension Reactive where Base : UIKit.UICollectionView {
  public func endEditing(force: Swift.Bool) -> RxCocoa.Binder<Swift.Void>
  public func deselect(animated: Swift.Bool) -> RxCocoa.Binder<Foundation.IndexPath>
}
extension UIFont {
  public static func scaledFont(for font: UIKit.UIFont, maximumPointSize: CoreGraphics.CGFloat = 25.0) -> UIKit.UIFont
  public static func scaledSystemFont(size: CoreGraphics.CGFloat, weight: UIKit.UIFont.Weight, maximumPointSize points: CoreGraphics.CGFloat = 25.0) -> UIKit.UIFont
  public func withTraits(_ traits: UIKit.UIFontDescriptor.SymbolicTraits...) -> UIKit.UIFont?
  public func bold() -> UIKit.UIFont?
  public func italic() -> UIKit.UIFont?
}
extension UIImage {
  public func resized(_ size: CoreGraphics.CGSize) -> UIKit.UIImage?
  public func resized(withAspectFit size: CoreGraphics.CGSize) -> UIKit.UIImage?
  public func cropped(by rect: CoreGraphics.CGRect) -> UIKit.UIImage
  public struct FlipOptions : Swift.OptionSet {
    public typealias RawValue = Swift.Int
    public let rawValue: UIKit.UIImage.FlipOptions.RawValue
    public init(rawValue: UIKit.UIImage.FlipOptions.RawValue)
    public static let none: UIKit.UIImage.FlipOptions
    public static let horizontal: UIKit.UIImage.FlipOptions
    public static let vertical: UIKit.UIImage.FlipOptions
    public static let both: UIKit.UIImage.FlipOptions
    public typealias Element = UIKit.UIImage.FlipOptions
    public typealias ArrayLiteralElement = UIKit.UIImage.FlipOptions
  }
  public static func byRenderingOneLineSelfSizingText(_ text: Swift.String, options: UIKit.NSStringDrawingOptions = [], fontSize: CoreGraphics.CGFloat) -> UIKit.UIImage
  public static func byRenderingOneLineSelfSizingText(_ text: Swift.String, options: UIKit.NSStringDrawingOptions = [], attributes: [Foundation.NSAttributedString.Key : Any]? = nil) -> UIKit.UIImage
  public static func byRenderingText(_ text: Swift.String, size: CoreGraphics.CGSize) -> UIKit.UIImage
  public func resizedImageTo(targetSize: CoreGraphics.CGSize) -> UIKit.UIImage?
}
extension CGImage {
  public func toData(options: Foundation.NSDictionary = [:], type: CoreFoundation.CFString = "image" as CFString) -> Foundation.Data?
}
extension UIImagePickerController {
  @objc override dynamic open var supportedInterfaceOrientations: UIKit.UIInterfaceOrientationMask {
    @objc get
  }
}
extension UIImageView {
  public var isActivityEnabled: Swift.Bool {
    get
    set(newValue)
  }
  public var activityStyle: UIKit.UIActivityIndicatorView.Style {
    get
    set(newValue)
  }
  public var activityIndicator: UIKit.UIActivityIndicatorView {
    get
    set(newValue)
  }
}
extension Reactive where Base : UIKit.UILabel {
  public var textColor: RxCocoa.Binder<UIKit.UIColor?> {
    get
  }
  public var numberOfLines: RxCocoa.Binder<Swift.Int> {
    get
  }
}
extension UILayoutPriority {
  public static let almostRequired: UIKit.UILayoutPriority
}
public enum NavigationItemInsertionPosition {
  public typealias CustomPositionCalculator = (([UIKit.UIBarButtonItem]) -> Swift.Int?)
  case first
  case last
  case custom(Dialog_iOS.NavigationItemInsertionPosition.CustomPositionCalculator)
}
extension UINavigationItem {
  public enum BarButtonSide : Swift.Hashable {
    case left
    case right
    public static func == (a: UIKit.UINavigationItem.BarButtonSide, b: UIKit.UINavigationItem.BarButtonSide) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public func barButtonItems(side: UIKit.UINavigationItem.BarButtonSide) -> [UIKit.UIBarButtonItem]?
  public func setBarButtonItems(_ items: [UIKit.UIBarButtonItem]?, side: UIKit.UINavigationItem.BarButtonSide, animated: Swift.Bool)
  public func replace(items: [UIKit.UIBarButtonItem], with item: UIKit.UIBarButtonItem?, side: UIKit.UINavigationItem.BarButtonSide, animated: Swift.Bool)
}
extension Reactive where Base : UIKit.UINavigationItem {
  public var leftBarButtonItem: RxCocoa.Binder<UIKit.UIBarButtonItem?> {
    get
  }
  public var backButtonItem: RxCocoa.Binder<UIKit.UIBarButtonItem?> {
    get
  }
  public var hidesBackButton: RxCocoa.Binder<Swift.Bool> {
    get
  }
  public func barButtonItems(side: UIKit.UINavigationItem.BarButtonSide, animated: Swift.Bool) -> RxCocoa.ControlProperty<[UIKit.UIBarButtonItem]?>
  public func setHidden(item: UIKit.UIBarButtonItem, side: UIKit.UINavigationItem.BarButtonSide, position: Dialog_iOS.NavigationItemInsertionPosition, animated: Swift.Bool) -> RxCocoa.Binder<Swift.Bool>
  public func replaceItem(oneOf items: [UIKit.UIBarButtonItem], side: UIKit.UINavigationItem.BarButtonSide, animated: Swift.Bool) -> RxCocoa.Binder<UIKit.UIBarButtonItem?>
}
extension Reactive where Base : UIKit.UITableView {
  public var footerView: RxCocoa.Binder<UIKit.UIView?> {
    get
  }
  public func setEditing(_ editing: Swift.Bool, animated: Swift.Bool) -> RxCocoa.Binder<Swift.Void>
  public func deselect(animated: Swift.Bool) -> RxCocoa.Binder<Foundation.IndexPath>
}
extension Reactive where Base : UIKit.UITableView {
  public func modelSelectedIfPresent<T>(_ modelType: T.Type) -> RxCocoa.ControlEvent<T>
}
extension Reactive where Base : UIKit.UITableViewCell {
  public var selected: RxCocoa.Binder<Swift.Bool> {
    get
  }
  public var title: RxCocoa.Binder<Swift.String?> {
    get
  }
}
extension Reactive where Base : UIKit.UITextField {
  public var keyboardType: RxCocoa.ControlProperty<UIKit.UIKeyboardType> {
    get
  }
  public var textContentType: RxCocoa.ControlProperty<UIKit.UITextContentType> {
    get
  }
}
extension Reactive where Base : UIKit.UIView {
  public var backgroundColor: RxCocoa.Binder<UIKit.UIColor?> {
    get
  }
  public func endEditing(_ force: Swift.Bool) -> RxCocoa.Binder<Swift.Void>
  public func tapGestureInScroll() -> RxSwift.Observable<UIKit.UITapGestureRecognizer>
}
extension Reactive where Base : UIKit.UIStackView {
  public var layoutMargins: RxCocoa.Binder<UIKit.UIEdgeInsets> {
    get
  }
}
extension Reactive where Base : UIKit.UIView {
  public var bounds: RxCocoa.Driver<CoreGraphics.CGRect> {
    get
  }
  public var frame: RxCocoa.Driver<CoreGraphics.CGRect> {
    get
  }
  public var safeAreaInsets: RxCocoa.Driver<UIKit.UIEdgeInsets> {
    get
  }
}
public protocol PickerPresentable {
  func showPicker(with configurator: DLGPicker.TelegramPickerConfigurator)
  func handlePickerSelection(_ selection: DLGPicker.TelegramSelectionType, sourceController controller: UIKit.UIViewController)
}
public protocol AvatarPickerPresentable : Dialog_iOS.PickerPresentable {
  func showAvatarPicker(with configurator: DLGPicker.TelegramPickerConfigurator, shouldShowRemovePhoto: Swift.Bool)
  func handleRemovePhoto(sourceController controller: UIKit.UIViewController)
}
extension PickerPresentable where Self : UIKit.UIViewController {
  public func showPicker(with configurator: DLGPicker.TelegramPickerConfigurator)
}
extension Reactive where Base : UIKit.UIViewController {
  public var tabBarItem: RxCocoa.Binder<UIKit.UITabBarItem> {
    get
  }
  public var viewDidLoad: RxCocoa.ControlEvent<Swift.Void> {
    get
  }
  public var viewDidDisappear: RxCocoa.ControlEvent<Swift.Void> {
    get
  }
  public var viewDidAppear: RxCocoa.ControlEvent<Swift.Bool> {
    get
  }
  public func onViewDidLoad() -> RxSwift.Observable<Swift.Void>
  public func onViewDidLoadWithLatest<E>(_ observable: RxSwift.Observable<E>) -> RxSwift.Observable<E>
}
public protocol UndefinedContentMessageCellDesignProtocol : Dialog_iOS.MessageContentDesignProtocol {
  var messageTextLabelAttributes: [Foundation.NSAttributedString.Key : Any] { get }
}
public struct DialogUndefinedContentMessageCellBubbleStyle : Dialog_iOS.UndefinedContentMessageCellDesignProtocol {
  public let messageTextLabelAttributes: [Foundation.NSAttributedString.Key : Any]
}
@objc @_hasMissingDesignatedInitializers final public class UnderlinedTextField : UIKit.UITextField {
  final public let underlineView: Dialog_iOS.UnderlineView
  @objc dynamic public init()
  @objc override final public func layoutSubviews()
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class UnderlineView : UIKit.UIView {
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc override dynamic public func layoutSubviews()
  public func setActive(_ active: Swift.Bool, animated: Swift.Bool = true)
  @objc deinit
}
extension Reactive where Base : Dialog_iOS.UnderlineView {
  public func isActive(animated: Swift.Bool) -> RxCocoa.Binder<Swift.Bool>
  public var activeColor: RxCocoa.Binder<UIKit.UIColor?> {
    get
  }
  public var inactiveColor: RxCocoa.Binder<UIKit.UIColor?> {
    get
  }
}
public protocol UnknownActiveUserPushHandlerProtocol {
  func handle(event: Dialog_iOS.PushEvent, protectedDataAvailable: Swift.Bool)
}
final public class UnknownActiveUserPushHandler : Dialog_iOS.UnknownActiveUserPushHandlerProtocol {
  public init(callKitProvider: Dialog_iOS.AppCallKitProviderProtocol)
  final public func handle(event: Dialog_iOS.PushEvent, protectedDataAvailable: Swift.Bool)
  @objc deinit
}
extension UNUserNotificationCenter {
  public static let kLockedScreenCallNotificationDelay: Swift.Double
  public enum Incident {
    case noMicrophoneAccessForCall
    case noCameraAccessForCall
    case protectedDataUnavailable
    public static func == (a: UserNotifications.UNUserNotificationCenter.Incident, b: UserNotifications.UNUserNotificationCenter.Incident) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public func add(for incident: UserNotifications.UNUserNotificationCenter.Incident, completion: ((Swift.Error?) -> Swift.Void)? = nil)
}
extension UNNotificationContent {
  public static func with(block: (UserNotifications.UNMutableNotificationContent) throws -> Swift.Void) rethrows -> UserNotifications.UNNotificationContent
}
public protocol UnreadCounterServiceProtocol {
  var counter: RxSwift.Observable<[DialogProtocols.DialogPeerId : DialogProtocols.DialogGroupUnreadCountState]> { get }
}
final public class UnreadCounterService : Dialog_iOS.UnreadCounterServiceProtocol {
  final public let counter: RxSwift.Observable<[DialogProtocols.DialogPeerId : DialogProtocols.DialogGroupUnreadCountState]>
  public static let kunreadUpdateDebounceInterval: Dispatch.DispatchTimeInterval
  public init(eventBus: DialogProtocols.EventBusServiceProtocol, muteService: DialogMuteSettingsService.DialogMuteSettingsServiceProtocol, notificationsService: DialogProtocols.GlobalNotificationsSettingsConfigServiceProtocol, debounceInterval: RxSwift.RxTimeInterval = UnreadCounterService.kunreadUpdateDebounceInterval)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class UnreadMessageCellNodeDefaultStyle {
  final public let prefferedHeight: CoreGraphics.CGFloat
  final public let prefferedBorderHeight: CoreGraphics.CGFloat
  final public let textHorizontalPadding: CoreGraphics.CGFloat
  public var textFont: UIKit.UIFont {
    get
  }
  final public let textColor: UIKit.UIColor
  final public let borderColor: UIKit.UIColor
  final public let backgroundColor: UIKit.UIColor
  @objc deinit
}
public struct UnreadMessageCellViewModel : Dialog_iOS.MessageCellViewModelProtocol {
  public let text: RxSwift.Observable<Swift.String>
  public var identity: Dialog_iOS.MessageCellViewModelIdentity {
    get
  }
}
extension UnreadMessageCellViewModel : Swift.Equatable {
  public static func == (lhs: Dialog_iOS.UnreadMessageCellViewModel, rhs: Dialog_iOS.UnreadMessageCellViewModel) -> Swift.Bool
}
extension Reactive where Base : UserNotifications.UNUserNotificationCenter {
  public func getSettings() -> RxSwift.Single<UserNotifications.UNNotificationSettings>
}
public protocol UserActivityHandlerProtocol {
  func application(_ application: UIKit.UIApplication, continue userActivity: Foundation.NSUserActivity, restorationHandler: @escaping ([UIKit.UIUserActivityRestoring]?) -> Swift.Void) -> Swift.Bool
}
public struct UserActivityHandlerConfig {
  public let userAwaitTimeToMakeCall: Dispatch.DispatchTimeInterval
  public static let `default`: Dialog_iOS.UserActivityHandlerConfig
}
final public class UserActivityHandler : Dialog_iOS.UserActivityHandlerProtocol {
  public init(appAuthStateService: Dialog_iOS.AppAuthStateServiceProtocol, resolversProvider: Dialog_iOS.SwinjectUserContainersServiceProtocol, config: Dialog_iOS.UserActivityHandlerConfig)
  final public func application(_ application: UIKit.UIApplication, continue userActivity: Foundation.NSUserActivity, restorationHandler: @escaping ([UIKit.UIUserActivityRestoring]?) -> Swift.Void) -> Swift.Bool
  @objc deinit
}
public protocol UserAssociatedServicesRegistrarProtocol {
  func registerServices(user: DialogProtocols.AuthUserEntry, inContainer container: Swinject.Container)
}
final public class UserAssociatedServicesRegistrar : Dialog_iOS.UserAssociatedServicesRegistrarProtocol {
  final public let assembler: Swinject.Assembly
  public init(assembler: Swinject.Assembly)
  final public func registerServices(user: DialogProtocols.AuthUserEntry, inContainer container: Swinject.Container)
  @objc deinit
}
public protocol UsernameAndEndpointResolveServiceProtocol {
  func resolveUsername(from source: Swift.String?, with separator: Swift.Character) -> Swift.String?
  func resolveEndpoint(from source: Swift.String?, with separator: Swift.Character) -> Swift.String?
}
public protocol UsernameValidationServiceProtocol {
  func validate(username: Swift.String) -> Dialog_iOS.UsernameValidationServiceResult
}
public enum UsernameValidationServiceResult : Swift.Equatable {
  case valid
  case invalid(reason: Swift.String)
  public var isValid: Swift.Bool {
    get
  }
  public static func == (a: Dialog_iOS.UsernameValidationServiceResult, b: Dialog_iOS.UsernameValidationServiceResult) -> Swift.Bool
}
final public class UserPresenceStateService : DialogProtocols.UserPresenceStateServiceProtocol {
  final public var subscribeToTypings: RxSwift.AnyObserver<[DialogProtocols.DialogPeer]>
  final public var sendTyping: RxSwift.AnyObserver<(peer: DialogProtocols.DialogPeer, isTyping: Swift.Bool)>
  public init(eventBusService: DialogProtocols.EventBusServiceProtocol, updatesService: DialogMessaging.DialogWeakUpdatesServiceObjcProtocol, storageService: DialogStorage.DialogStorageServiceProtocol, featureFlagsService: DialogProtocols.DialogFeatureFlagsServiceProtocol)
  final public func perform(request: DialogProtocols.UserPresenceRequest)
  @objc deinit
}
public struct UserSectionHeaderViewStyle {
  public var tintColor: UIKit.UIColor
  public var infoColor: UIKit.UIColor
  public var infoFont: UIKit.UIFont {
    get
  }
  public var backgroundColor: UIKit.UIColor
  public var animationDuration: Swift.Double
  public init(attrs: Dialog_iOS.BasicAppTheme)
}
@objc @_inheritsConvenienceInitializers public class UserSectionHeaderView : UIKit.UIView {
  public typealias VM = Dialog_iOS.UserSectionHeaderViewModelProtocol
  public func bind(to viewModel: Dialog_iOS.UserSectionHeaderView.VM, style: Dialog_iOS.UserSectionHeaderViewStyle)
  @objc override dynamic public func updateConstraints()
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public protocol UserSectionHeaderViewModelProtocol : Dialog_iOS.ViewModelProtocol {
  var title: RxCocoa.Driver<Swift.String?> { get }
  var info: RxCocoa.Driver<Swift.String?> { get }
  var isHidden: Swift.Bool { get }
}
public class UserSectionHeaderViewModel : Dialog_iOS.UserSectionHeaderViewModelProtocol {
  public var title: RxCocoa.Driver<Swift.String?>
  public var info: RxCocoa.Driver<Swift.String?>
  public var isHidden: Swift.Bool
  public init(title: RxCocoa.Driver<Swift.String?>, info: RxCocoa.Driver<Swift.String?>, isHidden: Swift.Bool)
  public init(title: Swift.String?, info: Swift.String? = nil, isHidden: Swift.Bool)
  @objc deinit
}
public protocol UserSpecificServiceLauncherProtocol {
  func launchServices(resolver: Swinject.Resolver)
}
open class UserSpecificServiceLauncher : Dialog_iOS.UserSpecificServiceLauncherProtocol {
  public struct Config {
    public static let `default`: Dialog_iOS.UserSpecificServiceLauncher.Config
    public let needStartPushNotificationsService: Swift.Bool
    public let needStartCallsIntentsService: Swift.Bool
    public init(needStartPushNotificationsService: Swift.Bool = true, needStartCallsIntentsService: Swift.Bool = true)
  }
  public var config: Dialog_iOS.UserSpecificServiceLauncher.Config
  public init(config: Dialog_iOS.UserSpecificServiceLauncher.Config)
  @objc deinit
  public func launchServices(resolver: Swinject.Resolver)
}
public protocol UserStatusViewModelProtocol {
  var isPrivate: Swift.Bool { get }
  var typingChanged: RxRelay.BehaviorRelay<[Swift.String]> { get }
  var onlineChanged: RxRelay.BehaviorRelay<Swift.String?> { get }
  var onlineState: RxRelay.BehaviorRelay<Swift.Bool> { get }
  var isOnList: Swift.Bool { get }
}
public protocol UserVOIPNotificationsServiceProtocol {
  var pushEvent: RxSwift.AnyObserver<Dialog_iOS.PushEvent> { get }
  func unregisterActiveVoipToken() -> RxSwift.Single<Swift.Void>
}
final public class UserVOIPNotificationsService : Dialog_iOS.UserVOIPNotificationsServiceProtocol {
  final public let pushEvent: RxSwift.AnyObserver<Dialog_iOS.PushEvent>
  public init(registrar: DialogNotifications.DialogNotificationsTokenRegistrarProtocol, actualToken: RxSwift.Observable<Swift.String?>, config: Dialog_iOS.DialogPushConfig?)
  final public func unregisterActiveVoipToken() -> RxSwift.Single<Swift.Void>
  @objc deinit
}
public protocol FileSizeInfoDesignProtocol {
  var fileSizeInfoTextAttributes: [Foundation.NSAttributedString.Key : Any]? { get }
  var fileSizeInfoInsets: UIKit.UIEdgeInsets { get }
  var fileSizeInfoWrapperInsets: UIKit.UIEdgeInsets { get }
  var fileSizeInfoBackgroundColor: UIKit.UIColor { get }
  var fileSizeInfoWrapperCornerType: Dialog_iOS.CornerRadiusType { get }
}
public protocol VideoMessageDesignProtocol : Dialog_iOS.FileSizeInfoDesignProtocol, Dialog_iOS.MessageContentDesignProtocol {
  var messageVideoCornerRadius: Dialog_iOS.CornerRadiusType { get }
  var messageMaxVideoHeight: CoreGraphics.CGFloat { get }
}
public protocol EasyRegisterableViewModelDrivenSceneProtocol : Dialog_iOS.ViewModelDrivenSceneBuilderProtocol {
  func defaultViewModelRegistrator() -> ((Swinject.Resolver, Self.Arg) -> Self.ViewModel)?
  func defaultdefaultViewControllerRegistrator() -> ((Swinject.Resolver, Self.ViewModel, Self.Arg) -> Self.ViewController)?
  static func defaultViewModel(resolver: Swinject.Resolver, arg: Self.Arg) -> Self.ViewModel
  static func defaultViewController(resolver: Swinject.Resolver, viewModel: Self.ViewModel, arg: Self.Arg) -> Self.ViewController
}
public protocol ViewModelDrivenSceneBuilderProtocol : Dialog_iOS.SceneBuilderProtocol {
  associatedtype ViewModel
  associatedtype Arg = Dialog_iOS.SceneArgument<Self.MainArgument>
}
public protocol SceneViewControllerViewModelBindable {
  associatedtype ViewModel
  func bind(viewModel: Self.ViewModel)
}
@_hasMissingDesignatedInitializers open class ViewModelDrivenSceneBuilder<MainArg, VC, VM> : Dialog_iOS.ViewModelDrivenSceneBuilderProtocol where VC : UIKit.UIViewController {
  public func build(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<MainArg>) -> VC
  public typealias MainArgument = MainArg
  public typealias ViewController = VC
  public typealias ViewModel = VM
  open func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Dialog_iOS.ViewModelDrivenSceneBuilder<MainArg, VC, VM>.MainArgument>) -> Dialog_iOS.ViewModelDrivenSceneBuilder<MainArg, VC, VM>.ViewModel
  open func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.ViewModelDrivenSceneBuilder<MainArg, VC, VM>.Arg, viewModel: Dialog_iOS.ViewModelDrivenSceneBuilder<MainArg, VC, VM>.ViewModel) -> Dialog_iOS.ViewModelDrivenSceneBuilder<MainArg, VC, VM>.ViewController
  public typealias Arg = Dialog_iOS.SceneArgument<Dialog_iOS.ViewModelDrivenSceneBuilder<MainArg, VC, VM>.MainArgument>
  @objc deinit
}
public protocol ViewModelProtocol : AnyObject {
}
public protocol ViewProtocol {
  associatedtype VM : Dialog_iOS.ViewModelProtocol
  var viewModel: Self.VM { get }
  init(viewModel: Self.VM)
  func bind(to viewModel: Self.VM)
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class ViewRxConfigurator<View> : Dialog_iOS.AbstractRxConfigurator<View> where View : UIKit.UIView {
  public var backgroundColor: RxSwift.AnyObserver<UIKit.UIColor?> {
    get
  }
  public var alpha: RxSwift.AnyObserver<CoreGraphics.CGFloat> {
    get
  }
  override public func createBindings(to: View) -> [RxSwift.Disposable]
  @objc deinit
}
public protocol VoIPNotificationsHandlingServiceProtocol : Dialog_iOS.ProtectedDataIndependentServiceProtocol {
  var pushEvents: RxSwift.AnyObserver<Dialog_iOS.PushEvent> { get }
}
final public class VoIPNotificationsHandlingService : Dialog_iOS.VoIPNotificationsHandlingServiceProtocol {
  final public var pushEvents: RxSwift.AnyObserver<Dialog_iOS.PushEvent> {
    get
  }
  public init(callKitAdapter: DialogCalls.CallKitAdapterProtocol, callStateService: DialogCalls.CallsStateServiceProtocol, networkService: DialogCalls.CallsNetworkingServiceProtocol)
  @objc deinit
}
@_inheritsConvenienceInitializers final public class WebViewScene : Dialog_iOS.Scene<Foundation.URL, UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.WebViewScene.Builder
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<Foundation.URL, UIKit.UIViewController, Dialog_iOS.DUIWebViewToolbarProxyProtocol> {
    override final public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Foundation.URL>) -> Dialog_iOS.DUIWebViewToolbarProxyProtocol
    override final public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Foundation.URL>, viewModel: Dialog_iOS.DUIWebViewToolbarProxyProtocol) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<Foundation.URL, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
@_inheritsConvenienceInitializers final public class MiniAppWebViewScene : Dialog_iOS.Scene<Foundation.URL, UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.MiniAppWebViewScene.Builder
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class DefaultBuilder : Dialog_iOS.ViewModelDrivenSceneBuilder<Foundation.URL, UIKit.UIViewController, Dialog_iOS.DUIWebViewToolbarProxyProtocol> {
    override final public func createViewModel(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Foundation.URL>) -> Dialog_iOS.DUIWebViewToolbarProxyProtocol
    override final public func createViewController(resolver: Swinject.Resolver, argument: Dialog_iOS.SceneArgument<Foundation.URL>, viewModel: Dialog_iOS.DUIWebViewToolbarProxyProtocol) -> UIKit.UIViewController
    @objc deinit
  }
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<Foundation.URL, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
@_inheritsConvenienceInitializers final public class WhatsNewPreviewScene : Dialog_iOS.Scene<Swift.Void, UIKit.UIViewController> {
  override final public class func defaultSceneBuilder() -> Dialog_iOS.WhatsNewPreviewScene.Builder
  @objc deinit
  required public init(builder: Dialog_iOS.Scene<Swift.Void, UIKit.UIViewController>.Builder = super, resolver: Swinject.Resolver)
}
extension Reactive where Base : WebKit.WKWebView {
  public var title: RxSwift.Observable<Swift.String?> {
    get
  }
  public var loading: RxSwift.Observable<Swift.Bool> {
    get
  }
  public var estimatedProgress: RxSwift.Observable<Swift.Double> {
    get
  }
  public var url: RxSwift.Observable<Foundation.URL?> {
    get
  }
  public var canGoBack: RxSwift.Observable<Swift.Bool> {
    get
  }
  public var canGoForward: RxSwift.Observable<Swift.Bool> {
    get
  }
  public func evaluateJavaScript(_ javaScriptString: Swift.String) -> RxSwift.Observable<Any?>
}
extension Transition {
  public static func multiple(_ transitions: XCoordinator.Transition<RootViewController>..., animated: Swift.Bool) -> XCoordinator.Transition<RootViewController>
  public static func multiple<C>(_ transitions: C, animated: Swift.Bool) -> XCoordinator.Transition<RootViewController> where C : Swift.Collection, C.Element == XCoordinator.Transition<RootViewController>
  public static func dismissNonanimated(animation: XCoordinator.Animation? = nil, completion: XCoordinator.PresentationHandler? = nil) -> XCoordinator.Transition<RootViewController>
}
extension Transition where RootViewController == UIKit.UITabBarController {
  public static func select(_ presentable: XCoordinator.Presentable, animation: XCoordinator.Animation? = nil, animated: Swift.Bool) -> XCoordinator.Transition<RootViewController>
}
extension Dialog_iOS.ActiveCallButtonsPanelView.Distribution : Swift.Equatable {}
extension Dialog_iOS.ActiveCallButtonsPanelView.Distribution : Swift.Hashable {}
extension Dialog_iOS.PresentConflictPolicy : Swift.Equatable {}
extension Dialog_iOS.PresentConflictPolicy : Swift.Hashable {}
extension Dialog_iOS.DeletableAccess : Swift.Equatable {}
extension Dialog_iOS.DeletableAccess : Swift.Hashable {}
extension Dialog_iOS.ActiveSessionCellViewModel : Dialog_iOS.ActiveSessionCellViewModelParentProtocol {}
extension Dialog_iOS.AppFlowState : Swift.Equatable {}
extension Dialog_iOS.AppFlowState : Swift.Hashable {}
extension Dialog_iOS.AppFlowState : Swift.RawRepresentable {}
extension Dialog_iOS.ApprovalCodeRequestTimeoutService.State : Swift.Equatable {}
extension Dialog_iOS.ApprovalCodeRequestTimeoutService.State : Swift.Hashable {}
extension Dialog_iOS.CheckVersionError : Swift.Equatable {}
extension Dialog_iOS.CheckVersionError : Swift.Hashable {}
extension Dialog_iOS.AssetsServiceCroppingType : Swift.Equatable {}
extension Dialog_iOS.AssetsServiceCroppingType : Swift.Hashable {}
extension Dialog_iOS.AttachmentsViewControllerState : Swift.Equatable {}
extension Dialog_iOS.AttachmentsViewControllerState : Swift.Hashable {}
extension Dialog_iOS.AudioPortType : Swift.Equatable {}
extension Dialog_iOS.AudioPortType : Swift.Hashable {}
extension Dialog_iOS.SupportedAudioPortOutputType : Swift.Hashable {}
extension Dialog_iOS.AuthCertificateStartPermission : Swift.Equatable {}
extension Dialog_iOS.AuthCertificateStartPermission : Swift.Hashable {}
extension Dialog_iOS.AuthTypeCellViewModel : Dialog_iOS.ViewModelProtocol {}
extension Dialog_iOS.AuthTypesSection.Kind : Swift.Equatable {}
extension Dialog_iOS.AuthTypesSection.Kind : Swift.Hashable {}
extension Dialog_iOS.AuthUIViewModelLoginMode : Swift.Equatable {}
extension Dialog_iOS.AuthUIViewModelLoginMode : Swift.Hashable {}
extension Dialog_iOS.AuthUIViewModelLoginMode : Swift.RawRepresentable {}
extension Dialog_iOS.AvatarPreviewItemError : Swift.Equatable {}
extension Dialog_iOS.AvatarPreviewItemError : Swift.Hashable {}
extension Dialog_iOS.BatchFetchingDirection : Swift.Equatable {}
extension Dialog_iOS.BatchFetchingDirection : Swift.Hashable {}
extension Dialog_iOS.BatchFetchingDirection : Swift.RawRepresentable {}
extension Dialog_iOS.BundleLookupStrategy : Swift.Equatable {}
extension Dialog_iOS.BundleLookupStrategy : Swift.Hashable {}
extension Dialog_iOS.CallActionViewButtonStyle : Swift.Equatable {}
extension Dialog_iOS.CallActionViewButtonStyle : Swift.Hashable {}
extension Dialog_iOS.CallTogglableActionViewModel.State : Swift.Equatable {}
extension Dialog_iOS.CallTogglableActionViewModel.State : Swift.Hashable {}
extension Dialog_iOS.CallKitAdapterError : Swift.Equatable {}
extension Dialog_iOS.CallKitAdapterError : Swift.Hashable {}
extension Dialog_iOS.CallTryResult : Swift.Equatable {}
extension Dialog_iOS.CallTryResult : Swift.Hashable {}
extension Dialog_iOS.CallsHistorySegmentType : Swift.Equatable {}
extension Dialog_iOS.CallsHistorySegmentType : Swift.Hashable {}
extension Dialog_iOS.CallsHistorySegmentType : Swift.RawRepresentable {}
extension Dialog_iOS.CallsHistoryEditingOptionType : Swift.Equatable {}
extension Dialog_iOS.CallsHistoryEditingOptionType : Swift.Hashable {}
extension Dialog_iOS.MissedCountUpdatePolicy : Swift.Equatable {}
extension Dialog_iOS.MissedCountUpdatePolicy : Swift.Hashable {}
extension Dialog_iOS.CallVideoViewContentMode : Swift.Equatable {}
extension Dialog_iOS.CallVideoViewContentMode : Swift.Hashable {}
extension Dialog_iOS.PlaceholderState : Swift.Equatable {}
extension Dialog_iOS.PlaceholderState : Swift.Hashable {}
extension Dialog_iOS.ConversationEventBusInputBarState.JoinState : Swift.Equatable {}
extension Dialog_iOS.ConversationEventBusInputBarState.JoinState : Swift.Hashable {}
extension Dialog_iOS.ConversationSelectionMode : Swift.Hashable {}
extension Dialog_iOS.CallIconType.DisplayMode : Swift.Equatable {}
extension Dialog_iOS.CallIconType.DisplayMode : Swift.Hashable {}
extension Dialog_iOS.CreateDialogType : Swift.Equatable {}
extension Dialog_iOS.CreateDialogType : Swift.Hashable {}
extension Dialog_iOS.CreateDialogOptionsModel.GroupType : Swift.Equatable {}
extension Dialog_iOS.CreateDialogOptionsModel.GroupType : Swift.Hashable {}
extension Dialog_iOS.CreateDialogOptionsModel.GroupType : Swift.RawRepresentable {}
extension Dialog_iOS.CreateNewConferenceNameValidationType : Swift.Equatable {}
extension Dialog_iOS.CreateNewConferenceNameValidationType : Swift.Hashable {}
extension Dialog_iOS.CreateNewConferenceNameValidationType : Swift.RawRepresentable {}
extension Dialog_iOS.CreateNewDialogNameValidationType : Swift.Equatable {}
extension Dialog_iOS.CreateNewDialogNameValidationType : Swift.Hashable {}
extension Dialog_iOS.CreateNewDialogNameValidationType : Swift.RawRepresentable {}
extension Dialog_iOS.CreateNewDialogDescriptionValidationType : Swift.Equatable {}
extension Dialog_iOS.CreateNewDialogDescriptionValidationType : Swift.Hashable {}
extension Dialog_iOS.CreateNewDialogDescriptionValidationType : Swift.RawRepresentable {}
extension Dialog_iOS.CreateNewDialogCreateLinkValidationType : Swift.Equatable {}
extension Dialog_iOS.CreateNewDialogCreateLinkValidationType : Swift.Hashable {}
extension Dialog_iOS.CreateNewDialogCreateLinkValidationType : Swift.RawRepresentable {}
extension Dialog_iOS.DateComponentRange.Component : Swift.Equatable {}
extension Dialog_iOS.DateComponentRange.Component : Swift.Hashable {}
extension Dialog_iOS.DialogAuthConfig.Strategy : Swift.Equatable {}
extension Dialog_iOS.DialogAuthConfig.Strategy : Swift.Hashable {}
extension Dialog_iOS.DialogAlertButtonsConfigError : Swift.Equatable {}
extension Dialog_iOS.DialogAlertButtonsConfigError : Swift.Hashable {}
extension Dialog_iOS.DialogAlertContext.IdempotentId : Swift.Equatable {}
extension Dialog_iOS.DialogAlertContext.IdempotentId : Swift.Hashable {}
extension Dialog_iOS.DialogAlertContext.IdempotentId : Swift.RawRepresentable {}
extension Dialog_iOS.DialogGroupType : Swift.Equatable {}
extension Dialog_iOS.DialogGroupType : Swift.Hashable {}
extension Dialog_iOS.DialogGroupType : Swift.RawRepresentable {}
extension Dialog_iOS.DialogListSearchTableData.SectionKind : Swift.Hashable {}
extension Dialog_iOS.DialogListSearchViewModel.Config.UserTapBehavior : Swift.Equatable {}
extension Dialog_iOS.DialogListSearchViewModel.Config.UserTapBehavior : Swift.Hashable {}
extension Dialog_iOS.DialogListSearchViewModel.Mode : Swift.Equatable {}
extension Dialog_iOS.DialogListSearchViewModel.Mode : Swift.Hashable {}
extension Dialog_iOS.DialogTextMessageBubbleStyle : Dialog_iOS.MessageContentDesignProtocol {}
extension Dialog_iOS.DialogMyTextMessageBubbleStyle : Dialog_iOS.MessageContentDesignProtocol {}
extension Dialog_iOS.DialogSwipeButtonTypeConfigType : Swift.Equatable {}
extension Dialog_iOS.DialogSwipeButtonTypeConfigType : Swift.Hashable {}
extension Dialog_iOS.DialogSwipeButtonTypeConfigType : Swift.RawRepresentable {}
extension Dialog_iOS.DialogsListSection.SectionType : Swift.Equatable {}
extension Dialog_iOS.DialogsListSection.SectionType : Swift.Hashable {}
extension Dialog_iOS.DialogsListSection.SectionType : Swift.RawRepresentable {}
extension Dialog_iOS.DiscoverRoute : Swift.Equatable {}
extension Dialog_iOS.DiscoverRoute : Swift.Hashable {}
extension Dialog_iOS.DLGOperationState : Swift.Equatable {}
extension Dialog_iOS.DLGOperationState : Swift.Hashable {}
extension Dialog_iOS.ValidationState : Swift.Equatable {}
extension Dialog_iOS.ValidationState : Swift.Hashable {}
extension Dialog_iOS.TextValidationReasons : Swift.Equatable {}
extension Dialog_iOS.TextValidationReasons : Swift.Hashable {}
extension Dialog_iOS.TextValidationReasons : Swift.RawRepresentable {}
extension Dialog_iOS.DUICellConfiguratorAssociationPolicy : Swift.Equatable {}
extension Dialog_iOS.DUICellConfiguratorAssociationPolicy : Swift.Hashable {}
extension Dialog_iOS.DUICommonCellType : Swift.Equatable {}
extension Dialog_iOS.DUICommonCellType : Swift.Hashable {}
extension Dialog_iOS.DUICommonCellType : Swift.RawRepresentable {}
extension Dialog_iOS.DUIContactCellViewModel.AccessoryKind : Swift.Equatable {}
extension Dialog_iOS.DUIContactCellViewModel.AccessoryKind : Swift.Hashable {}
extension Dialog_iOS.DialogCellHeaderItemType : Swift.Equatable {}
extension Dialog_iOS.DialogCellHeaderItemType : Swift.Hashable {}
extension Dialog_iOS.DialogCellHeaderItemType : Swift.RawRepresentable {}
extension Dialog_iOS.DUIHistoryCallResult : Swift.Equatable {}
extension Dialog_iOS.DUIHistoryCallResult : Swift.Hashable {}
extension Dialog_iOS.DUIInviteUserState : Swift.Equatable {}
extension Dialog_iOS.DUIInviteUserState : Swift.Hashable {}
extension Dialog_iOS.DUIInviteUserState : Swift.RawRepresentable {}
extension Dialog_iOS.DUITextCellSinglelineStyle.DUITextCellSinglelineSeparatorType : Swift.Equatable {}
extension Dialog_iOS.DUITextCellSinglelineStyle.DUITextCellSinglelineSeparatorType : Swift.Hashable {}
extension Dialog_iOS.DUIToolBarItem : Swift.Equatable {}
extension Dialog_iOS.DUIToolBarItem : Swift.Hashable {}
extension Dialog_iOS.DUIToolBarItem : Swift.RawRepresentable {}
extension Dialog_iOS.MiniAppOpenDiscoverUrlType : Swift.Hashable {}
extension Dialog_iOS.ForwardTargetListInapplicableItemPolicy : Swift.Equatable {}
extension Dialog_iOS.ForwardTargetListInapplicableItemPolicy : Swift.Hashable {}
extension Dialog_iOS.GlobalNotificationError : Swift.Equatable {}
extension Dialog_iOS.GlobalNotificationError : Swift.Hashable {}
extension Dialog_iOS.GroupLinkType : Swift.Equatable {}
extension Dialog_iOS.GroupLinkType : Swift.Hashable {}
extension Dialog_iOS.GroupLinkType : Swift.RawRepresentable {}
extension Dialog_iOS.GroupProfileCellType : Swift.Equatable {}
extension Dialog_iOS.GroupProfileCellType : Swift.Hashable {}
extension Dialog_iOS.GroupProfileCellType : Swift.RawRepresentable {}
extension Dialog_iOS.GroupsOfNotificationSetting : Swift.Hashable {}
extension Dialog_iOS.IGError : Swift.Equatable {}
extension Dialog_iOS.IGError : Swift.Hashable {}
extension Dialog_iOS.MimeType : Swift.Equatable {}
extension Dialog_iOS.MimeType : Swift.Hashable {}
extension Dialog_iOS.MimeType : Swift.RawRepresentable {}
extension Dialog_iOS.IGLayoutType : Swift.Equatable {}
extension Dialog_iOS.IGLayoutType : Swift.Hashable {}
extension Dialog_iOS.LeaveGroupError : Swift.Equatable {}
extension Dialog_iOS.LeaveGroupError : Swift.Hashable {}
extension Dialog_iOS.MessageActionError : Swift.Equatable {}
extension Dialog_iOS.MessageActionError : Swift.Hashable {}
extension Dialog_iOS.MultiforwardTargetSectionType : Swift.Equatable {}
extension Dialog_iOS.MultiforwardTargetSectionType : Swift.Hashable {}
extension Dialog_iOS.MultiforwardTargetSectionType : Swift.RawRepresentable {}
extension Dialog_iOS.NewEventBusError : Swift.Equatable {}
extension Dialog_iOS.NewEventBusError : Swift.Hashable {}
extension Dialog_iOS.NotificationKey.MissedCall : Swift.Equatable {}
extension Dialog_iOS.NotificationKey.MissedCall : Swift.Hashable {}
extension Dialog_iOS.NotificationKey.MissedCall : Swift.RawRepresentable {}
extension Dialog_iOS.TargetIndexType : Swift.Equatable {}
extension Dialog_iOS.TargetIndexType : Swift.Hashable {}
extension Dialog_iOS.PhoneValidationError : Swift.Equatable {}
extension Dialog_iOS.PhoneValidationError : Swift.Hashable {}
extension Dialog_iOS.PrivateProfileRoute : Swift.Equatable {}
extension Dialog_iOS.PrivateProfileRoute : Swift.Hashable {}
extension Dialog_iOS.PrivateProfileViewModel : Dialog_iOS.ViewModelProtocol {}
extension Dialog_iOS.PublicProfileCellType : Swift.Equatable {}
extension Dialog_iOS.PublicProfileCellType : Swift.Hashable {}
extension Dialog_iOS.PublicProfileCellType : Swift.RawRepresentable {}
extension Dialog_iOS.PushRegistryServiceRequest : Swift.Equatable {}
extension Dialog_iOS.PushRegistryServiceRequest : Swift.Hashable {}
@available(*, unavailable, renamed: "Connection")
extension Dialog_iOS.Reachability.NetworkStatus : Swift.Equatable {}
@available(*, unavailable, renamed: "Connection")
extension Dialog_iOS.Reachability.NetworkStatus : Swift.Hashable {}
extension Dialog_iOS.Reachability.Connection : Swift.Equatable {}
extension Dialog_iOS.Reachability.Connection : Swift.Hashable {}
extension Dialog_iOS.Server : DialogProtocols.ServerSettingsRepresentable {}
extension UserNotifications.UNUserNotificationCenter.Incident : Swift.Equatable {}
extension UserNotifications.UNUserNotificationCenter.Incident : Swift.Hashable {}
