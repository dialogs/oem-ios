// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.3.1 (swiftlang-1200.0.41 clang-1200.0.32.8)
// swift-module-flags: -target x86_64-apple-ios11.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name DialogSearching
import DialogBasics
import DialogFilter
import DialogNetService
import DialogProtocols
import DialogRx
import DialogSDK_GRPC
@_exported import DialogSearching
import DialogSwiftGRPCExtra
import Foundation
import RxSwift
import Swift
import SwiftGRPC
public protocol AttachmentSearchServiceProtocol {
  func searchAttachments(forPeer peer: DialogProtocols.DialogPeer, forContentType types: [DialogSDK_GRPC.Dialog_SearchContentType]?, withText text: Swift.String) -> RxSwift.Observable<DialogSDK_GRPC.Dialog_ResponseMessageSearchResponse>
  func searchMore(pointer: DialogSearching.SimpleSearchPagePointer) -> RxSwift.Observable<DialogSDK_GRPC.Dialog_ResponseMessageSearchResponse>
}
extension AttachmentSearchServiceProtocol {
  public func searchAttachments(forPeer peer: DialogProtocols.DialogPeer) -> RxSwift.Observable<DialogSDK_GRPC.Dialog_ResponseMessageSearchResponse>
}
public class AttachmentSearchService : DialogSearching.AttachmentSearchServiceProtocol {
  public init(searchTaskPerformer: DialogSearching.SearchTaskPerformerProtocol)
  public func searchAttachments(forPeer peer: DialogProtocols.DialogPeer, forContentType types: [DialogSDK_GRPC.Dialog_SearchContentType]? = nil, withText text: Swift.String) -> RxSwift.Observable<DialogSDK_GRPC.Dialog_ResponseMessageSearchResponse>
  public func searchMore(pointer: DialogSearching.SimpleSearchPagePointer) -> RxSwift.Observable<DialogSDK_GRPC.Dialog_ResponseMessageSearchResponse>
  @objc deinit
}
final public class CombinedSearchContactsSorter : DialogSearching.CombinedSearchStateModifierProtocol {
  public init()
  final public func modify(state: DialogSearching.CombinedSearchState) -> RxSwift.Single<DialogSearching.CombinedSearchState>
  @objc deinit
}
public enum SearchItemId : Swift.Equatable {
  public enum Peer : Swift.Equatable {
    case user(DialogProtocols.DialogUserId)
    case group(DialogProtocols.DialogGroupId)
    public static func == (a: DialogSearching.SearchItemId.Peer, b: DialogSearching.SearchItemId.Peer) -> Swift.Bool
  }
  case peer(DialogSearching.SearchItemId.Peer)
  case dialog(Swift.Int32)
  case message(DialogProtocols.DialogUUID)
  public static func == (a: DialogSearching.SearchItemId, b: DialogSearching.SearchItemId) -> Swift.Bool
}
public protocol SearchItemIdRepresentableItem {
  var searchItemIds: [DialogSearching.SearchItemId] { get }
}
extension RemoteSearchIntermediateItem : DialogSearching.SearchItemIdRepresentableItem {
  public var searchItemIds: [DialogSearching.SearchItemId] {
    get
  }
}
extension RemoteSearchResultItem : DialogSearching.SearchItemIdRepresentableItem {
  public var searchItemIds: [DialogSearching.SearchItemId] {
    get
  }
}
extension LocalSearchResultItem : DialogSearching.SearchItemIdRepresentableItem {
  public var searchItemIds: [DialogSearching.SearchItemId] {
    get
  }
}
final public class CombinedSearchRemoteDuplicatesFilter : DialogSearching.CombinedSearchStateModifierProtocol {
  final public var idsToExclude: [DialogSearching.SearchItemId]
  final public let bag: RxSwift.DisposeBag
  final public func modify(state: DialogSearching.CombinedSearchState) -> RxSwift.Single<DialogSearching.CombinedSearchState>
  public init(idsToExclude: [DialogSearching.SearchItemId] = [], featureFlagsService: DialogProtocols.DialogFeatureFlagsServiceProtocol, myId: DialogProtocols.DialogUserId)
  public init(idsToExclude: [DialogSearching.SearchItemId] = [])
  @objc deinit
}
public struct CombinedSearchState : Swift.Equatable, DialogProtocols.BaseStruct {
  public static let empty: DialogSearching.CombinedSearchState
  public var localSearchState: DialogSearching.LocalSearchServiceState
  public var userRemoteSearchState: DialogSearching.RemoteSearchServiceCompositeState
  public var groupsRemoteSearchState: DialogSearching.RemoteSearchServiceCompositeState
  public var messagesSearchState: DialogSearching.RemoteSearchServiceCompositeState
  public var isEmpty: Swift.Bool {
    get
  }
  public static func == (a: DialogSearching.CombinedSearchState, b: DialogSearching.CombinedSearchState) -> Swift.Bool
}
public enum CombinedSearchLoadMoreTarget : Swift.Equatable {
  case users
  case groups
  case messages
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DialogSearching.CombinedSearchLoadMoreTarget, b: DialogSearching.CombinedSearchLoadMoreTarget) -> Swift.Bool
}
public protocol CombinedSearchServiceProtocol {
  var state: RxSwift.Observable<DialogSearching.CombinedSearchState> { get }
  var search: RxSwift.AnyObserver<Swift.String?> { get }
  var loadMore: RxSwift.AnyObserver<DialogSearching.CombinedSearchLoadMoreTarget> { get }
}
final public class CombinedSearchService : DialogSearching.CombinedSearchServiceProtocol {
  final public var state: RxSwift.Observable<DialogSearching.CombinedSearchState>
  final public var search: RxSwift.AnyObserver<Swift.String?>
  final public var loadMore: RxSwift.AnyObserver<DialogSearching.CombinedSearchLoadMoreTarget>
  public struct Config {
    public var combineDebounce: Dispatch.DispatchTimeInterval
    public static let `default`: DialogSearching.CombinedSearchService.Config
  }
  public init(localSearchService: DialogSearching.LocalSearchServiceProtocol, usersRemoteSearhService: DialogSearching.RemoteSearchServiceProtocol, groupsRemoteSearchService: DialogSearching.RemoteSearchServiceProtocol, messagesRemoteSearchService: DialogSearching.RemoteSearchServiceProtocol? = nil, resultModifier: DialogSearching.CombinedSearchStateModifierProtocol, localRequestModifier: ((inout DialogSearching.LocalSearchRequest) -> Swift.Void)? = nil, canSearchMessages: RxSwift.Observable<Swift.Bool>? = nil, config: DialogSearching.CombinedSearchService.Config = .default)
  @objc deinit
}
public protocol CombinedSearchStateModifierProtocol {
  func modify(state: DialogSearching.CombinedSearchState) -> RxSwift.Single<DialogSearching.CombinedSearchState>
}
final public class CombinedSearchStateModifiersStack : DialogSearching.CombinedSearchStateModifierProtocol {
  public init(modifiers: [DialogSearching.CombinedSearchStateModifierProtocol])
  final public func modify(state: DialogSearching.CombinedSearchState) -> RxSwift.Single<DialogSearching.CombinedSearchState>
  @objc deinit
}
public struct LocalCallSearchContext {
}
public protocol LocalCallSearchPerformerProtocol {
  func search(string: Swift.String, context: DialogSearching.LocalCallSearchContext) -> RxSwift.Single<[DialogSearching.LocalCallSearchResult]>
}
final public class LocalCallSearchPerformer : DialogSearching.LocalCallSearchPerformerProtocol {
  final public let relevanceIdentifier: DialogSearching.LocalSearchRelevanceIdentifierProtocol
  public init(relevanceIdentifier: DialogSearching.LocalSearchRelevanceIdentifierProtocol)
  final public func search(string: Swift.String, context: DialogSearching.LocalCallSearchContext) -> RxSwift.Single<[DialogSearching.LocalCallSearchResult]>
  @objc deinit
}
public protocol LocalCallSearchServiceProtocol {
  func search(_ query: Swift.String) -> RxSwift.Observable<[DialogSearching.LocalCallSearchResult]>
}
public struct LocalCallSearchResult : DialogProtocols.BaseStruct {
  public let call: DialogProtocols.DialogHistoryCall
  public let items: [DialogSearching.LocalSearchResultItem]
}
final public class LocalCallSearchService : DialogSearching.LocalCallSearchServiceProtocol {
  public struct Config : DialogProtocols.BaseStruct {
    public struct ContinuousOptions : Swift.OptionSet {
      public let rawValue: Swift.Int
      public init(rawValue: Swift.Int)
      public static let calls: DialogSearching.LocalCallSearchService.Config.ContinuousOptions
      public static let users: DialogSearching.LocalCallSearchService.Config.ContinuousOptions
      public static let none: DialogSearching.LocalCallSearchService.Config.ContinuousOptions
      public static let all: DialogSearching.LocalCallSearchService.Config.ContinuousOptions
      public typealias Element = DialogSearching.LocalCallSearchService.Config.ContinuousOptions
      public typealias ArrayLiteralElement = DialogSearching.LocalCallSearchService.Config.ContinuousOptions
      public typealias RawValue = Swift.Int
    }
    public var continuousOptions: DialogSearching.LocalCallSearchService.Config.ContinuousOptions
    public static let `default`: DialogSearching.LocalCallSearchService.Config
  }
  final public let config: DialogSearching.LocalCallSearchService.Config
  public init(calls: RxSwift.Observable<[DialogProtocols.DialogHistoryCall]>, users: RxSwift.Observable<[DialogProtocols.DialogUserId : DialogProtocols.DialogUser]>, searchPerformer: DialogSearching.LocalCallSearchPerformerProtocol, config: DialogSearching.LocalCallSearchService.Config = .default)
  final public func search(_ query: Swift.String) -> RxSwift.Observable<[DialogSearching.LocalCallSearchResult]>
  @objc deinit
}
public struct LocalSearchConfig : DialogProtocols.BaseStruct {
  public var minLengthToSearch: Swift.Int
  public var debounceTime: Dispatch.DispatchTimeInterval
  public static let `default`: DialogSearching.LocalSearchConfig
}
public protocol LocalSearchIdentifiableSourceProviderProtocol {
  func sources(for resultTypes: DialogSearching.LocalSearchRequest.ResultType) -> RxSwift.Observable<[DialogSearching.LocalSearchRelevanceIdentifiable]>
}
public enum LocalSearchIdentifiableSourceType : Swift.Hashable {
  case users
  case contacts
  case groups
  case dialogs
  public static func == (a: DialogSearching.LocalSearchIdentifiableSourceType, b: DialogSearching.LocalSearchIdentifiableSourceType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
final public class LocalSearchIdentifiableSourceProvider : DialogSearching.LocalSearchIdentifiableSourceProviderProtocol {
  public init(sourcesByTypes: [DialogSearching.LocalSearchIdentifiableSourceType : RxSwift.Observable<[DialogSearching.LocalSearchRelevanceIdentifiable]>])
  final public func sources(for resultTypes: DialogSearching.LocalSearchRequest.ResultType) -> RxSwift.Observable<[DialogSearching.LocalSearchRelevanceIdentifiable]>
  @objc deinit
}
public typealias LocalSearchRequestResponse = Swift.Result<RxSwift.Observable<[DialogSearching.LocalSearchResultItem]>, DialogSearching.LocalSearchServiceDenyReason>
public protocol LocalSearchResponseProvider {
  func search(request: DialogSearching.LocalSearchRequest) -> DialogSearching.LocalSearchRequestResponse
}
final public class LocalSearchPerformer : DialogSearching.LocalSearchResponseProvider {
  public struct Config : DialogProtocols.BaseStruct {
    public var queryMinLength: Swift.Int
    public var chunkSize: Swift.Int
    public var continuous: Swift.Bool
    public static let `default`: DialogSearching.LocalSearchPerformer.Config
  }
  final public let config: DialogSearching.LocalSearchPerformer.Config
  public init(sourceProvider: DialogSearching.LocalSearchIdentifiableSourceProviderProtocol, relevanceIdentifier: DialogSearching.LocalSearchRelevanceIdentifierProtocol, config: DialogSearching.LocalSearchPerformer.Config = .default)
  final public func search(request: DialogSearching.LocalSearchRequest) -> DialogSearching.LocalSearchRequestResponse
  @objc deinit
}
public enum LocalSearchRelevanceIdentifiable {
  public enum DialogInfo {
    case user(DialogProtocols.DialogUser)
    case group(DialogProtocols.DialogGroup)
  }
  case dialog(DialogProtocols.DialogState, info: DialogSearching.LocalSearchRelevanceIdentifiable.DialogInfo)
  case user(DialogProtocols.DialogUser)
  case group(DialogProtocols.DialogGroup)
  case contact(DialogProtocols.DialogUser)
  public enum ID : Swift.Equatable {
    case user(Swift.Int32)
    case contact(Swift.Int32)
    case group(Swift.Int32)
    case dialog(Swift.Int32)
    public static func == (a: DialogSearching.LocalSearchRelevanceIdentifiable.ID, b: DialogSearching.LocalSearchRelevanceIdentifiable.ID) -> Swift.Bool
  }
}
extension LocalSearchRelevanceIdentifiable : Swift.Equatable {
  public static func == (lhs: DialogSearching.LocalSearchRelevanceIdentifiable, rhs: DialogSearching.LocalSearchRelevanceIdentifiable) -> Swift.Bool
}
public protocol LocalSearchRelevanceIdentifierProtocol {
  func identifier(request: DialogSearching.LocalSearchRequest) -> ((DialogSearching.LocalSearchRelevanceIdentifiable) -> DialogSearching.LocalSearchResultItem?)
}
final public class LocalSearchRelevanceIdentifier : DialogSearching.LocalSearchRelevanceIdentifierProtocol {
  public init(myId: DialogProtocols.DialogUserId? = nil, favoritesLocalizedString: Swift.String = "")
  final public func identifier(request: DialogSearching.LocalSearchRequest) -> ((DialogSearching.LocalSearchRelevanceIdentifiable) -> DialogSearching.LocalSearchResultItem?)
  @objc deinit
}
public struct LocalSearchRequest : Swift.Equatable {
  public struct ResultType : Swift.OptionSet, Swift.Equatable, Swift.Hashable {
    public typealias RawValue = Swift.Int
    public let rawValue: DialogSearching.LocalSearchRequest.ResultType.RawValue
    public init(rawValue: DialogSearching.LocalSearchRequest.ResultType.RawValue)
    public static let users: DialogSearching.LocalSearchRequest.ResultType
    public static let groups: DialogSearching.LocalSearchRequest.ResultType
    public static let contacts: DialogSearching.LocalSearchRequest.ResultType
    public static let dialogs: DialogSearching.LocalSearchRequest.ResultType
    public static let `default`: DialogSearching.LocalSearchRequest.ResultType
    public typealias Element = DialogSearching.LocalSearchRequest.ResultType
    public typealias ArrayLiteralElement = DialogSearching.LocalSearchRequest.ResultType
  }
  public struct QueryParametrization : Swift.OptionSet {
    public typealias RawValue = Swift.Int
    public let rawValue: DialogSearching.LocalSearchRequest.QueryParametrization.RawValue
    public init(rawValue: DialogSearching.LocalSearchRequest.QueryParametrization.RawValue)
    public static let caseInsensitive: DialogSearching.LocalSearchRequest.QueryParametrization
    public static let diacriticInsensitive: DialogSearching.LocalSearchRequest.QueryParametrization
    public static let latinTransliterated: DialogSearching.LocalSearchRequest.QueryParametrization
    public static let cyrillicTransliterated: DialogSearching.LocalSearchRequest.QueryParametrization
    public static let all: DialogSearching.LocalSearchRequest.QueryParametrization
    public var caseInsensitive: Swift.Bool {
      get
    }
    public var diacriticInsensitive: Swift.Bool {
      get
    }
    public var transliterated: Swift.Bool {
      get
    }
    public typealias Element = DialogSearching.LocalSearchRequest.QueryParametrization
    public typealias ArrayLiteralElement = DialogSearching.LocalSearchRequest.QueryParametrization
  }
  public let query: Swift.String
  public init(query: Swift.String)
  public var limit: Swift.Int
  public var resultTypes: DialogSearching.LocalSearchRequest.ResultType
  public var queryParametrization: DialogSearching.LocalSearchRequest.QueryParametrization
  public var trimmed: Swift.String {
    get
  }
  public var isEmpty: Swift.Bool {
    get
  }
  public static func request(query: Swift.String, modifier: ((inout DialogSearching.LocalSearchRequest) throws -> Swift.Void)? = nil) rethrows -> DialogSearching.LocalSearchRequest
  public static func == (a: DialogSearching.LocalSearchRequest, b: DialogSearching.LocalSearchRequest) -> Swift.Bool
}
public struct LocalSearchResultItem : Swift.Equatable {
  public struct Relevance : Swift.RawRepresentable, Swift.Hashable, Swift.Comparable {
    public typealias RawValue = Swift.Float
    public let rawValue: DialogSearching.LocalSearchResultItem.Relevance.RawValue
    public init(rawValue: DialogSearching.LocalSearchResultItem.Relevance.RawValue)
    public static let max: DialogSearching.LocalSearchResultItem.Relevance
    public static let none: DialogSearching.LocalSearchResultItem.Relevance
    public static func < (lhs: DialogSearching.LocalSearchResultItem.Relevance, rhs: DialogSearching.LocalSearchResultItem.Relevance) -> Swift.Bool
  }
  public var relevance: DialogSearching.LocalSearchResultItem.Relevance
  public var object: DialogSearching.LocalSearchRelevanceIdentifiable
  public init(relevance: DialogSearching.LocalSearchResultItem.Relevance, object: DialogSearching.LocalSearchRelevanceIdentifiable)
  public static func == (a: DialogSearching.LocalSearchResultItem, b: DialogSearching.LocalSearchResultItem) -> Swift.Bool
}
final public class LocalSearchUpdatableState {
  final public let state: RxSwift.Observable<[DialogSearching.LocalSearchResultItem]>
  public init(state: RxSwift.Observable<[DialogSearching.LocalSearchResultItem]>)
  @objc deinit
}
public struct LocalSearchServiceState : Swift.Equatable, DialogProtocols.BaseStruct {
  public enum Task : Swift.Equatable {
    case idle
    case denied(DialogSearching.LocalSearchServiceDenyReason)
    case searching(DialogSearching.LocalSearchRequest)
    case waitingForUpdates(DialogSearching.LocalSearchRequest)
    public static func == (a: DialogSearching.LocalSearchServiceState.Task, b: DialogSearching.LocalSearchServiceState.Task) -> Swift.Bool
  }
  public var task: DialogSearching.LocalSearchServiceState.Task
  public var results: [DialogSearching.LocalSearchResultItem]?
  public var denyReason: DialogSearching.LocalSearchServiceDenyReason? {
    get
  }
  public var currentRequest: DialogSearching.LocalSearchRequest? {
    get
  }
  public var isIdle: Swift.Bool {
    get
  }
  public var isEmpty: Swift.Bool {
    get
  }
  public static let empty: DialogSearching.LocalSearchServiceState
  public static func == (a: DialogSearching.LocalSearchServiceState, b: DialogSearching.LocalSearchServiceState) -> Swift.Bool
}
public protocol LocalSearchServiceProtocol {
  var search: RxSwift.AnyObserver<DialogSearching.LocalSearchRequest> { get }
  var state: RxSwift.Observable<DialogSearching.LocalSearchServiceState> { get }
}
open class LocalSearchService : DialogSearching.LocalSearchServiceProtocol {
  final public let search: RxSwift.AnyObserver<DialogSearching.LocalSearchRequest>
  final public let state: RxSwift.Observable<DialogSearching.LocalSearchServiceState>
  final public let responseProvider: DialogSearching.LocalSearchResponseProvider
  public init(config: RxSwift.Observable<DialogSearching.LocalSearchConfig>, workScheduler: RxSwift.SchedulerType = SerialDispatchQueueScheduler(qos: .userInitiated,
                                                                            internalSerialQueueName: "im.dlg.search.local.performer",
                                                                            leeway: .nanoseconds(0)), responseProvider: DialogSearching.LocalSearchResponseProvider)
  @objc deinit
}
public struct LocalSearchServiceDenyReason : Swift.RawRepresentable, Swift.Hashable, Swift.Error {
  public typealias RawValue = Swift.String
  public let rawValue: DialogSearching.LocalSearchServiceDenyReason.RawValue
  public init(rawValue: DialogSearching.LocalSearchServiceDenyReason.RawValue)
  public static let requestEmpty: DialogSearching.LocalSearchServiceDenyReason
  public static let queryTooSmall: DialogSearching.LocalSearchServiceDenyReason
  public static let internalError: DialogSearching.LocalSearchServiceDenyReason
}
public struct RemoteSearchPage : Swift.Equatable, Swift.CustomDebugStringConvertible, DialogProtocols.BaseStruct {
  public typealias MessageInfo = DialogSearching.RemoteSearchResultItem.MessageInfo
  public static let empty: DialogSearching.RemoteSearchPage
  public var results: [DialogSearching.RemoteSearchResultItem]
  public var totalItemsCount: Swift.Int64
  public let id: Foundation.UUID
  public var groups: [DialogProtocols.DialogGroup] {
    get
    set
  }
  public var users: [DialogProtocols.DialogUser] {
    get
    set
  }
  public var messageInfos: [DialogSearching.RemoteSearchPage.MessageInfo] {
    get
    set
  }
  public var hasMore: Swift.Bool
  public static func == (lhs: DialogSearching.RemoteSearchPage, rhs: DialogSearching.RemoteSearchPage) -> Swift.Bool
  public var debugDescription: Swift.String {
    get
  }
}
public enum RemoteSearchServiceRequest : Swift.Equatable {
  case clear
  case new(DialogSearching.RemoteSearchRequest)
  case loadMore
  public var isNew: Swift.Bool {
    get
  }
  public var isClear: Swift.Bool {
    get
  }
  public var isLoadMore: Swift.Bool {
    get
  }
  public static func == (a: DialogSearching.RemoteSearchServiceRequest, b: DialogSearching.RemoteSearchServiceRequest) -> Swift.Bool
}
public enum RemoteSearchResultItem : Swift.CustomDebugStringConvertible, Swift.Equatable {
  public struct MessageInfo : DialogProtocols.BaseStruct, Swift.Equatable {
    public enum PeerResolve : Swift.Hashable {
      case unknown(DialogSDK_GRPC.Dialog_Peer)
      case group(DialogProtocols.DialogGroup)
      case user(DialogProtocols.DialogUser)
      public var peer: DialogSDK_GRPC.Dialog_Peer {
        get
      }
      public var hashValue: Swift.Int {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: DialogSearching.RemoteSearchResultItem.MessageInfo.PeerResolve, b: DialogSearching.RemoteSearchResultItem.MessageInfo.PeerResolve) -> Swift.Bool
    }
    public enum SenderResolve : Swift.Hashable {
      case id(DialogProtocols.DialogUserId)
      case user(DialogProtocols.DialogUser)
      public var user: DialogProtocols.DialogUser? {
        get
      }
      public var hashValue: Swift.Int {
        get
      }
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: DialogSearching.RemoteSearchResultItem.MessageInfo.SenderResolve, b: DialogSearching.RemoteSearchResultItem.MessageInfo.SenderResolve) -> Swift.Bool
    }
    public var mid: DialogProtocols.DialogUUID
    public var peerResolve: DialogSearching.RemoteSearchResultItem.MessageInfo.PeerResolve
    public var senderResolve: DialogSearching.RemoteSearchResultItem.MessageInfo.SenderResolve
    public var date: Swift.Int64
    public var content: DialogSDK_GRPC.Dialog_MessageContent
    public var highlightTokens: [Swift.String]
    public init(original: DialogSDK_GRPC.Dialog_MessageSearchResult, peerResolve: DialogSearching.RemoteSearchResultItem.MessageInfo.PeerResolve? = nil, senderResolve: DialogSearching.RemoteSearchResultItem.MessageInfo.SenderResolve? = nil)
    public static func == (a: DialogSearching.RemoteSearchResultItem.MessageInfo, b: DialogSearching.RemoteSearchResultItem.MessageInfo) -> Swift.Bool
  }
  case user(DialogProtocols.DialogUser)
  case group(DialogProtocols.DialogGroup)
  case message(DialogSearching.RemoteSearchResultItem.MessageInfo)
  public var debugDescription: Swift.String {
    get
  }
  public static func == (lhs: DialogSearching.RemoteSearchResultItem, rhs: DialogSearching.RemoteSearchResultItem) -> Swift.Bool
}
public enum RemoteSearchServiceCurrentTask : Swift.Equatable, Swift.CustomDebugStringConvertible {
  case idle
  case searching(request: DialogSearching.RemoteSearchRequest, pageIdx: Swift.Int)
  public static func initial(request: DialogSearching.RemoteSearchRequest) -> DialogSearching.RemoteSearchServiceCurrentTask
  public var isLoadingMore: Swift.Bool {
    get
  }
  public var isInitialLoading: Swift.Bool {
    get
  }
  public var request: DialogSearching.RemoteSearchRequest? {
    get
  }
  public var isIdle: Swift.Bool {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public static func == (a: DialogSearching.RemoteSearchServiceCurrentTask, b: DialogSearching.RemoteSearchServiceCurrentTask) -> Swift.Bool
}
public struct RemoteSearchServiceResults : Swift.Equatable, DialogProtocols.BaseStruct {
  public var pages: [DialogSearching.RemoteSearchPage]
  public var hasMore: Swift.Bool
  public let initialRequest: DialogSearching.RemoteSearchRequest
  public init(initialRequest: DialogSearching.RemoteSearchRequest)
  public static func == (a: DialogSearching.RemoteSearchServiceResults, b: DialogSearching.RemoteSearchServiceResults) -> Swift.Bool
}
public struct RemoteSearchServiceCompositeState : Swift.Equatable, DialogProtocols.BaseStruct {
  public var currentTask: DialogSearching.RemoteSearchServiceCurrentTask
  public var resultsState: DialogSearching.RemoteSearchServiceResults?
  public static let idleWithoutResults: DialogSearching.RemoteSearchServiceCompositeState
  public var pages: [DialogSearching.RemoteSearchPage]? {
    get
  }
  public var hasResults: Swift.Bool {
    get
  }
  public var hasPages: Swift.Bool {
    get
  }
  public var expectedItemsCount: Swift.Int64? {
    get
  }
  public var hasNonEmptyPages: Swift.Bool {
    get
  }
  public var groups: [DialogProtocols.DialogGroup]? {
    get
  }
  public var users: [DialogProtocols.DialogUser]? {
    get
  }
  public func modified(byFilteringPageItems filter: (DialogSearching.RemoteSearchResultItem) throws -> Swift.Bool) rethrows -> DialogSearching.RemoteSearchServiceCompositeState
  public var isEmpty: Swift.Bool {
    get
  }
  public static func == (a: DialogSearching.RemoteSearchServiceCompositeState, b: DialogSearching.RemoteSearchServiceCompositeState) -> Swift.Bool
}
public protocol RemoteSearchServiceProtocol {
  var search: RxSwift.AnyObserver<DialogSearching.RemoteSearchServiceRequest> { get }
  var state: RxSwift.Observable<DialogSearching.RemoteSearchServiceCompositeState> { get }
}
public enum RemoteSearchIntermediateItem : Swift.Equatable, Swift.CustomDebugStringConvertible {
  case userPeer(DialogSDK_GRPC.Dialog_UserOutPeer)
  case groupPeer(DialogSDK_GRPC.Dialog_GroupOutPeer)
  case message(DialogSDK_GRPC.Dialog_MessageSearchResult)
  public init(_ groupPeer: DialogSDK_GRPC.Dialog_GroupOutPeer)
  public init(_ userPeer: DialogSDK_GRPC.Dialog_UserOutPeer)
  public init(_ messageSearchResult: DialogSDK_GRPC.Dialog_MessageSearchResult)
  public init(_ message: DialogSDK_GRPC.Dialog_MessageSearchItem)
  public var debugDescription: Swift.String {
    get
  }
  public static func create(response: DialogSDK_GRPC.Dialog_ResponseMessageSearchResponse) -> [DialogSearching.RemoteSearchIntermediateItem]
  public static func create(userPeers: [DialogSDK_GRPC.Dialog_UserOutPeer], groupPeers: [DialogSDK_GRPC.Dialog_GroupOutPeer], messages: [DialogSDK_GRPC.Dialog_MessageSearchItem]) -> [DialogSearching.RemoteSearchIntermediateItem]
  public static func == (a: DialogSearching.RemoteSearchIntermediateItem, b: DialogSearching.RemoteSearchIntermediateItem) -> Swift.Bool
}
public protocol ReferencedEntitiesLoaderProtocol {
  func load(userPeers: [DialogSDK_GRPC.Dialog_UserOutPeer], groupPeers: [DialogSDK_GRPC.Dialog_GroupOutPeer]) -> RxSwift.Single<(users: [DialogSDK_GRPC.Dialog_User], groups: [DialogSDK_GRPC.Dialog_Group])>
}
extension ReferencedEntitiesLoaderProtocol {
  public func loadUsers(peers: [DialogSDK_GRPC.Dialog_UserOutPeer]) -> RxSwift.Single<[DialogSDK_GRPC.Dialog_User]>
  public func loadGroups(peers: [DialogSDK_GRPC.Dialog_GroupOutPeer]) -> RxSwift.Single<[DialogSDK_GRPC.Dialog_Group]>
}
final public class ReferencedEntitiesLoader : DialogSearching.ReferencedEntitiesLoaderProtocol {
  public init(seqService: RxSwift.Observable<DialogSDK_GRPC.Dialog_SequenceAndUpdatesService>, netService: DialogNetService.NetServiceProtocol)
  final public func loadUsers(peers: [DialogSDK_GRPC.Dialog_UserOutPeer]) -> RxSwift.Single<[DialogSDK_GRPC.Dialog_User]>
  final public func loadGroups(peers: [DialogSDK_GRPC.Dialog_GroupOutPeer]) -> RxSwift.Single<[DialogSDK_GRPC.Dialog_Group]>
  final public func load(userPeers: [DialogSDK_GRPC.Dialog_UserOutPeer], groupPeers: [DialogSDK_GRPC.Dialog_GroupOutPeer]) -> RxSwift.Single<(users: [DialogSDK_GRPC.Dialog_User], groups: [DialogSDK_GRPC.Dialog_Group])>
  @objc deinit
}
public protocol RemoteSearchServiceItemConverterProtocol {
  func convert(items: [DialogSearching.RemoteSearchIntermediateItem]) -> RxSwift.Single<[DialogSearching.RemoteSearchResultItem]>
}
final public class RemoteSearchServiceItemConverter : DialogSearching.RemoteSearchServiceItemConverterProtocol {
  public init(loader: DialogSearching.ReferencedEntitiesLoaderProtocol, users: RxSwift.Observable<[DialogProtocols.DialogUserId : DialogProtocols.DialogUser]> = .just([:]), groups: RxSwift.Observable<[DialogProtocols.DialogGroupId : DialogProtocols.DialogGroup]> = .just([:]))
  final public func convert(items: [DialogSearching.RemoteSearchIntermediateItem]) -> RxSwift.Single<[DialogSearching.RemoteSearchResultItem]>
  @objc deinit
}
public protocol SearchPermissorProtocol : AnyObject {
  var canSearch: RxSwift.Observable<Swift.Bool> { get }
}
extension EventBusService : DialogSearching.SearchPermissorProtocol {
  public var canSearch: RxSwift.Observable<Swift.Bool> {
    get
  }
}
final public class RemoteSearchService : DialogSearching.RemoteSearchServiceProtocol {
  public struct Config : Swift.Equatable, DialogProtocols.BaseStruct {
    public var minLimit: Swift.Int
    public var debounce: Dispatch.DispatchTimeInterval
    public static let `default`: DialogSearching.RemoteSearchService.Config
    public static func == (a: DialogSearching.RemoteSearchService.Config, b: DialogSearching.RemoteSearchService.Config) -> Swift.Bool
  }
  final public let search: RxSwift.AnyObserver<DialogSearching.RemoteSearchServiceRequest>
  final public var state: RxSwift.Observable<DialogSearching.RemoteSearchServiceCompositeState>
  public static let defaultScheduler: RxSwift.SerialDispatchQueueScheduler
  public init(performer: DialogSearching.SearchTaskPerformerProtocol, converter: DialogSearching.RemoteSearchServiceItemConverterProtocol, debounceScheduler: RxSwift.SchedulerType = defaultScheduler, permissor: DialogSearching.SearchPermissorProtocol, config: RxSwift.Observable<DialogSearching.RemoteSearchService.Config> = .just(Config.default), debugId: Swift.String = UUID().uuidString)
  @objc deinit
}
extension Observable {
  public func `do`(onElementAtIndexes indexes: [Swift.Int], closure: @escaping (Swift.Int, Element) throws -> Swift.Void) -> RxSwift.Observable<Element>
  public func `do`(onElementAtIndex index: Swift.Int, closure: @escaping (Element) throws -> Swift.Void) -> RxSwift.Observable<Element>
  public func `do`(onElementAtIndexes indexes: Swift.Range<Swift.Int>, closure: @escaping (Swift.Int, Element) throws -> Swift.Void) -> RxSwift.Observable<Element>
}
final public class SearchTaskPerformer : DialogSearching.SearchTaskPerformerProtocol {
  public init(searchService: DialogSwiftGRPCExtra.AnyServiceRessurector<DialogSDK_GRPC.Dialog_SearchService>, netService: DialogNetService.NetServiceProtocol)
  final public func resolve(shortname: Swift.String) -> RxSwift.Single<DialogProtocols.DialogPeer>
  final public func search(simplest: DialogSearching.RemoteSearchRequest) -> RxSwift.Single<DialogSDK_GRPC.Dialog_ResponseMessageSearchResponse>
  final public func searchAttachments(searchRequest: DialogSearching.AttachmentSearchRequest) -> RxSwift.Single<DialogSDK_GRPC.Dialog_ResponseMessageSearchResponse>
  final public func searchMore(pointer: DialogSearching.SimpleSearchPagePointer) -> RxSwift.Single<DialogSDK_GRPC.Dialog_ResponseMessageSearchResponse>
  @objc deinit
}
extension Dialog_RequestSimpleSearch {
  public mutating func append(condition: DialogSDK_GRPC.Dialog_SimpleSearchCondition.OneOf_Criterion)
}
public typealias SimpleSearchPagePointer = Foundation.Data
extension Dialog_SearchContentType : DialogSwiftGRPCExtra.GoogleProtobufValueInitable {
  public typealias SwiftType = DialogSearching.RemoteSearchRequest.MessageSearchConditions.ContentType
  public init(_ value: DialogSDK_GRPC.Dialog_SearchContentType.SwiftType)
}
public struct RemoteSearchRequest : Swift.Hashable, Swift.CustomDebugStringConvertible, DialogProtocols.BaseStruct {
  public struct MessageSearchConditions : DialogProtocols.BaseStruct, Swift.Hashable {
    public enum ContentType : Swift.Int, DialogSwiftGRPCExtra.GoogleProtobufRepresentable {
      public typealias GoogleProtobufValueType = DialogSDK_GRPC.Dialog_SearchContentType
      case any
      case text
      case links
      case audio
      case documents
      case media
      public typealias RawValue = Swift.Int
      public init?(rawValue: Swift.Int)
      public var rawValue: Swift.Int {
        get
      }
    }
    public enum Direction : Swift.Int, DialogSwiftGRPCExtra.CustomGoogleProtobufRepresentable {
      public typealias CustomGoogleProtobufValueType = DialogSDK_GRPC.Dialog_SearchDirection
      case forward
      case backward
      public var protobufValue: DialogSearching.RemoteSearchRequest.MessageSearchConditions.Direction.CustomGoogleProtobufValueType {
        get
      }
      public typealias RawValue = Swift.Int
      public init?(rawValue: Swift.Int)
      public var rawValue: Swift.Int {
        get
      }
    }
    public var peer: DialogSDK_GRPC.Dialog_Peer?
    public var contentType: DialogSearching.RemoteSearchRequest.MessageSearchConditions.ContentType
    public var direction: DialogSearching.RemoteSearchRequest.MessageSearchConditions.Direction
    public var dateFrom: Swift.Int64?
    public static let `default`: DialogSearching.RemoteSearchRequest.MessageSearchConditions
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: DialogSearching.RemoteSearchRequest.MessageSearchConditions, b: DialogSearching.RemoteSearchRequest.MessageSearchConditions) -> Swift.Bool
  }
  public struct TargetType : Swift.OptionSet, Swift.Hashable {
    public typealias RawValue = Swift.Int
    public let rawValue: Swift.Int
    public init(rawValue: DialogSearching.RemoteSearchRequest.TargetType.RawValue)
    public static let users: DialogSearching.RemoteSearchRequest.TargetType
    public static let groups: DialogSearching.RemoteSearchRequest.TargetType
    public static let messages: DialogSearching.RemoteSearchRequest.TargetType
    public static let `default`: DialogSearching.RemoteSearchRequest.TargetType
    public typealias Element = DialogSearching.RemoteSearchRequest.TargetType
    public typealias ArrayLiteralElement = DialogSearching.RemoteSearchRequest.TargetType
  }
  public let query: Swift.String
  public var targets: DialogSearching.RemoteSearchRequest.TargetType
  public var messageSearchConditions: DialogSearching.RemoteSearchRequest.MessageSearchConditions?
  public init(query: Swift.String, targets: DialogSearching.RemoteSearchRequest.TargetType = .default)
  public var debugDescription: Swift.String {
    get
  }
  public static func == (a: DialogSearching.RemoteSearchRequest, b: DialogSearching.RemoteSearchRequest) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public struct AttachmentSearchRequest : Swift.Hashable {
  public let criteria: [DialogSDK_GRPC.Dialog_SimpleSearchCondition]
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: DialogSearching.AttachmentSearchRequest, b: DialogSearching.AttachmentSearchRequest) -> Swift.Bool
}
public protocol SearchTaskPerformerProtocol {
  func search(simplest: DialogSearching.RemoteSearchRequest) -> RxSwift.Single<DialogSDK_GRPC.Dialog_ResponseMessageSearchResponse>
  func searchMore(pointer: DialogSearching.SimpleSearchPagePointer) -> RxSwift.Single<DialogSDK_GRPC.Dialog_ResponseMessageSearchResponse>
  func searchAttachments(searchRequest: DialogSearching.AttachmentSearchRequest) -> RxSwift.Single<DialogSDK_GRPC.Dialog_ResponseMessageSearchResponse>
  func resolve(shortname: Swift.String) -> RxSwift.Single<DialogProtocols.DialogPeer>
}
final public class SupplementableSearchService {
  public struct Page : Swift.Equatable {
    public let response: DialogSDK_GRPC.Dialog_ResponseMessageSearchResponse
    public var nextPagePointer: Foundation.Data {
      get
    }
    public var hasMore: Swift.Bool {
      get
    }
    public init(response: DialogSDK_GRPC.Dialog_ResponseMessageSearchResponse)
    public static func == (a: DialogSearching.SupplementableSearchService.Page, b: DialogSearching.SupplementableSearchService.Page) -> Swift.Bool
  }
  public enum PageLoadTask : Swift.Equatable {
    case idle
    case loading(Swift.Int)
    case isFailed
    public var isLoading: Swift.Bool {
      get
    }
    public var isLoadingFirstPage: Swift.Bool {
      get
    }
    public static func == (a: DialogSearching.SupplementableSearchService.PageLoadTask, b: DialogSearching.SupplementableSearchService.PageLoadTask) -> Swift.Bool
  }
  public struct PagesState : Swift.Equatable, DialogProtocols.BaseStruct {
    public var pages: [DialogSearching.SupplementableSearchService.Page]
    public var currentTask: DialogSearching.SupplementableSearchService.PageLoadTask
    public var isInitial: Swift.Bool {
      get
    }
    public var hasResults: Swift.Bool {
      get
    }
    public var isIdle: Swift.Bool {
      get
    }
    public var isLoading: Swift.Bool {
      get
    }
    public var isFailed: Swift.Bool {
      get
    }
    public var nextPagePointer: Foundation.Data? {
      get
    }
    public var hasMore: Swift.Bool {
      get
    }
    public init()
    public static func == (a: DialogSearching.SupplementableSearchService.PagesState, b: DialogSearching.SupplementableSearchService.PagesState) -> Swift.Bool
  }
  final public let request: DialogSearching.RemoteSearchRequest
  final public var pagesState: RxSwift.Observable<DialogSearching.SupplementableSearchService.PagesState> {
    get
  }
  final public let hasMore: RxSwift.Observable<Swift.Bool>
  public static let sharedScheduler: RxSwift.SerialDispatchQueueScheduler
  public init(perfomer: DialogSearching.SearchTaskPerformerProtocol, request: DialogSearching.RemoteSearchRequest, scheduler: RxSwift.SchedulerType = SupplementableSearchService.sharedScheduler)
  final public func search()
  @objc deinit
}
extension SearchTaskPerformerProtocol {
  public func supplementableSearch(request: DialogSearching.RemoteSearchRequest) -> DialogSearching.SupplementableSearchService
}
extension DialogSearching.CombinedSearchLoadMoreTarget : Swift.Hashable {}
extension DialogSearching.RemoteSearchRequest.MessageSearchConditions.ContentType : Swift.Equatable {}
extension DialogSearching.RemoteSearchRequest.MessageSearchConditions.ContentType : Swift.Hashable {}
extension DialogSearching.RemoteSearchRequest.MessageSearchConditions.ContentType : Swift.RawRepresentable {}
extension DialogSearching.RemoteSearchRequest.MessageSearchConditions.Direction : Swift.Equatable {}
extension DialogSearching.RemoteSearchRequest.MessageSearchConditions.Direction : Swift.Hashable {}
extension DialogSearching.RemoteSearchRequest.MessageSearchConditions.Direction : Swift.RawRepresentable {}
